{"pages":[{"title":"Godot游戏开发实践之一：使用High Level Multiplayer API制作多人游戏（下）","url":"/2020/07/23/godot-game-devLog-1-making-game-with-high-level-multiplayer-api-part-2/","text":"一、前言注：本篇为草稿！ 继续接着上篇： Godot游戏开发实践之一：使用High Level Multiplayer API制作多人游戏（上） ，本篇主要讲解游戏 Demo 的代码分析与开发总结。 主要内容： 局域网多人游戏开发代码简析与开发小结阅读时间： 12 分钟永久链接： http://liuqingwen.me/2020/07/23/godot-game-devLog-1-making-game-with-high-level-multiplayer-api-part-2/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文示例源码我已经上传到 Github ，另外可以在这里体验游戏： https://gotm.io/spkingr/bomberman ，创建服务器后可以邀请好友一起开启炸弹之旅。 部分游戏代码分析首先，最重要的核心部分是处理游戏中局域网连接的代码，这是一个单例 Singleton 也叫 AutoLoad ，代码不需要使用在节点上，相当于一个一直存在的单例脚本，我创建了一个名为 GameState.gd 的脚本，然后在项目设置里添加、启用即可： 一、 GameState 代码 我们来看代码： GameState.gd123456789101112131415161718192021222324252627282930313233343536373839extends Node# 自定义信号signal player_list_update(players, colors)signal player_color_update(id, color)signal player_ready_status_update(id, isReady)signal player_disconnected(id)signal connection_succeeded()signal game_ended(why)signal game_ready(isReady)signal game_loaded()# 定义端口，最大连接数量，需要加载的游戏场景，还有玩家可选颜色const PORT := 34567const MAX_PLAYERS := 4const GAME_SCENE := 'res://World/Game.tscn'const COLORS := [Color('#B0BEC5'), Color('#8D6E63'), Color('#FFAB91'), ...] # 省略# 基本属性：联网id，名字，颜色，其他玩家的相关信息等var myId := -1var myName := ''var myColor := Color.whitevar otherPlayerNames := &#123;&#125; # id-namevar otherPlayerColors := &#123;&#125; # id-colorvar isGameStarted := false# 已经准备好的玩家和当前可用颜色，只在主场景中使用（实际是服务器）master var readyPlayers := []master var availableColors := []# 这里5个信号都是Godot High-level multiplayer API自带信号func _ready() -&gt; void: self.get_tree().connect('network_peer_connected', self, '_onNewPlayerConnected') self.get_tree().connect('network_peer_disconnected', self, '_onPlayerDisconnected') self.get_tree().connect('server_disconnected', self, '_onServerDisconnected') self.get_tree().connect('connected_to_server', self, '_onConnectionSuccess') self.get_tree().connect('connection_failed', self, '_onConnectionFail') 有几个注意点，代码是通用的，所以客户端的代码也是一样的，每个人不仅仅要记录自己的信息，还要记录其他玩家的相关信息，这就是 otherPlayerNames/otherPlayerColors 属性的必要性了。另外 _ready() 方法中的 5 个 Godot 自带的信号都是处理网络连接相关的，可以参考官方文档的介绍： 管理连接 Managing connections ，我们分布来看这些信号触发的调用地点和作用： GameState.gd1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 每当新客户端链接，所有其他id都会调用该方法# 不论当前节点是服务端还是客户端func _onNewPlayerConnected(id : int) -&gt; void: if isGameStarted: return # 通过rpc_id将自己的信息发送给对方 self.rpc_id(id, '_addMyNameToList', myName, myColor) # 仅服务端处理游戏准备事件、分配颜色 if self.get_tree().is_network_server(): self.emit_signal('game_ready', false) var color := _getRandomColor() self.rpc('_updateColor', id, color)# 每当新客户端断开链接，所有其他id都会调用该方法# 如果游戏在进行中则发出player_disconnected的信号# 否则只要移除该id信息即可func _onPlayerDisconnected(id : int) -&gt; void: if isGameStarted: self.emit_signal('player_disconnected', id) else: _removeDisconnectedPlayer(id)# 客服端链接成功，仅客户端调用# 表明客户端进入了游戏大厅，可以准备游戏了func _onConnectionSuccess() -&gt; void: self.emit_signal('connection_succeeded')# 服务器断开，仅客户端调用# 一般是退出游戏，清空网络连接相关信息func _onServerDisconnected() -&gt; void: self.emit_signal('game_ended', 'Server disconnected.')# 客服端链接失败，仅客户端调用func _onConnectionFail() -&gt; void: self.emit_signal('game_ended', 'Connection failed.')# 远程方法，添加自身的信息到其他玩家场景中# 注意，这个方法实际是在其他端运行的，或者说你通过该方法接收到了来自其他玩家的信息remote func _addMyNameToList(playerName : String, playerColor : Color) -&gt; void: var id = self.get_tree().get_rpc_sender_id() otherPlayerNames[id] = playerName if ! otherPlayerColors.has(id): otherPlayerColors[id] = playerColor self.emit_signal('player_list_update', otherPlayerNames, otherPlayerColors)# 更新颜色，颜色随机，由服务器决定# remotesync表明该方法在每个玩家中都会运行，有服务器统一发起调用remotesync func _updateColor(id : int, color : Color) -&gt; void: if id == myId: myColor = color else: otherPlayerColors[id] = color self.emit_signal('player_color_update', id, color)# 省略部分代码…… 这里比较重要的是 network_peer_connected 信号连接后的发放 _addMyNameToList 方法的运行。注意：虽然此方法也将自身颜色发送到其他玩家场景代码中，但是这里颜色很可能还没有被服务器赋值，是默认颜色，所以我们依然需要再定义一个更新颜色的信号，以保证每个玩家收到其他玩家的颜色是正常的。 在连接之前我们需要创建服务器或者连接到服务器： GameState.gd12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 创建服务器func hostGame(playerName: String) -&gt; bool: myName = playerName otherPlayerNames.clear() otherPlayerColors.clear() availableColors = COLORS.duplicate() readyPlayers.clear() var host := NetworkedMultiplayerENet.new() var error := host.create_server(PORT, MAX_PLAYERS) if error != OK: return false self.get_tree().network_peer = host self.get_tree().refuse_new_network_connections = false myId = self.get_tree().get_network_unique_id() # id = 1 is the server myColor = _getRandomColor() return true# 创建客户端，加入游戏func joinGame(address: String, playerName: String) -&gt; bool: myName = playerName otherPlayerNames.clear() otherPlayerColors.clear() readyPlayers.clear() var host := NetworkedMultiplayerENet.new() var error := host.create_client(address, PORT) if error != OK: return false self.get_tree().network_peer = host myId = self.get_tree().get_network_unique_id() return truefunc resetNetwork() -&gt; void: isGameStarted = false otherPlayerNames.clear() otherPlayerColors.clear() yield(self.get_tree(), 'idle_frame') self.get_tree().network_peer = null 这部分代码非常简单，官网有介绍，接下来是准备开始游戏部分，这一部分可以用“一波三折”表示： GameState.gd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 客户端调用，准备状态func readyGame(isReady : bool) -&gt; void: self.rpc('_readyGame', isReady)# 玩家是否处于准备状态remote func _readyGame(isReady : bool) -&gt; void: # 这部分代码所有玩家都会收到，更新相应的玩家准备状态 var id := self.get_tree().get_rpc_sender_id() self.emit_signal('player_ready_status_update', id, isReady) # 这部分代码仅服务器端处理，可以根据玩家是否【全部】准备好来决定是否可以开启游戏 if self.get_tree().is_network_server(): if isReady: assert(! id in readyPlayers, 'Player %s is already in ready players!' % id) readyPlayers.append(id) self.emit_signal('game_ready', readyPlayers.size() == otherPlayerNames.size()) else: readyPlayers.erase(id) self.emit_signal('game_ready', false)# 服务器端调用，开始游戏func startGame() -&gt; void: self.get_tree().refuse_new_network_connections = true readyPlayers.clear() self.rpc('_prestartGame')# 开始游戏第一步：实例化游戏场景，并且暂停，通知服务器等待其他玩家remotesync func _prestartGame() -&gt; void: isGameStarted = true # 实例化游戏战场，并暂停等待 var game : Node2D = load(GAME_SCENE).instance() game.name = 'Game' game.set_network_master(1) self.get_parent().add_child(game) self.get_tree().paused = true if self.get_tree().is_network_server(): _postStartGame(myId) else: # 1代表服务器id，向服务器发送可以开始的消息 self.rpc_id(1, '_postStartGame', myId)# 开始游戏第二步：等待所有玩家全部加载、实例化游戏场景# 由上面的调用我们知道，这个方法一定只会运行在服务器端remote func _postStartGame(id : int) -&gt; void: readyPlayers.append(id) # 确保所有玩家都已经准备好，包括自己 if readyPlayers.size() == otherPlayerNames.size() + 1: self.rpc('_startGame')# 开始游戏第三步：全部进入游戏，开始# remotesync表示所有玩家均会运行该方法，开启游戏remotesync func _startGame() -&gt; void: readyPlayers.clear() self.emit_signal('game_loaded') 关键代码搞定，如果大家有疑问可以多参考一下代码注释。 二、 Game.gd 主游戏场景代码 游戏主场景中处理关于玩家信息、死亡、消息、敌人生成等，但是这些都比较简单，我相信有兴趣的朋友可以去看看，并且能看懂，关键部分在于添加玩家代码： Player.gd1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253func _ready() -&gt; void: if GameConfig.isSoundOn: _audioPlayer.play() _resultPopup.showPopup('Waiting for other players...', 'Waiting', true, _resultPopup.BUTTON_BACK_BIT + _resultPopup.BUTTON_STAY_BIT) GameState.connect('game_loaded', self, '_onGameLoaded') GameState.connect('game_ended', self, '_onGameEnded') GameState.connect('player_disconnected', self, '_onPlayerQuit') _setDifficulties() _addPlayers() GameConfig.sendMessage(GameConfig.MessageType.System, GameState.myId, 'enters the game!') GameConfig.rpc('sendMessage', GameConfig.MessageType.System, GameState.myId, 'enters the game!')# 添加玩家，一个master其他都是puppet# 只有主人节点添加相关事件# 设置玩家的起始位置，由玩家的id大小决定func _addPlayers() -&gt; void: var positions := [GameState.myId] + GameState.otherPlayerNames.keys() positions.sort() var player := PlayerNode.instance() player.connect('lay_bomb', self, '_on_Player_lay_bomb') player.connect('dead', self, '_on_Player_dead') player.connect('damaged', self, '_on_Player_damaged') player.connect('collect_item', self, '_on_Player_collect_item') player.name = str(GameState.myId) player.playerId = GameState.myId player.playerName = GameState.myName player.playerColor = GameState.myColor player.global_position = _playerPositionNodes[positions.find(GameState.myId)].position player.set_network_master(GameState.myId) _playersContainer.add_child(player) _allPlayers.append(GameState.myId) for id in GameState.otherPlayerNames: player = PlayerNode.instance() player.name = str(id) player.playerId = id player.playerName = str(GameState.otherPlayerNames[id]) player.playerColor = GameState.otherPlayerColors[id] player.global_position = _playerPositionNodes[positions.find(id)].position player.set_network_master(id) _playersContainer.add_child(player) _allPlayers.append(id) for node in _playerPositionNodes: node.queue_free() 可以看到这里 player.set_network_master(id) 每个玩家都设置了相对应的 Master ID ，并且名字也是他们的 ID 转化的字符串，由 ID 表示任何场景中该玩家是否为 Master 还是 Puppet 。 注意，当前场景中只有 Master 身份的玩家才有信号处理功能，其他 Puppet 玩家节点只是“木偶”而已，不需要处理事件，“主人会全权处理”。 三、 Player.gd 玩家代码 相信到这里很多东西大家都能拨云见日了，玩家中的代码也不复杂，摘几个点稍微说下就可以了： Player.gd1234567891011121314151617181920212223242526272829303132333435363738394041func _unhandled_input(event: InputEvent) -&gt; void: # 这部分代码不论对主人节点还是奴隶节点都有效 # 显示所有玩家的名字 if event.is_action_pressed('show_name'): _labelName.show() elif event.is_action_released('show_name'): _labelName.hide() if ! self.is_network_master(): return # 这里的代码则只能在主人节点中运行：放置炸弹 if _isStuning || _isDead: return if event.is_action_pressed('lay_bomb'): _layBomb()func _physics_process(delta): # 只能运行于主人节点中 if ! self.is_network_master(): return if _isStuning || _isDead: return self.move_and_slide(_velocity) # 更新其他场景中的奴隶节点位置，这里使用rpc_unreliable允许丢包 self.rpc_unreliable('_updatePosition', self.position)# 只能运行在主人节点上，然后内部由主节点发送必要的消息到奴隶节点master func bomb(byKiller : int, damage : int) -&gt; void: damage(damage, Vector2.ZERO, byKiller)master func damage(amount : float, direction : Vector2 = Vector2.ZERO, byId : int = -1) -&gt; void: # ...master func collect(itemIndex : int) -&gt; void: # ... 基本上， _process 或者 _physics_process 等持续运行的方法尽量保证只有主人节点运行，然后由主人节点更新奴隶节点必要的属性即可，比如：朝向、当前动画、位置等。因为这些会因机器性能而异，如果各自为政，那么很可能会导致不同步，这也是很多人会在网上问：如何在服务器端和客户端保持碰撞同步？非常频繁的问题。 其他一些场景，我会在最后总结说明，我相信大家开发过程中肯定会有收获总结，调试过程你就会很清楚，哪些方法需要远程调用，哪些只能在主人节点或者服务器端运行了。 四、 其他示例代码 首先是怪物代码 Enemy.gd ，这个方法 _process 完全是为 puppet 服务的，我直接在这个方法中更新了怪物的几乎所有信息：位置、图形、动画。 Enemy.gd12345678`func _process(delta: float) -&gt; void: if self.get_tree().network_peer == null || ! self.is_network_master(): return if _isDead || _isPaused: return self.rpc_unreliable('_puppetSet', self.position, _sprite.flip_h, _animationPlayer.current_animation) 如何踢人实际很简单，只有服务器可以，让服务发送消息让被踢的 id 退出游戏即可： LobbyUI.gd123456func _onPlayerBeKickedOut(id : int) -&gt; void: self.rpc_id(id, '_kickedOut')remote func _kickedOut() -&gt; void: # ... self.get_tree().network_peer = null 其他的包括炸弹爆炸、发送消息、显示结果、掉落物品等处理我相信大家都有自己的实现方式，这里就不啰嗦了，也可以参考我的源代码吧。 游戏开发小结开发过程中，我填了不少坑，我再谈谈： 1. 名字必须相同 在开发过程中，在电脑上测试时，我发现偶尔会遇到炸弹、爆炸效果在客户端或者“奴隶”端不会消失，就像这样的 Bug ： 这个在电脑上还好，到了网络端就非常频繁地触发这种 BUG 了。我刚开始自以为是不同步造成方法调用失败，但是回头想想方法一定会调用，只要连接在一起，所以不是这个原因，后面看到这个错误消息我就恍然大悟： E 0:00:11.206 _process_get_node: Failed to get cached path from RPC: Game/Enemies/Enemy123456. 说明一个问题： Master 和 Puppet 名字对不上！所以解决方案很简单，对于生成的物品，统一唯一的名字即可，比如生成的物品、炸弹、怪物等，举例游戏中生成的怪物： 123456789101112131415161718# 生成敌人func _spawnEnemy() -&gt; void: # ...... # 定义一个整数字段，没生成一个敌人加1，保证每个敌人名字【唯一】 _enemyNameIndex += 1 var pos := _tileMap.map_to_world(tile) + _tileMap.cell_size / 2 var name := 'Enemy' + str(_enemyNameIndex) # 将名字作为数据发送到其他客户端，保证名字【一致】 self.rpc('_addEnemy', pos, name)# 远程添加敌人remotesync func _addEnemy(pos : Vector2, name : String) -&gt; void: var enemy = enemyScene.instance() enemy.name = name enemy.set_network_master(1) enemy.global_position = pos _enemiesContainer.add_child(enemy) 2. 不要传递复杂数据 这个问题也困惑了我一会，在主场景生成一个物品，然后将这个物品信息发送到其他 puppet 场景，结果其他场景得到的是空数据！会不会是因为传递了复杂数据类型？我改了一下： 1234567891011121314self.rpc('_addItem', GameState.myId, item)remotesync func _addItem(id : int, item : GameConfig.ItemData) -&gt; void: var power : Node = load(item.data).instance() power.set_network_master(id) self.add_child(power)# 修改后的代码：self.rpc('_addItem', GameState.myId, item.data)remotesync func _addItem(id : int, data : String) -&gt; void: var power : Node = load(data).instance() power.set_network_master(id) self.add_child(power) 可以看到，之前传递的是 ItemData 类型复杂数据，后面我改成 String 同样可以实现相同的功能，避免了这个问题。 3. 确保处于连接状态 有个小问题，虽然不会影响游戏运行，但是我觉得还是有必要解决： E 0:00:01.821 get_network_unique_id: No network peer is assigned. Unable to get unique network ID. 主要原因是网络断开，但是依然调用了这句代码： self.is_network_master() ，不过这个错误不影响游戏，我还是改了一下： 1234func _physics_process(delta: float) -&gt; void: if self.get_tree().network_peer == null || ! self.get_tree().is_network_server(): return # ...... 4. 确保必要数据同步 我们知道服务端和客户端共享一套代码，那么有些数据可以由服务器发送，但是有些复杂稳定的数据没必要占用网络，比如地图资源，那么我们在初始化的时候就可以共享： 123456func _ready() -&gt; void: # 这里会运行在服务器端和客户端，保证_brokenTiles同步 _navigation = self.get_parent() for tile in self.get_used_cells(): if self.get_cellv(tile) == GameConfig.GRASS_TILE_ID: _brokenTiles.append(tile) 这样避免发送数据，或者避免出现问题。 5. 其他小问题 即使对方设置了 get_tree().refuse_new_network_connections = false 客户端还是能加入，但是看不到任何 id 信息。无伤大雅吧。 我觉得这是 Godot 的一个 BUG 。 游戏开发资源推荐一个平台， Gotm.io 支持 Godot 游戏，而且局域网多人游戏可以在这个平台上创建房间，实现基本的网络多人游戏，还是蛮好的。 这个平台免费，可以给你做一些数据统计，比如人数、收入等，当然，你必须得英文比较好，毕竟上面的人几乎都是国外的开发者或者国外的玩家。 广告时间：？？？ 三、总结小结一下： puppet 大部分场合等同于 remote ，因为你的调用都是在 master 中调用 几乎全部的事件————都应该确定只运行于 master 中，比如某个物品 3 秒后 queue_free ，万一卡住了，超过 3 秒没回收？所以这个方法可以在 server/master 中调用保证同步 所有添加物品几乎都是 rpc ，同理删除物品也是 rpc ，比如 queue_free ，比如地图的更改 master/puppet 相比 remote 的一个用法是： master A 触发了或者调用了 puppet B 的方法，这时候可以使用 master/puppet 关键字更好 方法的调用分三类： _ready _process _input 等系统调用，注意 is_network_master 事件，使用编辑器连接起来的事件，注意 is_network_master 公开方法和属性，这些方法或者属性注意使用 master/puppet 本篇的 Demo 以及相关代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos ， 后续继续更新，原创不易，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot游戏开发实践之一：使用High Level Multiplayer API制作多人游戏（上）","url":"/2020/07/22/godot-game-devLog-1-making-game-with-high-level-multiplayer-api-part-1/","text":"一、前言距离上一次发文已经稳稳超过一年了，去年一直在做 #￥@#*!%……%#&amp;…%&amp;^# 然后待在家里了！偶尔写写 BUG ，一直默默关注着 Godot ，这不已经 3.2.2 版本了，距离“神秘”的 4.0 版本又近了一步。接下来我还是会不断探索，努力提高自己，努力提高别人，哈哈。有时间多和大家交流探讨 Godot 游戏开发中的一些技能、技巧、技术吧。 该结束了！我说的是往期的 Godot3 游戏引擎入门系列正是宣布完成，我们不能总是停留在入门阶段，不要局限于写小 Bug ，大 Boss 也得搞搞，我打算邀请大家一起进入下一阶段的深入学习，本人斗胆提了个高大上的名字： Godot 游戏开发实践系列。说白了，就是“踩坑填坑”系列，至于内容，我暂时能想到、能做到的只有以下一点东西： Godot 的开发技巧、高级 API 的探索 Shader 着色器入门和应用 AI 的一些入门级应用学习 继续实践，做不同类型的游戏 Demo 赶在 4.0 之前入个 3D 游戏开发的门 其他，或者资源，还有太多没学到的…… 我也是新手，很多内容都是第一次尝试，不过不要紧，有梁静茹给的“勇气”，希望“我的一小步，让大家前进一大步吧！”哈哈。另外，喜欢 Godot 游戏引起的朋友们，强烈推荐入群交流， QQ 群号： 692537383 ，和我上次推荐的不是一个群，该群群主是 Godot 第三方语言 QuickJS 绑定者，技术大牛，而且群里的学习讨论、交流气氛也不错，记得在入群申请的时候报上我的名字，进群后可以享受“发际线高端维护优惠券”一张还有群主香吻一个！ 不谢！（PS： 另有新群 831931065 也推荐加入。） 主要内容： High Level Multiplayer API 局域网多人游戏开发应用阅读时间： 10 分钟永久链接： http://liuqingwen.me/2020/07/22/godot-game-devLog-1-making-game-with-high-level-multiplayer-api-part-1/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文 本次示例是一个局域网联机小游戏：炸弹人，当然不能直接在网上进行联机，我还没写过任何服务器代码，不过有一个平台支持 Godot 的局域网游戏进行“网络联机”，并能邀请他人一起玩： gotm.io ，想试一下这个游戏的朋友，这里有体验链接： https://gotm.io/spkingr/bomberman ，进入游戏后，创建服务器，然后网页的右下角有个邀请链接，复制后发送给朋友就可以一起痛苦地玩耍了。由于服务器在国外，要想不卡，对网速要求是比较高的。关于 Godot 中局域网游戏开发可以参考官方文档教程：High-level multiplayer ，文档内容有点简洁，本着“填坑”的思想，我把开发过程中遇到的一些问题和解决方案记录下来，这也是本篇文章的出发点，大致内容： 局域网多人联网游戏开发介绍 远程调用基础知识 Godot 中几个重要的关键字 游戏结构、代码简析 经验总结 示例源码我已经上传到 Github 并且被打包运往北极，妈妈再也不担心我的“祖传代码”会被弄丢了！哈哈。 多人游戏开发简介多人游戏开发听上去感觉要比单机游戏开发高端，实际上并不复杂，只要了解多人游戏开发中的几个重要概念，开发起来和单人游戏几乎没啥区别。在多人游戏中，有一个重要的概念是区分：服务端和客户端。在一场局域网联机游戏中，有一个玩家是服务器，即 Server ，其他加入的玩家都是 Client 客户端，在游戏开发代码编写上，它们几乎“平等”： 服务端和客户端共享相同的场景和代码 都可以互相调用远程方法，发送通知等 也可以独立运行相关逻辑，比如初始化一些共有的数据 上图显示的是服务器端和客户端的场景图，节点和结构完全一样，当然也共享同一套代码，不过我们知道，在运行过程中不可能让客户端随意、单独、自定义地运行任何代码，那样的话游戏就不能保持进度同步了，多人游戏也就成了单机游戏。相比客户端，服务端至少拥有以下特殊职能： 服务端优先于其他客户端先运行、创建游戏实例 服务端负责统一分配某些属性值，比如给玩家随机分配颜色，确保不重复 服务端可以踢人，可以通知并开始游戏，客户端一般不具有该功能 服务端一般不会随便退出正在进行中的游戏，至少也要发送一个通知或者提示 如何在代码中判断当前游戏是否为服务器非常简单，在 Godot 中可以使用下面的代码： 1234if self.get_tree().is_network_server(): print('this is the server.') # 服务器端else: print('this is the client.') # 客户端 在这个 Demo 中，所有的“怪物”都在服务器端产生，然后“同时通知所有其他客户端生成相同属性的敌人”： 12345678func _spawnEnemies() -&gt; void: # 只有服务端可以控制敌人对象的生成 if ! self.get_tree().is_network_server(): return var count := _enemiesContainer.get_child_count() if count &lt;= maxEnemyCount: _spawnEnemy() # 生成怪物 逻辑很简单，那么服务端如何通知客户端怪物对象的生成呢？换句哈说，也就是服务端如何在运行时发送消息到客户端，消息内容包括客户端需要生成怪物的位置、名字、状态等变量值，这就需要高大上且专业的远程调用相关 API 了：低端点，就是远程方法调用的实现。在 Godot 中我们使用 rpc 关键字调用远程方法， rset 调用远程属性，了解了服务器和客户端，接下来一起深入探讨远程调用相关知识。 远程调用基础 前方预警：各种七嘴八舌、鱼龙混杂、绕口令式的句段可能会让小白们感觉不适，慎读！莫晕！勿醉！ 何谓远程调用？有点网络知识的朋友都知道，所谓“远程”就是本地与非本地，或者联网中的服务端、客户端之间的关系，举一个很简单的例子：玩家A和玩家B联网游戏，玩家A发送一条消息后，这条消息会同时显示在两个玩家的屏幕上，玩家A的消息就是通过远程调用传送到玩家B的游戏场景进行显示的。 再举个例子：玩家A进入多人游戏场景，那么服务器端和客户端都有玩家A对象，但实际上只有一个地方（比如服务端）可以操作控制自己的角色，比如玩家A在服务器端通过键盘事件控制位置移动后，客户端几乎同时也能看到玩家A移动到了相同的某个新位置，这个流程就是一个简单的远程调用实现过程。具体点，就是服务端接收键盘输入，玩家移动后，通过远程调用客户端相应方法，让客户端实现移动该场景中的玩家A（傀儡/镜像），这个所谓的傀儡有个专业名词叫奴隶（ slave ）或者木偶 （ puppet ）。有点啰嗦，用一个简单的动态图演示如下，注意左边是受控制的真实玩家A所在场景，右边反映的是另一个玩家所在游戏场景： 对于小白来说，了解了这个过程就是理解了这个游戏的核心部分。在 Godot 中，除了 rpc/rset 关键字外，还有几个关键字。还是用例子来说：假设三个玩家联网玩游戏，玩家A/B/C在紧张刺激地进行游戏，这里他们各自控制自己的主角，我们把他们各自打开的游戏界面或场景定义为各自所谓的主场景。某个时候玩家A在自己的主场景中发送了一条私密信息，这条信息以玩家C为特定的接收对象，也就是说玩家B所在场景是看不到该消息的，只有玩家C才能看到，如何实现呢？这就是有选择性、定向性的远程调用了，是通过一个 network id 实现的。游戏联网后，每个玩家（服务器、客户端）都有一个特定的网络 id （在前面的场景结构图中，两个玩家 1 和 62889 实际就是他们各自的 ID ），通过这个 id 利用 rpc_id 或者 rset_id 方法就可以向指定端发送私密信息了。 说明：服务器端 ID = 1 ，其他客户端 ID 都是随机数。 例子到此为止，在 Godot 中远程调用 API 有以下几个，这些都是 Node 节点自带的方法： rpc/rset 调用远程方法或者属性 rpc_id/rset_id 调用指定 id 对象的远程方法或者属性 rpc_unreliable/rset_unreliable 和上面类似，但不保证一定会调用，可能因为延迟等原因掉包 rpc_unreliable_id/rset_unreliable_id 和上面类似，针对指定 id 的不稳定远程调用 “talk is cheap, show me the code!” 多人游戏中，服务端有“玩家A”和“玩家B（镜像）”，客户端同样有“玩家A（镜像）”和“玩家B”，当服务器端玩家A（客户端的玩家B同理）按下“攻击”按键的时候，服务端的玩家A和客户端的玩家A（镜像）都会同时发出攻击动作，代码如下： 123456789func _input(e : Event) -&gt; void: # 只会在本地运行（玩家A） attack() # 可以调用远程方法（玩家A的所有镜像） rpc('attack')# remote 表示该方法可以被远程调用remote func attack() -&gt; void: print('attack something...') 同理，远程属性的调用代码示例： 123456# remote 表示该属性可以被远程调用remote var health := 100func damage(value : int) -&gt; void: self.health -= value rset('health', self.health) 大家应该注意到了，有的方法、属性的定义前多了一个关键字 remote ，正如单词的意思，这个关键字修饰的方法/属性不同于普通方法/属性：能使用 rpc/rset 进行远程调用。 除此之外，细心的朋友能发现，在上面的 GIF 演示图中还有两个关键字： master/puppet 。这两个关键字并不是玩家的名字（因为他们不同），同样是远程调用中的关键字，分别代表该节点为当前场景的“主节点”或者“奴隶（傀儡、木偶、镜像）节点”。而普通方法前除了可以用 remote 修饰外，也可以使用 master/puppet 修饰，接下来重点讨论这些关键字的意义和应用。 远程调用关键字为了把主/奴区分开来，我还是继续举例子，假设联机玩家A/B/C在各自电脑上的各自场景中一起游戏（果然 RAP ），那么下面的高深结论成立： 相对于玩家A来说：玩家B和玩家C都属于远程端（他们三个有一个服务端，两个客户端） 相对于玩家A电脑中的场景：玩家A对象是主人节点，玩家B和玩家C是对应的奴隶节点 同理，相对于玩家B中的场景：玩家B对象是主人节点，A和C都是奴隶节点 玩家A只能是玩家A的主人节点或者奴隶节点，不可能玩家A的主人节点或者奴隶节点是玩家B/C 比如：玩家A场景中的A对象是玩家B场景中A对象的主人节点，玩家B/C场景中A也是玩家A场景中A对象的奴隶节点（ RAP 唱起来！ ） 不管你有没有搞懂，反正我是没办法再举例子了。太混乱了！小二，来瓶 80 年的 XO 压压惊……“酒醒后第二天，发现下图能看懂了！” 上图说明两个联机游戏场景的结构是完全一样的，但有“主次”节点之分，在实际游戏中的就像下图： 总结一下，在 Godot 中用于修饰远程属性/方法的几个主要关键字就这几个： remote 表示该方法是一个远程方法或者属性，可以使用 rpc/rset 调用 remotesync 以前写作 sync ，它不仅会调用远程方法，也会在本地调用一次 master 表示该方法只能在“主人”节点中调用，“奴隶”节点不会调用 puppet 以前写作 slave ，和 master 相反，在所有“奴隶”身份节点中调用 “talk is cheap, show me the code!” 为了区分 remote/remotesync 关键字，再举个栗子，我发誓这最后一个 RAP ：假设“炸弹K”所在的场景，调用了一个“爆炸然后消失”的远程方法，因此其他场景中，不论服务器端还是客户端的“炸弹K”镜像都会“爆炸然后消失”。但问题来了，“炸弹K”本身并没有爆炸，为啥？因为这里调用的是远程方法，本地方法并没有调用，所以，为了保证游戏中炸弹K“同步”爆炸，在本地也需要手动调用一次普通方法： 12345678# 玩家A中的“炸弹K”，使用 rpc 调用远程爆炸方法self.rpc('_deleteObject')# 本地调用：本身也需要调用一次该方法_deleteObject()# 通用方法：玩家A/B/C中的：“炸弹K”remote func _deleteObject() -&gt; void: print('Explode and delete self.') 上面的代码显然有点啰嗦，我们改用 remotesync 可以让代码稍许简洁： 123456# rpc 远程调用，因为是 remotesync 修饰所以本身也会调用一次self.rpc('_deleteObject')# 使用 remotesync 表示该方法调用时本地也会触发remotesync func _deleteObject() -&gt; void: print('Explode and delete self.') 实际上， remote 完全可以替代 remotesync ，视具体情而定吧，像类似上述的场景中 remotesync 更加方便。另一方面， master 和 puppet 也具有类似的特点，同样表示远程属性或者方法，不过他们明确了调用者的“身份”，比如游戏中的一段代码： 123456789101112131415161718# 炸弹触发爆炸事件后所调用的一个方法func _on_Explosion_body_entered(body : CollisionObject2D) -&gt; void: if body != null &amp;&amp; body.has_method('bomb'): # 调用 body 的 bomb 方法，这里 bomb 方法只有主人节点才会发生实际调用 body.rpc('bomb') self.queue_free()# 玩家场景中的代码，使用 master 表示远程调用中只有“主人节点”会触发master func bomb() -&gt; void: print('Damaged by bomb.') _isStunning = true stun() # 主人节点使用远程调用通知所有其他奴隶节点 self.rpc('stun')# 这里当然可以改为 remotesync 或者 puppetremote func stun() -&gt; void: print('stunning...') 相同的道理， puppet 关键字保证了方法或者属性只能在“奴隶”节点上发生调用： 1234567891011121314151617func _physics_process(delta): # 这里对当前节点进行判断：非主人节点则返回 if ! self.is_network_master(): return if _isStuning || _isDead: return # 主人节点根据键盘输入移动位置 self.move_and_slide(_velocity) # 因为奴隶节点不接受键盘输入的控制，所以必须由主人节点远程控制移动 self.rpc_unreliable('_updatePosition', self.position)# 这个方法只会在奴隶节点中调用（依然可以改为 remote ）puppet func _updatePosition(pos : Vector2) -&gt; void: self.position = pos 在源码中，你会发现很多方法中都包含 Node.is_network_master() 的判断语句，这是为了避免该方法在非“主人”节点中运行。值得注意的是，这个方法和 Node.get_tree().is_network_server() 是完全不相干的两种判断，前者表示当前节点是否为主人节点，是任何 Node 节点具有的一个方法；后者表示当前游戏是否为服务器，是场景树 Tree 的一个方法。 写了这么多，说了那么多 RAP ，也举了不少例子，对于编写过服务器代码的朋友来说应该不难，作为新手还是需要一些思考和实践的，现在，总结一下前面的内容： 方法（属性） 本地节点是否运行 远程节点是否运行 本地主节点是否运行 本地奴隶节点是否运行 普通法法 是 否 是 否 remote 否 是 否 否 remotesync 是 是 是 是 master 是/否（视情况） 是/否（视情况） 是 否 puppet 是/否（视情况） 是/否（视情况） 否 是 完成了这个游戏后，我发现：本质上来说，我们完全只需要一个 remote 结合 is_network_master() 方法就可以实现其他所有关键字的功能，因为在 remote 方法中完全可以判断当前节点是否为主人节点还是奴隶节点。当然，那样会很麻烦，合理且灵活地应用每个修饰符，能够写出更加简洁、易读的代码。 另外的另外，还有几个关键字，比如 mastersync/puppetsync 我没有在游戏中用到，大家可以到官方文档中进行查询了解，接下来我们一起讨论本 Demo 中的场景结构和相关代码吧。 游戏结构限于篇幅过长，我将在下部分再详述，尽情期待！ 未完待续…… 我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之十五：RigidBody2D刚体节点的几种应用场景及示例","url":"/2019/07/31/introduction-of-godot-3-part-15-several-usage-examples-of-rigidbody2d-node-in-games/","text":"一、前言这一次，让我们来做一些轻松有趣的东西，嘿嘿。 在上一篇 Godot3游戏引擎入门之十四：刚体RidigBody2D节点的使用以及简单的FSM状态机介绍的文章中，我们主要讨论了刚体节点 RigidBody2D 的一些常用属性以及在游戏中的简单使用，利用刚体节点开发了一个简单的太空飞船射击小游戏，这一章我们继续探讨刚体节点，研究一下刚体节点的其他几个重要属性，并在场景中做一些简单应用。 除此之外，我还会穿插着介绍一下 Godot 引擎自带的 AStar 最短路径寻路 API 的简单使用。 主要内容： RigidBody2D 刚体节点的几个有趣的应用场景阅读时间： 10 分钟永久链接： http://liuqingwen.me/2019/07/31/introduction-of-godot-3-part-15-several-usage-examples-of-rigidbody2d-node-in-games/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文废话不多说，由于自己知识和经验的局限性，暂时我能想到的 RigidBody2D 的应用场景主要有这几个： 刚体节点作为普通的游戏物品或者元素 刚体节点响应鼠标事件进行拖拽 利用刚体节点实现爆破特效 随机生成地图的应用 注：为了缩短文章篇幅，涉及到的代码只提供核心部分，其他部分代码将省略，有兴趣的朋友可以直接到我的 Github 仓库下载项目的全部源码查看。 1. 普通元素在上一篇文章中，我们使用刚体节点制作了太空飞船和太空岩石，由于是在太空，它们都不会受到重力的影响。实际应用场景中，刚体默认会受到重力的作用，在重力影响下刚体会发生一些有趣的碰撞反馈，我们可以充分利用 RigidBody2D 刚体节点的物理特性，无需手动编写代码即可实现一些简单的特效。 在这个场景中，木箱子和子弹球都是刚体模型，与我们之前游戏中使用 Area2D 作为根节点的“子弹”场景不同，使用 RigidBody2D 作为根节点，“子弹”可以直接和游戏世界中的其他物体产生碰撞互动。另外，游戏场景中玩家根节点为 KinematicBody2D 节点，能与刚体产生直接互动。从上图中可以看出来，勾选和不勾选 player infinite inertia 选项，玩家和其他刚体的碰撞效果完全不一样，我们先看下玩家 Player 场景的主要代码： 1234567891011121314151617181920212223242526var _velocity := Vector2.ZEROvar _isInfInertia := truefunc _physics_process(delta): var hDir := int(Input.is_action_pressed('ui_right')) - int(Input.is_action_pressed('ui_left')) var vDir := int(Input.is_action_pressed('ui_down')) - int(Input.is_action_pressed('ui_up')) var velocity := Vector2(hDir, vDir if isTopDown else 0).normalized() * moveSpeed if !isTopDown: velocity.y = _velocity.y + gravity * delta _velocity = self.move_and_slide(velocity, FLOOR_NORMAL, true, 4, PI / 2, _isInfInertia) # 省略代码……func _shoot() -&gt; void: if ! bulletScene || ! _canShoot: return _canShoot = false _timer.start() var ball := bulletScene.instance() as RigidBody2D ball.position = _bulletPosition.global_position ball.apply_central_impulse(bulletForce * _bulletPosition.transform.x) self.get_parent().add_child(ball)# 设置玩家是否为无限惯性力func setInfiniteInertia(value : bool) -&gt; void: _isInfInertia = value 影响玩家与刚体碰撞反馈核心方法是 KinematicBody2D 的方法 move_and_slide() ，这个方法在 Godot 3.1 版本中新增加了一个参数，即最后一个参数 infinite_inertia ，表示玩家是否为无限惯性。如果玩家具有无限惯性属性，那么玩家移动时可以推动刚体，甚至挤压物体，但是不会检测与刚体的碰撞；如果玩家非无限惯性，那么刚体就像静态碰撞体一样会阻止玩家的移动。参数默认值为 true 表示无限惯性。其他的都比较简单了，之前的文章也有讨论。 2. 鼠标拖拽另一个有意思的应用场景是：我们可以使用鼠标来拖拽刚体进行移动，同时与其他刚体进行交互，最后使用鼠标将其“抛”出去。 实现这个效果不难，这里我们需要使用到刚体的另一个重要的属性： Mode 属性，即刚体的模式。在刚体属性面板中，我们会发现该属性有 4 种取值设置： Rigid 即普通刚体模式，为默认值 Static 静态模式，刚体表现和静态碰撞体一样 Kinematic 图形学模式，和 KinematicBody2D 一样 Character 人物模式，和普通刚体一样，但是不会发生旋转 利用这一点，我们可以找到实现刚体拖拽的思路：拖拽开始时刻设置刚体的模式为 MODE_STATIC 静态模式，同时控制刚体的全局位置跟随鼠标移动，拖拽结束即松开鼠标后，复原刚体的模式为 MODE_RIGID 普通模式，接着可以给刚体一个临时冲量使其运动。 1234567891011121314151617181920212223242526272829303132333435363738394041export var mouseSensitivity := 0.25export var deadPosition := 800.0var _isPicked := false # 判断当前刚体是否被鼠标拖拽func _input_event(viewport, event, shape_idx): # 右键按下时拖拽箱子 var e : InputEventMouseButton = event as InputEventMouseButton if e &amp;&amp; e.button_index == BUTTON_RIGHT &amp;&amp; e.pressed: pickup()func _unhandled_input(event): # 右键松开时抛掉箱子 var e : InputEventMouseButton = event as InputEventMouseButton if e &amp;&amp; e.button_index == BUTTON_RIGHT &amp;&amp; ! e.pressed: # 传入鼠标的移动速度 var v := Input.get_last_mouse_speed() * mouseSensitivity drop(v)func _physics_process(delta): # 更新拖拽盒子的位置，跟随鼠标移动 if _isPicked: self.global_transform.origin = self.get_global_mouse_position() # 盒子掉出地图之外删除 if self.position.y &gt; deadPosition: self.queue_free()func pickup() -&gt; void: if _isPicked: return _isPicked = true self.mode = RigidBody2D.MODE_STATIC # 拾起盒子，更改为静态模式func drop(velocity: Vector2 = Vector2.ZERO) -&gt; void: if ! _isPicked: return _isPicked = false self.mode = RigidBody2D.MODE_RIGID # 抛掉盒子，更改为刚体模式 # self.sleeping = false # 防止刚体睡眠 self.apply_central_impulse(velocity) # 给盒子一个抛力 核心部分为 pickup() 和 drop() 这两个方法，实现起来非常简单，这里需要提醒的是，对于 RigidBody2D 刚体节点，如果需要响应鼠标事件，即 _input_event() 方法的正常调用，我们必须勾选设置刚体节点的 Pickable 属性： 另外，在代码中有一个值得注意的地方是，松开鼠标后，复原刚体模式为普通模式的同时不能让其进入默认的睡眠状态。阻止刚体睡眠状态有两种方法： sleeping = false 即设置睡眠属性 apply_central_impulse(Vector2.ZERO) 给刚体添加一个冲量，大小为 0 也可以 鼠标松开后，我们给物体一个抛力使其运动，所以我们选择第二种方式即可。 3. 爆破特效“物品爆破”特效在游戏中很常见，可以直接使用动画实现，这里我讲的是通过代码来实现物体的爆破特效。我使用了 Github 上一个开源库，非常容易地实现了爆破效果，开源库链接地址： Godot-3-2D-Destructible-Objects 。如何使用这个开源库在其主页上有详细的说明，实际使用过程中，我遇到了的一个问题，如下图所示的场景结构图：特效代码不能直接放在需要爆破的子场景中，而应该放在子场景实例化后的节点上！ 另外，源代码中自带的控制爆炸的方式是鼠标左键点击事件，这里我稍微修改了一下源码，让效果只有在爆炸体与玩家或者子弹碰撞后才会触发，部分代码如下： 123456789# 引起爆炸的物体分组名集合，这里为玩家和子弹export(Array, String) var triggerGroups := ['player', 'bullet']func _on_Area2D_area_or_body_entered(area_or_body): for group in triggerGroups: if area_or_body.is_in_group(group): $Explode.explode() $Area2D.queue_free() return 大家可以自己尝试，效果图如下： 4. 随机地图在游戏中随机生成地图是一个非常“巨大”、非常“深入”的话题，不过本篇中我要介绍的随机地图生成只是涉及到其中的一点点皮毛，对这个话题感兴趣的朋友可以到网上找找相关的资料。怎么生成一个随机的地图呢？我的思路大概是这样的： 地图由一个一个的小房间构成 房间之间没有重叠，就像刚体不能互相交叉渗入一样 房间个数、大小、位置都随机 房间之间有路径可达，整个地图必须有一条完整的路径 如何实现这个特别的“房间”呢？其实很简单，我们可以使用 RigidBody2D 节点作为房间场景的根节点，充分利用其物理特性，这里最重要的一点就是设置刚体节点的 Mode 模式属性为 Character 人物模式，以保证其不会发生旋转： 同时，不需要考虑重力因素，设置重力影响系数设为 0 即可，房间场景 Room 的代码非常简单： 123456789# 设置房间的位置和大小func makeRoom(pos: Vector2, size: Vector2) -&gt; void: self.position = pos _size = size# 获取房间的位置尺寸，可以传入一个偏差值func getRect(tolerance : float = 0.0) -&gt; Rect2: var s = _size - Vector2(tolerance, tolerance) return Rect2(self.position - s / 2, s) 接下来我们主要分三步实现随机地图的轮廓。第一步，我们在主场景中生成一定数量的大小随机的房间，利用“人物”刚体模式的特性，房间添加到场景后会自动彼此分开；第二步，我们随机地删除一些房间，让地图显得更加随机；第三步，使用 AStar 寻路算法将我们产生的房间之间的最短路劲找出来。最后一步，肯定是替换“房间”为真正的“地图”，这一步我就没有介绍了，大家完全可以动手实现一个，或者参考我后面给出的相关资料。好了，我们看下效果： 主要的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100export var roomScene : PackedScene = null # 房间子场景export var roomCount : int = 25 # 房间总数量export var tileSize : int = 32 # 地图瓦片单元尺寸export var minSize : int = 4 # 房间最小尺寸，乘以瓦片尺寸export var maxSize : int = 10 # 房间最大尺寸，乘以瓦片尺寸export(float, 0.0, 1.0) var cullTolerance : float = 0.4 # 剔除部分房间，系数onready var _roomContainer := $RoomContaineronready var _camera := $Camera2Donready var _windowSize : Vector2 = self.get_viewport_rect().sizevar _isWorking := false # 是否正在进行生成中var _astarPath : AStar = null # AStar算法实例var _zoom : Vector2 = Vector2.ONE # 相机缩放var _offset : Vector2 = Vector2.ZERO # 相机偏移# 随机地图生成方法，可以拆分为多个函数，这里分4步func generateRooms() -&gt; void: if ! roomScene || _isWorking: return # 标记，删除旧房间 _isWorking = true _astarPath = null for room in _roomContainer.get_children(): room.queue_free() # 随机生成新的房间，尺寸随机 randomize() for i in range(roomCount): var room : Room = roomScene.instance() var width := randi() % (maxSize - minSize) + minSize var height := randi() % (maxSize - minSize) + minSize var size := Vector2(width, height) * tileSize room.makeRoom(Vector2.ZERO, size) _roomContainer.add_child(room) print('Step 1 is done.') # 第一步完成 # 停留1秒，让生成的房间有足够时间分散开 yield(self.get_tree().create_timer(1.0), 'timeout') # 随机删除一部分房间，把房间的位置全部添加到数组，注意时 Vector3 类型 var allPoints : Array = [] for room in _roomContainer.get_children(): if randf() &lt; cullTolerance: room.queue_free() else: room.mode = RigidBody2D.MODE_STATIC allPoints.append(Vector3(room.position.x, room.position.y, 0.0)) print('Step 2 is done.') # 第二步完成 # 创建新的AStar算法，添加第一个点 _astarPath = AStar.new() _astarPath.add_point(_astarPath.get_available_point_id(), allPoints.pop_front()) # 循环所有【未添加的点】，循环所有AStar中【已添加的点】 # 找出【未添加点】与【已添加点】的距离中，【最短】的距离点，并添加到AStar中 # 同时将该点从【未添加点集合】中删除 while allPoints: var minDistance : float = INF var minDistancePosition : Vector3 var minDistancePositionIndex : int var currentPointId :int = -1 for point in _astarPath.get_points(): for index in range(allPoints.size()): var pos = allPoints[index] var distance = _astarPath.get_point_position(point).distance_to(pos) if distance &lt; minDistance: minDistance = distance minDistancePosition = pos minDistancePositionIndex = index currentPointId = point var id = _astarPath.get_available_point_id() _astarPath.add_point(id, minDistancePosition) _astarPath.connect_points(currentPointId, id) allPoints.remove(minDistancePositionIndex) print('Step 3 is done.') # 第三步完成 # 等待一帧的时间，用于等待被删除的房间被彻底移除 yield(self.get_tree(), 'idle_frame') if _roomContainer.get_child_count() == 0: return # 找出所有房间最左上角和最右下角的两个坐标，确定摄像机的缩放和位移 var minPos := Vector2(_roomContainer.get_child(0).position.x, _roomContainer.get_child(0).position.y) var maxPos := minPos for room in _roomContainer.get_children(): var rect := room.getRect() as Rect2 if rect.position.x &lt; minPos.x: minPos.x = rect.position.x if rect.end.x &gt; maxPos.x: maxPos.x = rect.end.x if rect.position.y &lt; minPos.y: minPos.y = rect.position.y if rect.end.y &gt; maxPos.y: maxPos.y = rect.end.y _zoom = Vector2.ONE * ceil(max((maxPos.x - minPos.x) / _windowSize.x, (maxPos.y - minPos.y) / _windowSize.y)) _offset = (maxPos + minPos) / 2 print('Step 4 is done.') # 第四步完成 _isWorking = false 代码虽然有点长，不过并不难，相信大家很容易就能看懂，你完全可以把 generateRooms() 方法拆分为多个子方法来实现，这里关于 AStar 的用法我已经在注释中作了简要说明，形象一点，可以参考下图： 另外，随机生成房间的时候，你可以设置一下房间的坐标位置，比如放置在同一条水平线上等。这里我给大家看下最终的实现效果： 相关内容可以参考如下链接： AStar API http://kidscancode.org/tags/procgen/ Procedural Generation in Godot - Part 6: Dungeons 三、总结简单的介绍了 RigidBody2D 节点的几个应用场景，不知道大家感觉怎样？有没有更好玩的点子？期待大家的留言，哈哈。 本篇的 Demo 以及相关代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos ， 后续继续更新，原创不易，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"【翻译】游戏设计模式之状态机","url":"/2019/07/21/translation-of-state-in-game-programming-patterns/","text":"一、前言本文是一篇关于游戏设计模式之状态模式的文章内容翻译，我在上一篇文章 Godot3游戏引擎入门之十四：刚体RidigBody2D节点的使用以及简单的FSM状态机介绍中简单地介绍了 FSM 有限状态机的含义以及游戏中的简单实现，讲述的很浅显，如果你对游戏设计模式感兴趣，我相信本篇文章会适合你，如有翻译不当之处请谅解，哈哈。 作者简介：Robert Nystrom ，《 Game Programming Patterns 》的作者原文链接： http://www.gameprogrammingpatterns.com/state.html 二、正文忏悔时间：我对这一章节的内容有点夸大其词。表面上是关于状态设计模式的探讨，但我不得不谈及游戏中关于有限状态机制（或称为 “FSM” ）的基本概念。不过我一旦提及到这个，那么我想我也不妨介绍下分层状态机和下推自动机的概念以及相关原理。 这会涵盖多方面的知识点，为了尽可能地缩短文章篇幅，文中使用的代码示例省略了一些细节，这些是您必须自己填写的。不管怎样，我还是希望这些知识点仍然能够清晰以便能让你了解整个理念。 如果你从未听说过状态机，也请不要感到难过。状态机不像 AI 和编译器、黑客那样，它在编程圈子里没有那么耳熟能详。不过我认为它们更应该广为人知，所以我在这里会把它们抛到一个不同层次的问题上去看待。 我们曾经都见识过假设我们正在研究一个往一边滚动的平台游戏。我们的工作是实现游戏中的女主角，即玩家在游戏世界中的化身。这意味着要让她响应用户的输入。比如按下 B 键，她应该跳跃。实现起来非常简单： 12345678void Heroine::handleInput(Input input)&#123; if (input == PRESS_B) &#123; yVelocity_ = JUMP_VELOCITY; setGraphics(IMAGE_JUMP); &#125;&#125; 有什么问题吗？ 目前还不能阻止“在空气中跳跃”的发生——当她在空中时继续点击 B 键，她将永远漂浮下去。这里最简单的解决方法是给 Heroine 添加一个 isJumping_ 的布尔字段，用于跟踪判断她是否已经跳跃，然后再执行操作： 1234567891011void Heroine::handleInput(Input input)&#123; if (input == PRESS_B) &#123; if (!isJumping_) &#123; isJumping_ = true; // 起跳... &#125; &#125;&#125; 接下来，我们希望实现：如果女主角在地面上，玩家按下下方向键按钮她就能进行躲闪，而松开按钮的时候，她又会重新站起来： 123456789101112131415161718void Heroine::handleInput(Input input)&#123; if (input == PRESS_B) &#123; // 如果没有跳跃就起跳... &#125; else if (input == PRESS_DOWN) &#123; if (!isJumping_) &#123; setGraphics(IMAGE_DUCK); &#125; &#125; else if (input == RELEASE_DOWN) &#123; setGraphics(IMAGE_STAND); &#125;&#125; 这次有没有发现问题所在？ 通过以上代码玩家可以实现： 按下按键躲闪。 按 B 键从闪避位置开始跳跃。 在空中松开按钮也能站立。 女主角跳跃在空中就能切换到她的站立姿势。是时候再添加另一个判断标记了…… 1234567891011121314151617181920212223242526void Heroine::handleInput(Input input)&#123; if (input == PRESS_B) &#123; if (!isJumping_ &amp;&amp; !isDucking_) &#123; // 跳跃... &#125; &#125; else if (input == PRESS_DOWN) &#123; if (!isJumping_) &#123; isDucking_ = true; setGraphics(IMAGE_DUCK); &#125; &#125; else if (input == RELEASE_DOWN) &#123; if (isDucking_) &#123; isDucking_ = false; setGraphics(IMAGE_STAND); &#125; &#125;&#125; 接下来，如果能够实现女主角在跳跃过程中，玩家只要按下下方向键按钮女主角就可以进行俯冲攻击的话，那确实很炫： 123456789101112131415161718192021222324252627282930void Heroine::handleInput(Input input)&#123; if (input == PRESS_B) &#123; if (!isJumping_ &amp;&amp; !isDucking_) &#123; // 跳跃... &#125; &#125; else if (input == PRESS_DOWN) &#123; if (!isJumping_) &#123; isDucking_ = true; setGraphics(IMAGE_DUCK); &#125; else &#123; isJumping_ = false; setGraphics(IMAGE_DIVE); &#125; &#125; else if (input == RELEASE_DOWN) &#123; if (isDucking_) &#123; // 站立... &#125; &#125;&#125; 又是寻找 Bug 的时候了。找到问题了吗？ 我们已经确定玩家在跳跃的过程中是不能继续在空中二次跳跃了，但这对于俯冲效果并不适用。看来我们又开辟了一个新的问题领域…… 我们的方法显然存在一些问题。每当我们修改这些代码，我们都会破坏某些逻辑。我们还需要添加更多的动作——我们还没有添加行走行为呢——但是按照目前这个进度，它会在我们完成之前就已经崩溃成一堆的 Bug 了。 有限状态机救场有点沮丧，不过至少你可以扫除桌面上除了纸和笔之外的所有其他东西，并开始来绘制一个流程图。你把女主角可以做的每个动作都画成一个长方形框：站立，跳跃，闪避和俯冲。当她处于其中的某一个状态并按下某个按钮时，您就可以从该状态框中画出来一个箭头，箭头上用这个按钮做标记，然后将其连接到她应该切换到的另一个状态上。 恭喜，您刚刚创建了一个有限状态机。这来自计算机科学的一个分支，被称为自动机理论，其数据结构所在家族还包括著名的图灵机。 FSM 是该家族中最简单的一位成员。 几个要点是： 你有一套固定的机械状态。在我们的例子中，那就是站立，跳跃，闪避和俯冲。 机器一次只能处于一种状态中。我们的女主角不能同时既跳跃又站立。事实上，防止这种情况的发生正是我们将要采用 FSM 机制的原因之一。 一系列输入或者事件会被发送到机器。在我们的示例中，也就是原始的按键按下与释放动作。 每个状态都有一系列转换机制，每个转换与某个输入相关联并指向另一个状态。当有输入进入时，如果输入与当前状态的转换相匹配，则机器的状态将切换为转换所指向的新状态。 例如，在站立状态时按下下方向键就可以过渡到闪避状态。在跳跃状态下按下下方向键可以过渡到俯冲状态。如果没有给当前状态的输入定义转换，那么这个输入会被忽略。 说的纯粹点，它的整个组成就是：状态，输入和转换。您可以把它绘制成一个小流程图。不幸的是，编译器没法识别我们的涂鸦，那么我们如何才能实现一个呢？四人帮 Gang of Four 的状态模式就是其中的一种方案——我们可以做到———不过先让我们从简单点开始吧。 枚举和 Switch 语句在我们的 Heroine 类中一个问题就是一些布尔字段的某些组合是无效的：比如， isJumping_ 和 isDucking_ 不能全部为 true 。如果你的一些标记中，符合一次只有一个是 true ，那就意味着你所需要的是一个 enum 枚举类。 在这种情况下，枚举 enum 的内容恰好是我们 FSM 的状态集，所以我们给出如下定义： 1234567enum State&#123; STATE_STANDING, STATE_JUMPING, STATE_DUCKING, STATE_DIVING&#125;; 取代了一堆布尔标志， Heroine 类中将只有一个 state_ 的字段。同时我们将选择分支的对象进行了反转。在之前的代码中，我们先判断输入，然后再根据状态进行判断。这会把同一个按钮的输入事件全写在了一起，导致某一个状态的代码的混乱。我们希望对同一个状态的处理保持在一块，因此我们以状态进行分支处理。代码如下： 1234567891011121314151617181920212223242526272829303132333435void Heroine::handleInput(Input input)&#123; switch (state_) &#123; case STATE_STANDING: if (input == PRESS_B) &#123; state_ = STATE_JUMPING; yVelocity_ = JUMP_VELOCITY; setGraphics(IMAGE_JUMP); &#125; else if (input == PRESS_DOWN) &#123; state_ = STATE_DUCKING; setGraphics(IMAGE_DUCK); &#125; break; case STATE_JUMPING: if (input == PRESS_DOWN) &#123; state_ = STATE_DIVING; setGraphics(IMAGE_DIVE); &#125; break; case STATE_DUCKING: if (input == RELEASE_DOWN) &#123; state_ = STATE_STANDING; setGraphics(IMAGE_STAND); &#125; break; &#125;&#125; 这看起来有点繁琐，但它确实在之前的代码上有了真正的改进。我们还缺少一些条件分支，不过我们将可变状态简化成了单个的字段。现在所有处理单个状态的代码都很好地集中在一块了。这是实现状态机的最简单方式，适用于某些用途。 但是，你的问题很可能会超出这个方案。假设我们想要添加一个新动作，我们的女主角可以闪避一段时间以补充能量，然后发动某个特殊攻击。当她进行闪避动作时，我们需要跟踪其能量补充的时间。 我们向 Heroine 类添加 chargeTime_ 字段以存储攻击前所要花费的时间。假设我们已经有一个每帧都会调用的 update() 函数，我们在这里添加代码： 1234567891011void Heroine::update()&#123; if (state_ == STATE_DUCKING) &#123; chargeTime_++; if (chargeTime_ &gt; MAX_CHARGE) &#123; superBomb(); &#125; &#125;&#125; 我们需要在她开始闪避的那一刻重置计时器，所以我们还需要修改 handleInput() 的代码： 1234567891011121314151617void Heroine::handleInput(Input input)&#123; switch (state_) &#123; case STATE_STANDING: if (input == PRESS_DOWN) &#123; state_ = STATE_DUCKING; chargeTime_ = 0; setGraphics(IMAGE_DUCK); &#125; // 处理其他输入... break; // 其他状态... &#125;&#125; 总而言之，为了增加这种特殊的大招攻击状态，我们必须修改两个方法并在 Heroine 类上添加一个 chargeTime_ 字段，即使这个字段只有在女主角处于闪避的状态下才有意义。我们倾向于将所有的代码和数据完美地整合在一起。这方面四人帮的设计模式已经涵盖了。 设计模式之状态模式对于对面向对象思想有深入了解的人来说，每个条件分支都是一个使用动态分派的机会（换句话说，也就是在 C++ 中使用虚拟方法）。我估计你可能会太深入而掉进了那个兔子打的洞里。有时候你需要的仅仅是一个 if 语句而已。 不过在我们的例子中，我们已经达到了一个转折点，即使用面向对象的思想更合适。这让我们顺理成章地使用状态模式。引用四人帮的话来说： 允许对象在其内部状态发生变化时更改其行为。这个对象貌似会更改它所在的类。 其实这并没有告诉我们多少东西。不过，我们的 switch 已经搞定了。他们所描述的具体模式，在我们的女主角类中实现起来像下面这样： 一个状态接口首先，我们为状态定义一个接口。每个行为都依赖于状态——就是我们之前每个 switch 分支的地方——都转变成该接口中的虚拟方法。对我们来说，这里的方法就是 handleInput() 和 update() ： 1234567class HeroineState&#123;public: virtual ~HeroineState() &#123;&#125; virtual void handleInput(Heroine&amp; heroine, Input input) &#123;&#125; virtual void update(Heroine&amp; heroine) &#123;&#125;&#125;; 每个状态封装成类对于每个状态，我们定义一个实现接口的类。它的方法定义了女主角在该状态下的一些行为。换句话说，从之前的 switch 语句中获取每个 case 情形并将它们移动到其对应的 state 类中。例如： 123456789101112131415161718192021222324class DuckingState : public HeroineState&#123;public: DuckingState() : chargeTime_(0) &#123;&#125; virtual void handleInput(Heroine&amp; heroine, Input input) &#123; if (input == RELEASE_DOWN) &#123; // 转换为站立状态... heroine.setGraphics(IMAGE_STAND); &#125; &#125; virtual void update(Heroine&amp; heroine) &#123; chargeTime_++; if (chargeTime_ &gt; MAX_CHARGE) &#123; heroine.superBomb(); &#125; &#125;private: int chargeTime_;&#125;; 注意我们还会将 chargeTime_ 字段从 Heroine 类中移出并移入到 DuckingState 类中。这真是太好了——这个数据段只有在该状态下才会有意义，现在的对象模型很明显地反映出了这一点。 状态委托接下来，我们给 Heroine 类一个指向她当前状态的指针，抛弃每段长长的 switch 语句，然后将其委托给状态： 1234567891011121314151617class Heroine&#123;public: virtual void handleInput(Input input) &#123; state_-&gt;handleInput(*this, input); &#125; virtual void update() &#123; state_-&gt;update(*this); &#125; // 其他方法...private: HeroineState* state_;&#125;; 为了“改变状态”，我们只需要赋值 state_ 变量以指向不同的 HeroineState 对象即可。整个就是状态模式的全部了。 状态对象实例在哪里？在这里我掩饰了一些东西。为了改变状态，我们需要给 state_ 字段赋值所要指向的新状态，但是这个新状态对象从哪里来呢？如果是通过我们的枚举类实现，这是一个欠缺思考的方式—— enum 枚举类型的值都是一些原始的基本数据类型，比如数字。但现在我们的状态的类型确是类，这意味着我们需要一个真实的实例来指向它。通常这有两种常见的方案： 静态类的状态如果状态对象没有任何其他字段，则它存储的唯一数据是一个指向内部虚拟方法表的指针，这样就可以实现其他方法的调用。在这种情况下，我们并没有什么理由让其拥有多个实例。无论如何，实例化的每个对象都是完全一样的。 所以基于这种情形，你可以创建一个静态的类型实例。即使你有一堆的 FSM 状态机都是同时运行在同一个状态下，它们都是可以指向同一个实例的，因为它没有任何特定于某个机器的实例。 把静态实例放在哪里这取决于你。最好是找一个有意义的地方吧。没有什么特别的原因的话，让我们把静态对象放在状态的基类中吧： 12345678910class HeroineState&#123;public: static StandingState standing; static DuckingState ducking; static JumpingState jumping; static DivingState diving; // 其他代码...&#125;; 每个静态字段都是游戏中使用的对应状态的一个实例。为了能让女主角正常跳跃，站立状态下应该是这样编写的： 12345if (input == PRESS_B)&#123; heroine.state_ = &amp;HeroineState::jumping; heroine.setGraphics(IMAGE_JUMP);&#125; 实例化的状态但是有时候这并不管用。静态状态类不适用于闪避状态。它有一个 chargeTime_ 字段，这个字段是特定于女主角的闪避状态的。如果碰巧只有一个女主角，这在我们的游戏中是没问题的，但如果我们假设添加多人玩家进行合作，同时在屏幕上出现两个女主角，那我们就会遇到问题了。 在这种情况下，我们必须在进行状态转换的时候创建一个新的状态对象实例。这样每个 FSM 都有自己的状态实例。当然，如果我们分配了一个新的状态对象，那意味着我们需要释放当前的旧状态对象内存。我们得小心翼翼，因为触发状态改变的代码是位于当前的旧状态的方法内。我们不想从自己本身当中删除 this 引用。 相反，我们将允许 HeroineState 中的 handleInput() 方法可选地返回一个新的状态。如果这样做， Heroine 将可以删除旧的状态然后转换为新的，代码如下所示： 123456789void Heroine::handleInput(Input input)&#123; HeroineState* state = state_-&gt;handleInput(*this, input); if (state != NULL) &#123; delete state_; state_ = state; &#125;&#125; 这样的话，在方法的返回值之前，我们不会删除先前的旧状态。现在，站立状态对象就可以通过创建新实例来转换为闪避状态了： 1234567891011HeroineState* StandingState::handleInput(Heroine&amp; heroine, Input input)&#123; if (input == PRESS_DOWN) &#123; // 其他代码... return new DuckingState(); &#125; // 停留在当前状态。 return NULL;&#125; 如果给我选择的话，我更倾向于使用静态状态模式，因为它们不会在每次状态更改的时候因为分配对象空间而消耗内存和 CPU 调用周期。当然，对于状态机，呃，这是一种思路。 动作的进入和退出状态模式的目的是将一个状态的所有行为和数据都封装在同一个类中。一般我们已经差不多实现，但仍然还有一些东西要完成。 当女主角状态改变时，我们同时会切换她的精灵（ sprite ）图片显示。目前这个代码由她所要发生转换的旧状态持有。当她从闪避状态转为站立状态时，闪避状态就会设定其显示图形： 12345678910HeroineState* DuckingState::handleInput(Heroine&amp; heroine, Input input)&#123; if (input == RELEASE_DOWN) &#123; heroine.setGraphics(IMAGE_STAND); return new StandingState(); &#125; // 其他代码...&#125; 我们真正想要的是每个状态能控制其自己的图形显示。我们可以通过向状态类提供一个进入（ enter ）的行为来解决这个问题： 12345678910class StandingState : public HeroineState&#123;public: virtual void enter(Heroine&amp; heroine) &#123; heroine.setGraphics(IMAGE_STAND); &#125; // 其他代码...&#125;; 回到 Heroine 类，我们修改一下处理状态更改的代码，以便在新状态下调用这个方法： 123456789101112void Heroine::handleInput(Input input)&#123; HeroineState* state = state_-&gt;handleInput(*this, input); if (state != NULL) &#123; delete state_; state_ = state; // 在新的状态上调用 enter 行为。 state_-&gt;enter(*this); &#125;&#125; 这使我们可以简化闪避状态类的代码如下： 123456789HeroineState* DuckingState::handleInput(Heroine&amp; heroine, Input input)&#123; if (input == RELEASE_DOWN) &#123; return new StandingState(); &#125; // 其他代码...&#125; 现在这段代码仅仅只用来处理切换到站立的状态而已，而图形显示由站立状态自行处理了。嗯，现在我们的状态类是真的被封装起来了。关于进入动作的一个特别好的效果就是它们一定是在进入该状态时才调用，而且不管你是从哪个状态转换而来。 大多数真实的游戏中，状态图是会存在从多个状态转换到同一个状态的情况。例如，我们的女主角在她跳跃或俯冲后最终都呈现站立状态。这意味着我们最后还是会在状态转换所发生的每一个地方编写一些重复的代码。进入（ Entry ）状态的方法为我们提供了处理这一点的地方。 当然，同样我们也可以扩展它以支持退出（ exit ）行为。这只是我们在切换到新状态之前所调用要离开的旧状态中的一个方法。 有何收获？我已经花了这么多时间安利你 FSM 有限状态机，不过现在我要把你从飘飘然状态拉回原地了。到目前为止我所说的一切都是没有什么问题， FSM 非常适合解决某些问题。但是他们最大的优点也即他们最大的缺陷。 状态机通过强制使用固定死的结构来帮助您解开那些乱成一团的代码。你所拥有的全部仅为一组固定的状态，一个单一的当前状态和一些用于进行状态转换的硬编码。 如果您尝试使用状态机来处理游戏中更复杂的事情，例如游戏 AI ，那么你首先得弄清楚这个模型的局限性。值得庆幸的是，我们的先人已经为我们找到了避开这些疑难杂症的方法。我将通过向你介绍其中几个解决方案来结束本篇文章的主要内容。 并发状态机我们决定让我们的女主角拥有携带枪支的能力。当她正在射击的时候，她仍然可以做之前所能做的一切动作：跑步，跳跃，闪避等等。而且她也能够在做这些动作的同时发射她的武器。 如果我们坚持使用 FSM 的范畴，那么我们必须将拥有的状态数量扩大一倍。对于每个现有的状态，我们同时需要另外一个她背着武器做同样事情的状态：站立，背着枪站立，跳跃，背着枪跳跃，嗯，你应该明白了。 再来添加几个武器，然后把状态进行组合，数量一下子爆增。不仅是大量的状态，而且还增加了大量的冗余：对于非武装和武装状态下的状态，除了处理射击的一点点代码外，其他几乎完全相同。 这个问题在于我们将两个状态——她正在做什么以及她所携带的东西——塞进了一个单一的状态机中。为了模拟所有可能的组合，我们需要编写成对的状态。这个问题的解决方案也很明显：分别设立两个独立的状态机。 我们先不管之前状态机做了些什么，我们只管保留原来的状态机。然后我们再分开单独定义一个她携带东西时的状态机。 Heroine 类将拥有两个“状态”引用，对应我们定义的两个状态机，如下代码： 12345678class Heroine&#123; // 其他代码...private: HeroineState* state_; HeroineState* equipment_;&#125;; 当女主角向各状态委托处理输入时，她将输入交给两个相应的函数分别进行处理： 12345void Heroine::handleInput(Input input)&#123; state_-&gt;handleInput(*this, input); equipment_-&gt;handleInput(*this, input);&#125; 然后，每个状态机可以响应输入，生成相应的行为，并独立于其他状态机而各自更改其状态。这里两组状态机大多不会相关联，这样处理很有效。 在项目实践中，你确实会发现某些情形下状态机之间会发生一些交互。例如，或者她并不能边跳跃边开火，或者如果她有武装，那么她就不能进行俯冲攻击。为了解决此类问题，在一个状态的代码中，你可能会简单地使用 if 语句测试其他机器的状态来协调它们之间的交互。这当然不是最优雅的解决方案，但它至少可以搞定这个目标。 分层状态机在完善了我们的女主角的一些行为后，她可能会有一堆相似的状态。例如，她可能有站立，行走，跑步和滑动状态。在其中任何一个状态下，按下 B 键会跳跃再按下方向键则俯冲。 如果通过一个简单的状态机实现，那么我们必须在每个状态中复制这段代码。如果我们能够只实现一次，然后在所有的状态中重用它那就更好了。 如果把这当做面向对象中的代码而不是状态机，那么这些状态共享代码的一种方式就是使用继承。我们可以定义一个“在地面上”的类来处理跳跃和闪避。然后，站立，行走，跑步和滑动将继承于它并添加他们各自应有的附加行为。 事实证明，这是一种被称为分层状态机的常见结构。一个状态可以有一个状态超类（使自己成为一个子状态）。当一个事件发生时，如果子状态没有处理它，它会顺着继承链到达状态的超类然后进行处理。换句话说，它就像继承中方法的重写一样。 实际上，如果我们使用 State 状态模式来实现我们的 FSM 有限状态机，我们可以使用类继承来实现层次结构。为状态超类定义一个基类： 123456789101112131415class OnGroundState : public HeroineState&#123;public: virtual void handleInput(Heroine&amp; heroine, Input input) &#123; if (input == PRESS_B) &#123; // 跳跃... &#125; else if (input == PRESS_DOWN) &#123; // 俯冲... &#125; &#125;&#125;; 然后每个子状态都继承于它： 12345678910111213141516class DuckingState : public OnGroundState&#123;public: virtual void handleInput(Heroine&amp; heroine, Input input) &#123; if (input == RELEASE_DOWN) &#123; // 站立... &#125; else &#123; // 不处理输入，顺着继承链往上走。 OnGroundState::handleInput(heroine, input); &#125; &#125;&#125;; 当然，这并不是实现层次结构的唯一方式。如果你没有使用 Gang of Four 四人帮的状态模式，这将不会起作用。相反，你可以使用一堆状态而不是主类中的单个状态来进行显式地模拟当前状态的超类继承链。 当前状态处于堆栈的顶部，在它之下则是它的直接超类，然后是该超类的超类。当你提出一些特定于状态的行为时，你便可以从堆栈的顶部开始往下走，直到其中某一个状态能够处理它。 （如果没有，你就忽略它吧。） 下推自动机有限状态机的另一个比较常见的扩充就是使用状态堆栈。令人困惑的是，堆栈实质上代表着一种完全不同的东西，它也是用于解决完全不同的问题。 这里存在的问题是有限状态机没有什么过往历史概念。你仅知道自己当前处于什么状态，但对你过去所处的状态没有记忆保留。并没有什么方法可以回到以前的状态去。 这里有一个例子：早些时候，我们让无畏的女主角先行全付武装起来。当她开枪时，我们需要一个新的状态来播放射击的动画并不断生成子弹和对应的视觉效果。因此，我们弄了一个 FiringState 拼到一起，同时还要弄出来所有那些当射击按钮按下时可以过渡到这个新状态的其他状态。 而棘手的部分就是她在射击后所要过渡到的状态。她可以在站立，跑步，跳跃和闪避时弹出一些特效。当射击相关的一系列动作完成后，她应该回到她之前正在做的动作状态。 如果我们坚持使用这香喷喷的 FSM ，那么我们早已经忘记了她之前所处的是什么状态了。为了跟踪之前的状态，我们必须又定义一系列几乎完全一样的状态——站立时射击，边跑边射击，射击时跳跃等等——这样每个人都有一套可以正确地回到之前状态的硬编码转换代码了。 其实我们真正喜欢的方式是先存储她在射击之前所处的状态，之后再返回去调用它。同理，这就是自动机理论发挥作用的地方。相关数据结构被称为下推自动机。 在有限状态机只有一个指向状态的指针的情况下，下推自动机则拥有一个状态堆栈。在 FSM 中，当转换到新状态后将覆盖前一个状态。下推自动机也可以让你这样处理，但它同时还为你提供了两个额外的操作： 您可以将新的状态推入堆栈中。 “当前”的状态始终处于堆栈的顶部，这样实现转换为新的状态。同时它将先前的状态压在了新状态的下面，而不是直接丢弃它。 您可以将最顶层的状态弹出堆栈。该状态被丢弃，而它下面的状态则成为新的当前状态。 这正是我们解决射击状态所需要的。我们创建了一个单一的射击状态。当处于任何其他状态情况下，按下射击按钮时，我们将射击状态推到堆栈顶层。当射击动画完成后，我们将该状态弹出，同时下推自动机自动将我们的状态转回之前的状态。 那么，这些东西有用吗？即使对状态机的发展有这些常见的扩充，但是它们仍然非常有限。如今，人工智能游戏领域中的趋势更倾向于使用行为树和规划系统等令人兴奋的事物。如果您感兴趣的是那些复杂的 AI ，那么本章内容一定能够刺激到您的胃口。你会想要阅读其他更多相关的书籍以满足自己的兴趣。 这并不意味着有限状态机，下推自动机以及其他简单的系统都是毫无用处的。对于某类问题，它们确实是一个非常不错的模型工具。有限状态机在以下情况非常有用： 你有一个实体，其行为根据某个内部状态变化而变化。 该状态可以严格地划分为相对比较小的不同选项。 随着时间推移，实体会对一系列的输入或者事件进行响应。 在游戏中，它们最常用于 AI ，但它们在用户输入处理，菜单导航切换，文本解析，网络协议以及其他异步行为的实现中也很常见。 三、其他以上就是主要内容，有任何建议请给我留言吧，谢谢！ 我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot 翻译"},{"title":"Godot3游戏引擎入门之十四：RigidBody2D刚体节点的应用以及简单的FSM状态机介绍","url":"/2019/07/20/introduction-of-godot-3-part-14-make-a-game-with-rigidbody2d-node-and-the-fsm-introduction/","text":"一、前言时间飞逝，距离上次更新已经有半年之久！这几个月里我只有三分之一的时间很忙，相反其他时间是比较闲的，但是由于空闲时间非常“碎片化”，导致我一直没有集中精力搞自己喜欢的“小游戏”了。首先对我的读者表示非常抱歉！嗯，从本篇开始，我会陆陆续续更新一些新的文章，尽管更新的频率可能会变得“佛系”，不过我肯定不会放弃 Godot 的，哈哈。 不知不觉， Godot 3.1 正式版都已经发布好几个月了，现在最新的稳定版本是 3.1.1 ，不知道大家有没有感受到新版本中的一些新特性所带来的开发乐趣呢？关于新特性这里我先不讨论，在今天要介绍的这个小游戏制作过程中，我要告诉大家一个“很不幸”的消息：新版本中的 RigidBody2D fails with a bug! 对，你没看错，我遇到 Bug 了，而且还不算个小问题，它直接导致了我的游戏不能正常地“好好玩耍”！ 话又说回来，我所要讲述的这个游戏是一个非常无聊的小游戏，仅用来作为示例演示而别无他意，我会在文章中指出新版本 Bug 出在哪，如何解决等。另外，游戏中包括的一些图片文件、音乐素材、甚至不少源代码都是来自或者参考了 Chris Bradfield 的一个名为 Space Rocks 的示例游戏，他的这个项目是开源的，地址在此： https://github.com/kidscancode/Godot-Game-Engine-Projects 。 我想通过本篇主要讲述以下几个小部分： 介绍 RigidBody2D 刚体节点的基本属性 刚体节点的基本应用以及注意点 游戏场景的结构关系与核心代码说明 最简单的 FSM 有限状态机介绍和应用 新版本中存在的 Bug 以及解决方法 主要内容： RigidBody2D 刚体节点的应用以及简单的 FSM 状态机介绍阅读时间： 12 分钟永久链接： http://liuqingwen.me/2019/07/20/introduction-of-godot-3-part-14-make-a-game-with-rigidbody2d-node-and-the-fsm-introduction系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 了解刚体节点的基本属性和作用 操控刚体节点的正确姿势 刚体节点的碰撞检测与响应处理 简单的 FSM 机制实现 版本更新带来的代码更新 游戏的主要场景我之前已经介绍过几个小游戏了： 金币收集小游戏 太空射击小游戏 平台小游戏 相比之前的游戏，本篇中我要介绍的这个太空飞船小游戏算比较简单的一个，游戏中的元素类型少、操作也相对简单，但最重要的一点是，在本游戏制作中，我重点使用了 RigidBody2D 刚体节点，这与之前讨论的 KinematicBody2D 有着很大的区别，后续我们会讨论，这里先预览一下游戏中的所有场景结构吧： 唯一一个要注意的地方我已经在上图中作了标注： Rock.tscn 岩石场景中的子节点 CollisionShape2D 碰撞图形没有定义实质的形状。这是因为我们需要在游戏中动态生成不同尺寸的岩石，所以选择在代码中根据其大小创建对应的碰撞图形： 123456789101112131415161718func _ready(): randomize() # 设置位置和质量（在Player.gd中设置位置是在_integrate_forces方法中） self.position = _position self.mass = _radius * density # 设置图片尺寸和爆炸粒子尺寸与传递的参数相匹配 _sprite.scale = Vector2(1, 1) * self.size * scaleFactor _explosion.scale = Vector2(1, 1) * self.size * scaleFactor # 给岩石一个碰撞体形状，和传递的参数半径相匹配 var shape = CircleShape2D.new() var textureSize = _sprite.texture.get_size() shape.radius = (textureSize.x + textureSize.y) / 2.0 * _radius * scaleFactor _collisionShape.shape = shape # 省略其他代码…… 我省略了一些代码，有需要的话可以参考我的项目源码，这里我就不全部贴出来了，其他的部分我也视情况作了一些注释，相信大家一眼就能看懂。 FSM 简介与实现FSM 即 Finite State Machine 有限状态机的缩写，相信很多游戏开发者都听过或者在项目中使用过这种模型。在 中文维基百科 中是这样描述的：有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。 上图来自 Chris Bradfield 的一本书[《 Godot Engine Game Development Projects 》]，图中每一个圆圈表示玩家的一种状态，在某种情况下，比如键盘输入、被攻击、超时等原因，玩家会从当前状态沿着箭头切换到另一种状态。如上图，举个例子：玩家处于空闲状态（ IDLE ）下，如果按下按键（ key ）则进入跑步（ RUN ）状态，如果玩家速度为 0 （ speed=0 ）则从跑步状态切回空闲状态。 关于状态机我了解的并不多，但是我在网上找到了一篇关于游戏设计模式之状态模式的文章，内容介绍非常详尽，我已经把它翻译了出来，有兴趣的朋友可以参考，当做扩展阅读吧，文章链接：【翻译】游戏设计模式之状态机。 本游戏中，我参考了 Chris Bradfield 的《 Godot Engine Game Development Projects 》一书中 Space Rocks 小游戏的设计，下图同样来自此书： 可以看到，玩家即太空飞船具有以下四个状态： INIT 即初始状态，这种状态下飞船不可见，也不会发生碰撞事件，等待游戏开始 ALIVE 即正常状态，初始状态下点击开始按钮即进入该状态，飞船恢复正常并接受相关事件 INVULN 无敌状态，这种情况是飞船被攻击时进入的状态，一小段时间后自动恢复到正常状态 DEAD 死亡状态，生命值耗光后进入该状态，即游戏结束，随后自动进入 INIT 状态 结合状态图，代码中实现起来非常简单，相关地方我也做了注释，以下是主要代码部分： 12345678910111213141516171819202122232425func _changeState(newState) -&gt; void: if _state == newState: return # 更改飞船的状态，注意设置飞船的可见性 match newState: states.INIT: # _collisionShape.disabled = true # 这在 Godot 3.1 版本中不能正常运行 _collisionShape.set_deferred('disabled', true) # 新版本适用，禁用碰撞检测 _sprite.hide() states.ALIVE: _collisionShape.set_deferred('disabled', false) _sprite.show() # 显示 states.INVULNERABLE: _collisionShape.set_deferred('disabled', true) _animationPlayer.play('invulnerable') # 无敌状态动画 _invulnerabilityTimer.start() # 无敌状态计时器 states.DEAD: _collisionShape.set_deferred('disabled', true) self.linear_velocity = Vector2.ZERO # 线速度归零 self.angular_velocity = 0.0 # 角速度归零 _sprite.hide() # 隐藏 _exhaustParticles.emitting = false # 停止粒子播放 _engineAudio.stop() # 停止声音播放 _state = newState 一个方法实现了 FSM ，并没有所谓的高大上嘛，嗯……但是，这毕竟只是一个简单、非常简单的小游戏，而且，使用这种思路避免了代码中多个 bool 布尔类型和 if...else... 多层嵌套的混乱局面。 刚体的属性及使用在之前的文章中我已经介绍过了 Godot 中的三种主要物理节点的功能特点和使用场景： KinematicBody2D/StaticBody2D/RigidBody2D ，其中 KinematicBody2D 是我们最重要的主角，关于它的介绍也扩展了不少，比如： Godot3游戏引擎入门之十二：Godot碰撞理论以及KinematicBody2D的两个方法。但是，对于 RigidBody2D 刚体节点，相反我仅做了使用场景的一个简单介绍和比较，所以，在本次小游戏中，我们撇开 KinematicBody2D 转而把精力集中到 RigidBody2D 上，重点介绍其使用和相关注意事项等。 其实在很多场景下 RigidBody2D 都是非常实用的，比如，想象一下，用 Godot 做一个类似愤怒的小鸟游戏，那么场景中肯定会有很多刚体节点，只要轻松一点，各种物体相互碰撞到处乱飞，相反，你完全不用自己去编写太多关于物理碰撞理论的代码就实现了游戏的相关特性，是不是很爽？这就是刚体节点在游戏中的应用场景之一。 1. 刚体的一些属性 刚体和我们现实生活中的物体非常相似，所以一些这些物体的共有特性在 RigidBody2D 节点中也有所提现。首先，最重要的一点就是刚体和万有引力那密不可分的关系，在 Godot 中设置重力（ Gravity ）对刚体的影响主要有两种方式：一是在项目中设置全局引力值；二是在刚体属性中设置引力的缩放系数。 项目中的设置参考下图，具体在 Project Settings -&gt; General -&gt; Physics -&gt; 2d 中找到 Default Gravity 即默认引力值配置，在本游戏中，由于处于外太空的所有物体都不受重力影响，所以可以在这里进行全局配置，把默认引力值设置为 0 。 另一种方式则是设置刚体属性中的 Gravity Scale 引力缩放系数值，它表示物体受重力的影响大小，本游戏中没必要进行设置。其他刚体的一些常见属性有： Mass/Weight ：质量和重量， G = mg 重力公式说明了重量和质量、引力三者的关系 Contacts Reported/Contact Monitor/Can Sleep ：是否响应碰撞以及响应碰撞体个数、能否休眠 Linear/Angular/Applied Forces ：分别设置线性速度和阻力、角速度和阻力、受力和扭矩力 Friction/Bounce ：碰撞材质相关属性，设置刚体的摩擦力和弹性系数等 最后一组属性的设置之前，你必须创建一个新的 PhysicsMaterial 即碰撞材质，这与老版本 Godot 中刚体属性设置稍微不同。另外，刚体还有一些其他的属性这里并没有完全列出来，比如 Mode 刚体模式或者 Custom Integrator 自定义碰撞响应等，我们暂时不讨论，在之后的文中如果用到再介绍吧。 上图是玩家和岩石节点的属性，他们都是刚体节点，但是设置还是有差别的。可以看到，我给 Rock 岩石刚体覆盖了默认的材质属性，设置摩擦阻力为 0 并添加了一定的弹性力，这样让岩石在太空中碰撞起来后的响应更有趣；而玩家 Player 即飞船刚体属性配置中，最重要的是我勾选开启了 Contact Monitor 属性（默认关闭），这对游戏的正常运行非常关键，否则我们无法检测到宇宙飞船和其他任何敌人（岩石）之间的碰撞。 2. 刚体的碰撞测试 在我们之前的游戏中，碰撞检测一般是 Area2D 的专项，在我们这个游戏中也有 Area2D 节点的使用，比如 Laser.tscn 子弹场景。然而我们还需要响应太空飞船和岩石之间的碰撞，他们都是刚体，如何响应呢？前面我已经说明了开启碰撞检测的属性，除此之外，我们还要在需要主动检测碰撞的刚体中设置 Contacts Reported 属性值，即碰撞体检测数量，这里我们设置为 1 对于这个游戏已经足够，那么碰撞响应处理的代码如下： 123456func _on_Player_body_entered(body): if body.is_in_group('rock') &amp;&amp; body.has_method('explode'): # 与岩石碰撞，调用岩石的爆炸方法，传递飞船速度（也就是碰撞方向） body.explode(self.linear_velocity) # 计算伤害 _damage(body.size) 除了开启碰撞，我们有时候还需要暂时关闭碰撞检测功能，比如飞船进入无敌状态的时候就不应该和其他任何物体发生碰撞了，和之前的游戏一样，我们的思路是：直接禁用飞船的碰撞图形 CollisionShape2D 即可，代码 _collisionShape.disabled = true 一行搞定。 当你觉得一切就绪的时候，“诡异”的事情发生了：飞船在禁用了碰撞图形后，居然还能与其他碰撞体进行正常的碰撞响应！其实这在 Godot 3.1 之前的版本中是不会出现的，一切正常，但是从 3.1 的版本开始： In 3.1 Godot doesn’t let you change the physics state during the physics processing stage. This change ($CollisionShape2D.set_deferred(&quot;disabled&quot;, true)) to the code tells it to disable the shape as soon as physics processing is complete. 这是我在遇到这个问题后从 KidsCanCode 博主那里得到的解答，大致意思是：我们不能在物理模型碰撞检测发生的过程中直接操作碰撞图形，相反应该使用 set_deferred 方法，这就是告诉引擎，在物理碰撞处理完阶段再进行设置。修改 _collisionShape.disabled = true 如下即可： 12# _collisionShape.disabled = true # 这在 Godot 3.1 版本中不能正常运行_collisionShape.set_deferred('disabled', true) # 新版本适用，禁用碰撞检测 除了这一点需要注意之外，其他的和之前我们介绍的 KinematicBody2D 的处理几乎一样。 3. 使用代码控制运动 实际上刚体的物理碰撞检测和响应都是交给引擎自动完成的，所以我们很多时候没必要插手刚体的运动，但是在本游戏中，我们的太空飞船并不适用，我们仍然需要监听并控制它的一举一动：不能飞出屏幕之外、设置其角速度和线速度、飞船的位置和角度重置等。 1234567self.position = Vector2.ZEROself.rotation = 0.0func _physics_process(delta): self.position += velocity.rotated(self.rotation); self.linear_velocity = velocity # ...... 以上代码使我们常用的设置，但是不幸的是，这并不适用于 RigidBody2D ，这在 Godot 官方文档中有说明： Note: You should not change a RigidBody2D’s position or linear_velocity every frame or even very often. If you need to directly affect the body’s state, use _integrate_forces, which allows you to directly access the physics state. 嗯，如果你想操作 RigidBody2D ，需要改用 _integrate_forces 方法： 1234567891011121314151617181920212223242526func _integrate_forces(state): # 计算前进动力和旋转扭矩，并应用给飞船刚体（冲量） var force = Vector2(_thrustForceInput * thrustForce, 0).rotated(self.rotation) var torque = _rotateDirection * rotateSpeed state.apply_central_impulse(force) state.apply_torque_impulse(torque) # 设置飞船的位置，origin为飞船位置，xform.x为飞船主轴转向，不要直接设置position var xform = state.transform if _needReset: xform.origin = _resetPosition xform.x = Vector2(1, 0) _needReset = false # 控制飞船在窗口边缘的位置，形成一个闭合区间 if xform.origin.x &gt; _screenSize.x: xform.origin.x = 0 elif xform.origin.x &lt; 0: xform.origin.x = _screenSize.x if xform.origin.y &gt; _screenSize.y: xform.origin.y = 0 elif xform.origin.y &lt; 0: xform.origin.y = _screenSize.y # 更新状态 state.transform = xform 通过 state 可以自由设置刚体的位置，比如上面的代码主要是控制飞船在窗口边缘的位置，另外，这里还有一个设置，由于玩家死亡后，我没有删除其引用而是将其隐身，那么飞船的位置是不固定的，游戏恢复重新开始后需要重置其位置为初始位置，这里同样地需要在 _integrate_forces 方法中进行设置，如上代码的注释我已经做了说明。 最后再啰嗦一句：对于刚创建（比如使用 instance 方法）的刚体物体，直接设置其 position 位置属性是没问题的，注意别混淆了。 新版本中刚体的问题游戏开发过程也就是学习的过程，也是填坑的过程，前面我们已经了解到了 Godot 3.1 新版本中的一个细节问题了：如何正确设置刚体的碰撞图形属性，需要使用 set_deferred 方法。然而在本游戏的制作过程中，我还遇到了另一个 3.1.1 稳定版本中尚未解决的 Bug ，而这个 Bug 居然在 Godot 3.0 中也是存在的：如果你一开始禁用刚体的碰撞图形，然后再经过过一段时间再启用，那么你的刚体变成了真正的直男——嗯，只能前进不能旋转！如下代码，第二行会失效： 12state.apply_central_impulse(force) # 线性冲量，有效。state.apply_torque_impulse(torque) # 扭矩冲量，无效！ 可以简单地通过下面的代码重现这个 Bug ： 123456789func _ready(): _changeState(states.INIT) yield(self.get_tree().create_timer(3), 'timeout') _changeState(states.ALIVE)func _integrate_forces(state): state.apply_central_impulse(force) state.apply_torque_impulse(torque) # 省略代码…… 不过这个 Bug 在 Godot 3.2 开发版本中已经得到了修复，关于开发版本的构建可以到这里下载： Unofficial Godot Engine builds ，关于这个 Bug 我也在官方 Github 上开了一个 issue ，传送门： https://github.com/godotengine/godot/issues/30551 。不管怎样，这个 Bug 肯定会在下一个稳定版本中修复的，大家放心吧。 嗯，如果想测试本篇中的这个小游戏，我建议还是要下载 Godot 3.2 的开发版进行项目导入和测试。 三、总结小游戏算是基本完成了，由于一些不可避免的问题，使得我这个无聊的游戏开发了很长一段时间，不管怎样，希望大家对 RigidBody2D 节点有一个新的认识吧，而关于 RigidBody2D 刚体节点的一些其他应用场景，我也打算会在后续文章中再做一个简单的介绍，大家有什么意见和建议欢迎留言哦！嘿嘿！ 本篇的 Demo 以及相关代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos ，后续继续更新，原创不易，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之十三：实现玩家的跳跃功能并完成一个平台小游戏（下）","url":"/2019/01/26/introduction-of-godot-3-part-13-the-player-jump-implementation-and-make-a-platform-game-part-2/","text":"一、前言本文为上一篇文章的续篇，在上一节中我们一起讨论了 Godot 中平台游戏玩家跳跃功能的实现方法，并使用到了本次小游戏中，那么本节内容主要是分享这个平台小游戏的基本结构和制作过程。游戏运行效果如下： 游戏中的图片资源主要来源于 OpenGameArt.org 网站： https://opengameart.org/content/a-platformer-in-the-forest ，游戏中的部分音乐资源也是在该网站中找到的，其他部分图片和音乐是我七零八凑拼起来的，为了顺利完成一个小游戏，找资源也花费了我不少时间，在这里建议大家有时间可以学习一些基础的美术知识吧。 本次两篇文章所详细讲述的内容包括以下部分： 重力加速度知识和简单的跳跃实现方法（上） 二次跳跃的实现（上） 精确高度的跳跃实现（上） 游戏场景结构与主要代码 三种敌人的行为和实现 其他的一些效果介绍 问题和总结 主要内容：平台游戏的制作解析阅读时间： 10 分钟永久链接： http://liuqingwen.me/2019/01/26/introduction-of-godot-3-part-13-the-player-jump-implementation-and-make-a-platform-game-part-2/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 平台游戏中的玩家场景 游戏中的三种敌人实现 游戏中的其他部分简述 问题与总结 在上一篇文中我们花了大篇幅探讨平台游戏的最核心部分：玩家跳跃功能的实现，接下来所要讨论的游戏中其他场景相对来说就非常简单了，特别是在结合本系列文章之前的两个小游戏的基础上，我觉得对于新手而言也不会有很大的难度，而游戏中的相关设计，额外小功能的实现，游戏场景的丰富程度等等这些还是需要自己好好打磨的。正因为如此，这些可以扩展、发挥的部分也就留给大家去思考实现啦，我仅仅是希望做到抛砖引玉的作用吧！ 玩家场景玩家还是那个玩家，节点还是那些节点。嗯，相比之前的游戏，玩家场景的结构变化不大，当然也有不同之处，玩家场景中最重要的变化是多了一个非常重要的节点： Camera2D 摄像机节点。这个节点其实非常好理解，特别是在 3D 游戏中更加常用，而且很多游戏中会同时拥有多个摄像机。 Camera2D 节点的一些基本参数很好理解，这里例举几个重要的参数说明如下： Current 设置为当前摄像头，这个参数非常重要，不勾选摄像头将不起作用 Zoom 摄像机镜头的缩放变焦，值越小范围越小，图片的显示也就越大 Limit 摄像机的最大活动范围，摄像头移动后的位置不会超出该限制 Smoothing/Speed 开启摄像头跟随平滑移动，可以设置移动的速度 Drag Margin 摄像头不跟随移动的尺寸范围，超出该范围摄像头开始跟随运动 Editor 显示摄像机相关范围图形界面，不会在游戏中显示，用于调试 在属性面板中，你会发现 Limit 下的默认值设置的有点荒谬，当然这在一般的游戏中并没有什么问题，你也可以手动设置合理的值，把摄像头的最大活动范围固定在游戏的主场景范围内，另外 Editor 菜单中的几个调试工具建议都开启查看，参考上图，其中黄色区域表示摄像机活动范围，紫色表示屏幕尺寸或者视窗 Viewport 的大小，蓝色表示玩家在此范围内摄像机不会发生移动，超出范围摄像机跟随移动。 除此之外，我在摄像机节点下添加了一个带脚本的空节点，脚本代码简单地实现了摄像头抖动效果，实现原理非常简单，有兴趣的朋友可以下载源码看看。整个玩家的场景结构如下图： UI 场景结构图也展示在上面了，场景的根节点是一个 CanvasLayer 节点，它的特点是能够忽略节点的渲染排序，直接显示在所有层的最上层，它的子节点又包含 3 个 TextureRect 节点，用于显示玩家的血量。 在这里我建议：如果你的 UI 场景比较简单，完全可以把 UI 场景直接添加到玩家场景中作为一个直接子节点，更加方便简洁！ 敌人场景这个平台游戏中，除了我们的主角——玩家子场景稍显复杂外，其他稍微复杂的节点就是敌人场景了，我在游戏中制作了 3 种行为各异的敌人：光头（ NakedEnemy ）、军人（ SoldierEnemy ）以及蛇（ SnakeEnemy ）。 从场景的结构可以看出来，其中两个敌人的场景根节点使用的是 KinematicBody2D 节点，而怪物蛇使用的则是 Area2D 节点，它们具有的共同行为是：左右反复巡逻。而不同的行为特点有这么几个： 怪物蛇只巡逻，没有主动攻击的能力，场景实现代码也是最简单的 光头在巡逻过程中如果与玩家发生碰撞会立刻进行攻击，之后继续巡逻 军人无主动攻击的能力，但会在巡逻时会往前方发射多颗子弹 怪物蛇 SnakeEnemy 场景的实现代码最简单，代码如下： SnakeEnemy.gd12345678910111213141516171819202122232425262728293031323334extends Area2Dconst UNIT = 16export(float) var patrolRange = 1 * UNITonready var _sprite = $Spriteonready var _animator = $AnimationPlayervar _walkSpeed: float = 2 * UNIT / 2.0var _startPosition: float = 0.0func _ready(): # 设置开始位置，注意为全局位置 _startPosition = self.global_position.xfunc _process(delta): self.position.x += _walkSpeed * delta if self.global_position.x &gt;= _startPosition + patrolRange || self.global_position.x &lt;= _startPosition - patrolRange: _walkSpeed = - _walkSpeed _sprite.flip_h = ! _sprite.flip_h# 发生碰撞时，检测是否为玩家func _on_SnakeEnemy_body_entered(body): if body.is_in_group('player') &amp;&amp; body.has_method('attacked'): body.attacked()func die(): self.set_process(false) _animator.current_animation = 'die' 从代码中可以看出来，怪物蛇在游戏中是不会检测与地面之间发生的碰撞的，所以在游戏关卡中，添加蛇场景的时候，必须把它的位置手动放置在地面上，否则会出现“蛇在空中移动”的现象。 接着是光头敌人 NakedEnemy 场景的实现代码： NakedEnemy.gd1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071extends KinematicBody2D# 省略部分代码……export(float) var patrolRange = 3 * UNIT # 巡逻范围var _walkSpeed: float = 3 * UNIT / 2.0 # 移动速度var _gravity: float = 100 # 重力加速度var _isStandingStill: bool = false # 站立不动var _startPosition: float = 0.0 # 巡逻开始位置var _moveDirection: int = 1 # 移动方向var velocity: Vector2 = Vector2() # 速度var _target = null # 攻击目标：玩家func _physics_process(delta): # 站着不动或者攻击对象不为空时，站立 if _isStandingStill || _target != null: return velocity.y += _gravity velocity.x = _walkSpeed * _moveDirection velocity = self.move_and_slide(velocity, FLOOR_NORMAL) # 循环判断碰撞体是否有玩家（**这里不能检测到玩家在背后的情形**） for index in range(self.get_slide_count()): var collision = self.get_slide_collision(index) if collision.collider.is_in_group('player'): _target = collision.collider _attack() return _animator.current_animation = _animations.walk if self.is_on_wall(): _moveDirection = - _moveDirection _sprite.flip_h = _moveDirection != 1 elif self.global_position.x &gt;= _startPosition + patrolRange: _standStill(-1) elif self.global_position.x &lt;= _startPosition - patrolRange: _standStill(1)# 攻击func _attack(): if 'isDead' in _target &amp;&amp; _target.isDead: _target == null return if _target.has_method('attacked'): _target.attacked() _animator.current_animation = _animations.attack yield(_animator, 'animation_finished') _target = null# 站立，nextDirection 表示站立时间过后转身func _standStill(nextDirection: int): _isStandingStill = true _moveDirection = nextDirection _animator.current_animation = _animations.idle _timer.start()# 站立时间超时func _on_StandStillTimer_timeout(): _isStandingStill = false _sprite.flip_h = _moveDirection != 1# 省略部分代码…… 这里根节点使用 KinematicBody2D 的好处是可以调用 move_and_slide 方法移动敌人，在代码中我给敌人添加了重力加速度，所以放置敌人的时候可以放在空中不需要贴着地面，但是这里的重力加速度值是手动设置的，并没有按照上一篇文章中讲的那样进行计算，也是为了方便简洁，够用就可以。 军人场景 SoldierEnemy 的代码与 NakedEnemy 的代码非常相似，这里我就不贴出来了，有兴趣的朋友可以到我的 Github 仓库下载源码查看。 游戏中其他场景包括：攻击效果子场景、敌人子弹、梯子、宝箱（恢复生命值）、木盒子（门）等这里不作一一介绍，结构和代码都很简单，在本系列之前的文章中都陆陆续续讨论过。 问题总结总结一下这个游戏的开发过程。其实做任何一个游戏，不论游戏开发有多复杂，它的结构设计都是很重要的。比如设计这么一个简单的平台游戏，你需要考虑玩家所应有的一些功能、敌人的行为和种类、关卡地图的设计、游戏中互动元素的添加、甚至一些简单的剧情等等。设计完成接下来就是考虑如何使用游戏引擎来完成制作了。 本次小游戏的结构设计可以参考下图： 这张图片场景名称并不相同，它是另一个游戏的场景结构，图片来源于 Thingsmatic 的一篇博客文章： Making a 2D platform game with Godot 3.0 ，尽管场景名字不同，但是总体结构是相似的，大家可以参考参考。 再来说说本次 Demo 中的一个非常重要的问题或者 BUG ：玩家在敌人（ KinematicBody2D ）身后挨着走也不会受到攻击！也就是说，玩家可以从背后推着敌人走而敌人并不能检测到与玩家之间的碰撞，从而玩家可以安然无恙地“躲过一劫”！ 如何解决这个问题呢？至少有三种最直接的方式： 添加 Area2D 子节点用于检测碰撞 使用 Raycast 射线节点检测碰撞 使用 Physics2DDirectSpaceState.intersect_ray() 方法检测碰撞 为了让游戏更加简单易懂，我并没有在游戏中解决这个 BUG ，不过我会在后续文章中讨论这个问题，以及游戏中常用的 FSM 有限状态机制我想也会谈到，有兴趣的朋友可以自己先探索。 三、总结小游戏算是完成了，但是还有太多不足之处，大家可以充分发挥自己的聪明才智，把你心目中的游戏打造的更加好玩、更加有特色，这里我能想到的一些可以在 Godot 中为游戏增光添彩的功能有： 添加单边碰撞体作为地面 玩家移动时的灰尘特效 给玩家添加无敌状态 添加空中移动平台 给敌人添加 AI 更多交互元素、更好的关卡设计等 本篇的 Demo 以及相关代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos ， 这应该是春节前的最后一篇文章，原创不易，希望大家喜欢，我们 2019 新年见！ 我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之十三：实现玩家的跳跃功能并完成一个平台小游戏（上）","url":"/2019/01/17/introduction-of-godot-3-part-13-the-player-jump-implementation-and-make-a-platform-game-part-1/","text":"一、前言2019 好久不见！终于见面！首先必须得提到一个好消息： Godot 3.1 Beta1 已经发布啦！这是新版本开发过程中的第一个 Beta 版，后续开发进程应该会加快，据我“夜观天象”，我们最快可能会在春节期间与 Godot 3.1 正式版见面！ 然而，对，还有一个然而，在我这三天的文章编写期间，第二个 Beta 版本也紧凑的发布了！看来开发速度已经是越来越快，距离正式版的发布也是指日可待了，强烈推荐大家使用最新发布的 Beta2 版本进行游戏开发，下载链接地址： https://downloads.tuxfamily.org/godotengine/3.1/beta2/ 。 言归正传，本文是我新年里的第一篇文章，也是我准备了很久的第三个入门小游戏：平台小游戏。加上我之前的文章里介绍过的两个小游戏：金币收集小游戏和太空射击小游戏，总算是完成了 Godot 入门教程系列文章的第三种类型不同的游戏了。平台游戏是我们平时在 2D 游戏中非常常见的一种类型，在上一篇文章中我已经介绍了 Godot 中对于平台游戏的一些引擎内置的实用方法和相关运行原理，本文将继续分上下两篇，结合上一节的内容，一起讨论完成这个游戏的开发与制作，在介绍之前，请务必确保自己已经掌握了上一节的相关内容：Godot3游戏引擎入门之十二：Godot碰撞理论以及KinematicBody2D的两个方法 。 OK ，我们开始吧，本次文章上下篇将要详细讲述的内容主要包括以下几点： 关于重力加速度的数学基础知识 简单的跳跃以及二次跳跃实现 精确到高度和跳跃距离的功能实现 游戏的主要场景与关卡、代码介绍（下） 几种敌人的设计和一些简单效果（下） 总结与前瞻（下） 主要内容：平台游戏中的跳跃实现阅读时间： 15 分钟永久链接： http://liuqingwen.me/2019/01/17/introduction-of-godot-3-part-13-the-player-jump-implementation-and-make-a-platform-game-part-1/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 重力加速度相关数学知识 简单的跳跃功能实现 精确高度和跨度的跳跃实现 二次跳跃等小功能的实现 基础数学理论在游戏开发中，我们不可避免地会接触到一些数学知识，比如矢量运算、矩阵操作、冲量动量等，听上去有点“高大上”，但实际上我们要做的确很少，因为游戏中涉及到的一些复杂的物理模型的数学分析，已经在游戏引擎的框架底层中都默默实现包装好了，比如碰撞图形的检测、图像材质的渲染、复杂的矩阵运算等等，而我们需要做的都是一些最基本的操作或者方法的应用，所以即使是初学者也无需有任何担心疑虑！当然，掌握一些基本的数学理论知识，能够让我们在游戏开发中得心应手、有章可循！ 平台游戏中经常会涉及到一些关于重力加速度和速度相关的数学理论知识，所以让我们首先一起来回顾一下物理学中有关自由落体运动的数学概念。这些数学概念并不复杂，主要是一些简单的数学公式，相信大家都学习过，现在一起来温习一下吧！ 首先是最基本的加速度公式： $$v_t = v_0 + at$$ 对于自由落体，物体的初始速度 \\(v_0 = 0\\) ，加速度 \\(a = g\\) 为重力加速度，那么在平台游戏中，玩家从地面跳跃到最高位置也就是自由落体的反向运动：速度从最大速度 \\(v_{max}\\) 减到最小速度 \\(v_{min} = 0\\) 。我们可以得出从地面上升到最高点时所经历的时间为： $$t = \\frac{v_{max}}{g}$$ 到达最高点后玩家开始下落，整个跳跃过程分上升和下落两部分，总时间即上升的时间和下落的时间总和，这两个时间是相等的，所以玩家跳跃后腾空的总时间为： $$t_总 = 2 \\cdot \\frac{v_{max}}{g}$$ 如何计算玩家跳跃后达到的最大高度呢？通过时间和重力加速度可以算出来，公式如下： $$h_{max} = \\frac{1}{2}gt^2$$ 游戏中重力加速度可能是未知的，如果我们设定了玩家能跳跃的最大高度 \\(h_{max}\\) 以及玩家在空中的总时间 \\(t_总\\) ，那么我们就可以由上述公式可以得出游戏中实际的重力加速度大小： $$t = \\frac{t_总}{2}$$ $$g = \\frac{2h_{max}}{t^2}$$ 通过上面的两个公式我们能得出玩家起跳和落地时的最大速度（方向不同而已）： \\(v_{max} = gt\\) ，除此之外，我们也可以根据玩家跳跃的最大高度以及重力加速度来推算出玩家的最大速度： $$v = gt = g\\sqrt{\\frac{2h}{g}} = \\sqrt{2gh}$$ 这里 \\(v\\) 代表最大速度，即 \\(v_{max}\\) ， \\(h\\) 代表最大高度，即 \\(h_{max}\\) 。 以上是枯燥的理论知识！回到游戏中来，游戏场景中的玩家就是我们要操作的对象，而游戏场景就是一个具有重力加速度和地面的小世界，在任何时刻玩家都会有一个向下的重力加速度，如果没有障碍物玩家就会一直往下掉，所以我们需要添加静态碰撞体作为地面阻止玩家继续掉落，这个时候重力加速度虽然一直存在，但是玩家在竖直方向的速度因为地面而变为 0 ，如果我们给玩家一个向上的初始速度，那么他就可以往上跳跃了。 但是，玩家不会无止境地往上升，因为受到向下的重力加速的影响，最终玩家的速度会降为 0 ，此刻也是他所到达最大高度的时刻，接下来就是往下落直到地面为止。这就是一个完整的跳跃过程，那么我们如何在代码中实现呢？又如设置合理的重力加速度和跳跃速度呢？接下来我们一一讨论并解决这些问题！ 简单跳跃实现首先我们来实现最简单的平台跳跃功能！根据上面的思路，分为以下几个步骤： 第一步，在每一帧玩家都会有一个向下的重力加速度，也就是 velocity.y += gravity ，让它的垂直速度不断增加 第二步，移动玩家，因为与地面的碰撞玩家的垂直速度会变为 0 ，更新速度： velocity = move_and_slide(velocity, FLOOR_NORMAL) 第三步，当玩家在地面上开始跳跃时，给玩家一个瞬间的向上的速度即可！ 根据上述步骤，我们编写代码来实现玩家跳跃，这里一定要注意速度是有正负之分的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344extends KinematicBody2Dexport(float) var moveSpeed = 300 # 水平移动速度export(float) var jumpSpeed = 1500 # 跳跃瞬时速度export(float) var gravity = 50 # 重力加速度const FLOOR_NORMAL = Vector2(0, -1) # 地面法线onready var _sprite = $Spriteonready var _animationPlayer = $AnimationPlayervar velocity = Vector2() # 玩家的速度func _input(event): # 只有在地面上的时候才能跳跃 if self.is_on_floor() &amp;&amp; event.is_action_pressed('jump'): velocity.y = -jumpSpeedfunc _physics_process(delta): # 垂直速度不断地受重力的影响 velocity.y += gravity # 水平移动控制 var hDir = int(Input.is_action_pressed('ui_right')) - int(Input.is_action_pressed('ui_left')) velocity.x = hDir * moveSpeed # 这里一定要给速度重新赋值以及设置地面的法线参数 velocity = self.move_and_slide(velocity, FLOOR_NORMAL) if hDir == 1: sprite.flip_h = false elif hDir == -1: sprite.flip_h = true _setAnimation()func _setAnimation(): if ! self.is_on_floor(): animationPlayer.current_animation = 'jump' elif velocity.x != 0: animationPlayer.current_animation = 'run' else: animationPlayer.current_animation = 'idle' 代码和逻辑都很简单，这就是最简单直接的玩家跳跃功能实现，代码中关于 move_and_slide() 以及 is_on_floor() 方法的使用介绍可以参考我的上一篇文章：Godot3游戏引擎入门之十二：Godot碰撞理论以及KinematicBody2D的两个方法。 其中有三个重要的参数，参数的值在每个游戏中都不一样，同一个游戏也可以有不同的设置： moveSpeed 水平移动速度，这个数值很好设置，结合动画感觉合理就可以 jumpSpeed 垂直跳跃的初始速度，设置过大会导致跳跃过高，而太小则没有跳跃效果 gravity 重力加速度，设置过大导致跳跃时间很短且水平跨度很小，过低则导致漂浮 你可能会想，是不是只要调整一下 jumpSpeed 和 gravity 这两个参数的值就好了呢？其实不然！这两个值固然重要，是控制跳跃高度和腾空时间具体效果的关键，但是进一步想想，如果你需要通过跳跃跨过一段峡谷，从起跳到落地的时间，也就是空中的时间过短的话，那么你的移动速度必须足够大才能成功跨过去；如果你在空中的时间过长，那么要成功跨越一段峡谷，你的速度就必须设置很小。看来这三个参数是相辅相成的，调整一个参数必然会引起其他参数的变动！嗯…… 那么如何解决这个问题呢？——别急，自然有办法，因为远在 17 世纪，牛顿就已经帮我们解决了，哈哈！ 精确的实现方法精确的实现，我们需要协调一些重要参数，具体的思路是这样的：首先设置最大的跳跃宽度，以及最大的跳跃高度，有了这两个值，还不够，我们还需要一个时间，即你跨过最大跨越宽度的总时间，这个时间也是玩家在空中上升和下落过程经历的总时间，这个值其实很好捕捉，凭感觉就行，举个例子，在经典小霸王游戏超级玛丽中的主角的最大跳跃高度是 4 个砖头，最大跨越宽度也是 4 块砖，跨越最大宽度的时间大约 1 秒钟（凭我 20 多年前的记忆猜测）。 这些参数设置说明如下： 跨越最大宽度时间： jumpDuration = 2 * t ，根据游戏场景凭感觉自由设置、调整，可以得出腾空的半程时间 t = jumpDuration / 2 设置最大跳跃宽度： maxJumpWidth = velocity.x * t 设置了 maxJumpWidth 后可以算出水平移动速度 moveSpeed = velocity.x 设置最大跳跃高度： maxJumpHeight = 1/2 * gravity * t * t 这里 maxJumpHeight 设置后可以推算出重力加速度 gravity 计算跳跃最大速度： maxJumpSpeed = gravity * t 请注意速度的方向，起跳速度 maxJumpSpeed 在 Godot 中取值为负 如果只是已知跳跃高度和重力加速度，可以使用 v * v = 2gh 的公式计算跳跃速度： v = sqrt(2 * gravity * jumpHeight) 这种设置方式就是我们要讨论的精确实现方法，设置相关变量，接下来在 _ready() 方法或者 _init() 方法中进行计算供后续代码使用，核心部分如下： 123456789101112131415161718192021222324extends KinematicBody2D# 省略一些代码……const UNIT = 16 # 根据你的地图进行设置var gravity = 0.0 # 计算获取var moveSpeed = 0.0 # 计算获取var maxJumpSpeed = 0.0 # 计算获取var maxJumpHeight = 4.25 * UNITvar maxJumpWidth = 5.25 * UNITvar jumpDuration = 1.0 # 跨越总时间，即 2tvar velocity = Vector2() # 计算获取func _ready(): gravity = 2 * maxJumpHeight / (jumpDuration / 2 * jumpDuration / 2) moveSpeed = maxJumpWidth / jumpDuration maxJumpSpeed = - gravity * jumpDuration / 2func _physics_process(delta): # 省略代码部分，请参考之前的代码 代码还是非常简单，大部分保持不变，另外，我这里定义的常量 UNIT 表示单个瓦片地图尺寸，你可以根据自己的游戏场景或者瓦片地图进行对应的设置。还有一个注意点，我在设计最大跳跃宽度和最大跳跃高度的时候，大家应该注意到了，我并没有设置为整数个单元大小，而是会稍微留有一点余地，比如 4.25 * UNIT 而不是 4 * UNIT ，让玩家不会感觉跳上去很难。 添加一些功能目前，我们只是完成了最简单的平台跳跃功能，我们需要更加丰富的游戏体验，更加合理的操作设计，让我们再添加一些其他基本功能吧！ 二次跳跃：在空中进行第二次跳跃，你也可以设置多次 停止跳跃：玩家可以控制主角立即停止跳跃 最低高度：跳跃的最低高度实现 缓冲方案：让起跳和移动不那么唐突 真空死亡：防止无限降落的 BUG 爬梯子：在梯子上玩家能够上下移动 小功能虽多，但实现这些小功能的思路并不复杂。对于二次跳跃，当玩家腾空后，也就是允许玩家进行第二次跳跃，这里的二次跳跃一般是不允许无限跳跃的，所以我们需要添加一个条件用于判断是否已经发生了二次跳跃： ! isSecondJumping &amp;&amp; ! self.is_on_floor() ，同时，记得在玩家着地后把标记的值进行重置 isSecondJumping = false 即可。 在有的游戏中玩家一旦触发跳跃就会直接跳跃到最大高度，不过这并不是我们所需要的，我们希望玩家可以随时停止跳跃：按下跳跃键起跳，松开跳跃键立即停止！这样玩家就会有一定的跳跃空间可操作，对于平台游戏体验来说还是不错的。停止跳跃功能实现起也不难，我们唯一要做的是监听按键的 released 松开事件并作出相应的处理即可： 12345func _input(event): # 跳跃按键松开 if event.is_action_released('jump'): # 玩家垂直速度设 0 velocity.y = 0.0 但是这会出现第三个问题：如果按键松的太快你会发现玩家好像没有发生过跳跃似的，这样是不是有点太唐突了？嗯，我们应该给玩家一个最小的跳跃高度，也即是说，如果玩家在跳跃上升过程中直接把速度设置为 0 是不行的，相反，我们应该给他一个最小速度： minJumpSpeed ，这个所谓的最小速度和之前的最大速度一样可以使用公式通过已知的最小高度值来计算得出。唯一要注意的是：下降过程是不能操作的！ 注意，严格来说这里的最小高度术语有误！实际上是在满足玩家没有达到最小速度之前我们就松开了按键，这时我们需要给玩家一个最小的向上跳跃速度而已！这样玩家跳跃的实际高度肯定会超出最小高度！大家可以揣摩体会一下，当然这个设置对游戏来说这并没有什么伤害。 12345678910111213141516var minJumpSpeed = 0.0 # 最小跳跃速度，注意是负数！var minJumpHeight = 1.75 * UNIT # 最小跳跃高度，用于计算最小速度func _ready(): minJumpSpeed = - sqrt(2 * gravity * minJumpHeight)func _input(event): if event.is_action_released('jump'): # 如果速度小于最小跳跃速度，并且不是二次跳跃的情况下设置最小速度 if velocity.y &lt; minJumpSpeed &amp;&amp; ! isBonusJumping: velocity.y = minJumpSpeed # 二次跳跃直接设置为 0 ，注意是上升过程中 elif velocity.y &lt; 0.0 &amp;&amp; isBonusJumping: velocity.y = 0.0 一些注意点我已经在代码的注释中说明了，注意判断玩家当前跳跃是否为二次跳跃，以及垂直运动的方向是往上还是落下的过程，另外， minJumpSpeed 也是一个负值！ 至于第四个和第五个小功能就非常简单了，真空死亡的意思是：如果测试过程中你的地图不小心出现某个漏洞，比如玩家从某个角落跳出了地图的范围，那么他就会因为受到重力加速度的影响导致垂直下落的速度一直增加到无限大（浮点数最大值），这其实已经是 Game Over 了，我们可以在代码中添加一个最大速度值，当玩家超过这个速度直接让游戏结束或者重新开始即可。 对于缓冲方案，这是一个可有可无的部分，只需要一个函数即可搞定： float lerp(float from, float to, float weight) 也就是线性插值计数器，比如我们让玩家移动的时候直接把速度赋值给玩家的移动速度就会有点“鲁莽”，玩家的速度应该从 0 然后快速增长到 moveSpeed 这样会更加合理，这就是插值函数的作用了，在 Unity 中你会发现它的使用更加广泛且常见。 最后一个，对于梯子上的玩家上下移动效果，与水平移动实现起来并没有很大的差别，我们只需要注意梯子上玩家是没有重力加速度的关键点即可：进入梯子清除重力加速度，离开梯子添加重力加速度。具体实现参考代码吧！ 辅助效果和所有代码我们的玩家跳跃功能已经全部实现了，剩下的是一些辅助特效了。 第一个肯定是添加播放合理的动画效果 第二个是音效了，比如跳跃音效，攻击音效，受到伤害的音效等 第三个是玩家受伤害时的屏幕震动特效等 当然，你可以添加更多的效果，比如灰尘粒子等…… 好了，这么多理论，堆砌到一起，最后看下我们的核心代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# 省略代码……var _gravity = 0.0 # 重力加速度，计算获得var _moveSpeed = 0.0 # 水平移动速度，计算获得var _maxJumpSpeed = 0.0 # 最大跳跃度，计算获得var _minJumpSpeed = 0.0 # 最小跳跃速度，计算获得var _maxJumpHeight = 4.25 * UNIT # 最大跳跃高度var _minJumpHeight = 1.75 * UNIT # 最小跳跃高度var _maxRunWidth = 5.25 * UNIT # 最大跨越宽度（飞跃）var _jumpDuration = 1.0 # 空中跳跃时间，上升、降落各占一半var _isSecondJumping = false # 是否为二次跳跃var _secondJumpHeight = 1.25 * UNIT # 二次跳跃最大高度var _secondJumpSpeed = 0.0 # 二次跳跃最大速度，计算获得var velocity = Vector2() # 玩家当前度包括x和y方向，计算获得var _isOnLadder = false # 玩家是否在子上var _climbSpeed = 0.0 # 爬梯子速度，根据移动速度计算获得var _nextSoundPlayTime = 0.5 # 水平移动和爬梯子脚步声播放最小时间间隔var _isAttacked = false # 玩家当前是否被攻击了var _isSlashing = false # 玩家是否在放冲击波var _currentHealth = 3 # 当前玩家的生命值# 计算所有应该计算的数值func _ready(): _gravity = 2 * _maxJumpHeight / (_jumpDuration / 2 * _jumpDuration / 2) _moveSpeed = _maxRunWidth / _jumpDuration _maxJumpSpeed = - _gravity * _jumpDuration / 2 _minJumpSpeed = - sqrt(2 * _gravity * _minJumpHeight) _secondJumpSpeed = - sqrt(2 * _gravity * _secondJumpHeight) _climbSpeed = _moveSpeed * 0.75 self.emit_signal('health_update', 3)# 处理键盘输入func _input(event): # 如果被攻击了，不能继续操作 if _isAttacked: return # 按下跳跃键 if event.is_action_pressed('jump_up'): if self.is_on_floor(): # 第一次跳跃，在地面上的时候 velocity.y = _maxJumpSpeed _playAudioEffect('jump') else: # 第二次跳跃，方法内部还有判断 _secondJump() # 松开跳跃键 elif event.is_action_released('jump_up'): if velocity.y &lt; _minJumpSpeed &amp;&amp; ! _isSecondJumping: velocity.y = _minJumpSpeed elif velocity.y &lt; 0.0 &amp;&amp; _isSecondJumping: velocity.y = 0.0 # 攻击键，函数内还有判断 if event.is_action_pressed('shoot'): _slash()func _physics_process(delta): # 被攻击的情况下依然移动玩家，但是不受键盘控制 if _isAttacked: velocity.y += _gravity * delta self.move_and_slide(velocity, FLOOR_NORMAL) return # 在梯子上且不是二次跳跃过程中可以上下移动玩家，同时不会产生重力加速度 var vertical = 0 if !_isSecondJumping &amp;&amp; _isOnLadder: vertical = int(Input.is_action_pressed('climb_down')) - int(Input.is_action_pressed('climb_up')) velocity.y = vertical * _climbSpeed if _nextSoundPlayTime &lt;= 0.0 &amp;&amp; vertical != 0: _nextSoundPlayTime = 0.5 _playAudioEffect('climb') # 不在梯子上则受重力加速度影响，注意即使在梯子上但是是二次跳跃依然会受重力影响而下落 else: velocity.y += _gravity * delta # 水平移动控制 var horizontal = int(Input.is_action_pressed('move_right')) - int(Input.is_action_pressed('move_left')) velocity.x = lerp(velocity.x, horizontal * _moveSpeed, _getRunWeight()) velocity = self.move_and_slide(velocity, FLOOR_NORMAL) if _isSecondJumping &amp;&amp; self.is_on_floor(): _isSecondJumping = false # 省略代码，图片方向控制和声效制，动画效果……# 插值权重：水平移动（0.25）和垂直跳跃（0.2）func _getRunWeight() -&gt; float: return 0.25 if self.is_on_floor() else 0.2# 二次跳跃func _secondJump(): if _isSecondJumping: return _isSecondJumping = true velocity.y = _secondJumpSpeed# 省略代码…… 以上是主要代码部分，建议到我的 Github 仓库克隆源码参考，仓库地址： https://github.com/spkingr/Godot-Demos ，最终的游戏效果： 三、总结（上）这是 2019 年的第一篇文章，理论加代码有点超出篇幅了，也陆陆续续花了我不少零零碎碎的闲余时间，希望大家能够从中学到一些知识吧，后续文章我也会努力保持更新速度！ 好了，总结一下本文的相关知识： 基本的重力加速度相关数学知识 简单的跳跃功能实现 精确高度和跨度的跳跃实现 二次跳跃功能的实现 其他功能的实现 本篇涉及到的 Demo 以及相关代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos ， 原创不易，希望大家喜欢，有疑问多多交流与讨论，随时给我留言！ 我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之十二：Godot碰撞理论以及KinematicBody2D的两个方法","url":"/2018/12/30/introduction-of-godot-3-part-12-talk-about-collision-and-move-and-collide-vs-move-and-slide-in-kinematicbody2d/","text":"一、前言这篇文章是为后续小游戏的开发做理论铺垫的。嗯，我们前面已经陆陆续续讨论了很多 Godot 中的一些基础元素、基本功能，最后也顺理成章地完成了两个小 Demo ： 金币收集小游戏 太空射击小游戏 这两个游戏实际上并没有很大的区别，都是简单地进行上下左右移动并完成一些特定功能，所以我打算接下来做一个更常见，更流行的 2D 游戏： 2D Platformer Game ，即所谓的平台游戏！在开启这个游戏之前，我们先一起来讨论平台游戏中涉及到的最重要的一些游戏理论知识： 2D 碰撞检测理论。 这些理论涉及到了我们之前讨论过的 Area2D 节点以及 KinematicBody2D/RigidBody2D/KinematicBody2D 节点，以及相关碰撞图层和碰撞图层掩码知识。另外，本文还会详细讲述 KinematicBody2D 在游戏中常用的两个重要方法： move_and_collide() 以及 move_and_slide() 的区别和联系。本文内容参考了 KidsCanCode 的一篇文章： Godot 3.0: Using KinematicBody2D ，然后结合我自己的一些探索实践完成。 主要内容：碰撞理论以及正确使用 KinematicBody2D 节点阅读时间： 15 分钟永久链接： http://liuqingwen.me/2018/12/30/introduction-of-godot-3-part-12-talk-about-collision-and-move-and-collide-vs-move-and-slide-in-kinematicbody2d/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 四个节点回顾： KinematicBody2D/RigidBody2D/StaticBody2D/Area2D 碰撞图层和碰撞图层掩码： Collision Layers/Collision Masks 两个重要方法的区别和联系： move_and_collide/move_and_slide 三个物理节点在 Godot 中有三个常用的 2D 节点，它们具有碰撞检测与反馈的功能，这三个节点的基础区别在我之前的文章中已经讨论过：Godot3游戏引擎入门之五：上下左右移动动画（下），搬用之前的表格，他们之间的关系和应用场景大致如下： 节点名 StaticBody2D RigidBody2D KinematicBody2D 节点名称 静态碰撞节点（ 2D ） 刚体节点（ 2D ） 运动学节点（ 2D ） 基本特性 自动碰撞检测，位置固定不变 自动碰撞检测，产生碰撞响应：有线速度、角速度等 参与碰撞检测，无自动响应，完全由代码控制移动 使用场景 一般用于固定的墙壁、地面等 一般用于受外界影响而产生运动的物体，比如球体、陨石等 主要用于由代码控制的带物理属性的玩家 我们在 Godot 编辑器中按 F4 查找 API ，可以看到这三个节点都是直接继承于 PhysicsBody2D 的，说明它们都是物理节点，而 PhysicsBody2D 又继承于 CollisionObject2D 具有碰撞检测功能。另外， CollisionObject2D 节点还有另外一个子类，这个子类也是我们之前提过并在游戏中应用过的 Area2D 节点。关于这四个节点的应用我举几个常见例子： StaticBody2D 能应用于所有游戏，作为墙壁、地面、障碍物等固定物 RigidBody2D 比如像愤怒的小鸟、割绳子、太空飞船游戏的主角等 KinematicBody2D 几乎所有的前后左右移动、跳跃的平台游戏玩家或者敌人 Area2D 常见于游戏中的可收集元素或者标记，比如金币、楼梯、关口或者特殊区域等 这几个节点我们在前面的文章中都遇见过，也有不少例子，它们的使用方法大家应该都会了。这里，关于刚体 RigidBody2D 我暂时不会介绍很多，大家可以参考这篇文章： Godot 3.0: Rigid Bodies ，介绍的内容比较全面。 重要说明： Godot 3.1 版本中对于 StaticBody2D 以及 RigidBody2D 的摩擦力属性（ friction ）和弹性属性（ bounce ）的设置没有出现在属性面板中，而需要在新增的 Physic Material Override 属性下新建一个 PhysicMaterial 间接进行设置即可，实质上区别影响并不大。 碰撞形状和图层所有的物理碰撞节点都需要至少一个碰撞形状才会有碰撞效果。这个碰撞形状你可以直接在属性面板中添加，也可以在编辑器中暂时“置空”，转而在代码中动态生成，这都是可以的。没有碰撞形状的碰撞节点不会参与游戏中的碰撞交互，碰撞形状主要分为： CollisionShape2D 和 CollisionPolygon2D 两种，应用非常简单，在场景中表现为蓝色区域，游戏运行后并不会显示，可以在 Debug 调试中打开显示效果，在之前的文章中已经详细讨论过。 这里重点要提到的概念是碰撞图层以及碰撞图层掩码。在使用碰撞图层之前，你必须在 Godot 项目设置中对你所需要的图层进行添加并合理命名： 如果你熟悉 iOS 游戏开发框架 SpriteKit 的话，那么这两个概念对你来说很简单，这里我们先列举一下它们的定义： Layer 即图层，在代码中为 collision_layer ，它表示物体所处的碰撞图层，一个物体一般处于一个图层中 Mask 即掩码，在代码中为 collision_mask ，它表示当前物体所关心的其他的碰撞图层，可包含多个图层 碰撞图层很好理解，类似 PhotoShop/GIMP/Krita 这些图片处理软件中的图层概念，用于把不同的内容分离开来，游戏中碰撞节点一般处于某一个特定的碰撞图层中。那么掩码又是啥意思呢？它实质代表的意义是这个物体需要与哪些图层进行碰撞检测，所以一个节点的掩码可以包含多个图层，如果对方所处的碰撞图层不在你的掩码范围内，那么就不会与之发生碰撞检测，有点拗口，举个例子你就能明白，给节点设置图层的方法以及各自所属的图层如下： 游戏物体 碰撞图层 图层掩码 玩家 1 2, 3 敌人 2 1 (or 0) 金币 3 1 (or 0) 在这种场景设置下，很显然，玩家掩码为 2(enemy) 和 3(coin) ，那么玩家会检测与敌人或者金币之间的碰撞，敌人和金币的掩码设置都是 1(player) ，所以它们分别也会检测与玩家之间发生的碰撞，但是敌人与金币、敌人与敌人、金币与金币、玩家与玩家之间则都不会互相发生任何碰撞检测！ 重点说明：图层和掩码都可以不勾选，也就是完全删除，如果这里敌人或者金币删除全部的掩码，即设置图层掩码为 0 ，那么是不是敌人就不能检测到与玩家之间的碰撞了呢？其实并不是！他们依然能互相检测到与对方的碰撞，这是因为玩家的掩码中包含了敌人，只要双方有一个设置了与对方可以发生碰撞检测的掩码，那么双方即可相互检测到与对方之间发生的碰撞！ 既然如此，那么假设有这种需求：“游戏中的玩家只检测敌人或者金币，而金币或者敌人不需要去检测玩家”，那能否实现呢？其实在 PhysicsBody2D 的三个节点中还真没办法，但是这里我们可以不考虑使用 KinematicBody2D 等节点，转而使用 Area2D 节点就可以实现了，需要注意该节点的两个属性： Monitoring 是否能主动检测其他碰撞体 Monitorable 是否能被其他碰撞体检测到 Area2D 这两个属性一直是新手容易忽略的，弄清楚了这两个属性的概念，你就可以关闭敌人或者金币（使用 Area2D 节点）的 monitoring 属性，关闭后它们不会主动检测与其他碰撞节点的碰撞，同时，在我们的 Demo 中玩家还是可以检测到他们。另一方面，如果要让某个金币不被玩家检测到，就像海底捞月，看得见摸不着的效果，那么可以设置其 monitorable 为关闭即可！嗯，还是用实际 Demo 来体会一下效果吧： OK ，明白了图层和掩码对游戏的开发帮助非常大，你完全可以自己写一个 Demo 尝试一下，或者下载我的源码一探究竟吧，偷偷告诉你：这很重要！哈哈！ 两个重要的方法接下来我们的重点是 KinematicBody2D 节点的两个常用方法，因为涉及到物理碰撞的大部分游戏中，玩家都是使用 KinematicBody2D 节点制作的，而它又有两个非常重要的碰撞处理方法，所以我们必须重点“针对”它们！ 首先，在正常的游戏场景中，对于 KinematicBody2D 几何学碰撞体节点的移动实现，我们主要有以下三种方式： position 属性设置，即控制位置，完全手动检测碰撞 move_and_collide() 方法调用，移动并自动检测碰撞 move_and_slide() 方法调用，移动并自动检测碰撞，支持滑动 对于第一种方式，直接操作 position 位置属性，一般在有碰撞体的游戏中很少这么“武断”地使用，即使你的游戏是没有任何碰撞体，你这个时候你也没必要选择 KinematicBody2D 节点，直接使用 Area2D 节点就好。那么，接下来我们主要讨论另外两种方式，包括它们的定义，区别与联系以及应用场合等。 1. 相关联系第一个：很显然，他们必须都在 _physics_process(delta) 方法中调用，因为该方法的内部会对物理引擎进行相关处理，前面我们已经讨论过，最好不要在 _process(delta) 中使用这两个方法，避免出现异常情况，这也是新手容易犯的错误之一。 第二个：这两个方法在某场景中是完全可以互相取代的，只需要对碰撞行为作出对应的处理即可。举个例子，下面两个代码段的效果表现会完全相同： move_and_collide123var collision = move_and_collide(velocity * delta)if collision: velocity = velocity.slide(collision.normal) move_and_slide1velocity = move_and_slide(velocity) 效果图如下： 2. 两者区别第一个，从上面的代码中我们能很明显地看出来，在使用这两个方法时，需要传递 KinematicBody2D 物体的速度作为参数；而这个速度在 move_and_collide() 方法中需要乘以帧间隔 delta ，但是在 move_and_slide() 方法中并不需要，这是因为此方法在内部已经帮我们自动处理好了，无需手动相乘。 第二个，根据上一条以及前面的代码，我们可以总结出在通用性方面，明显 move_and_collide() 更加通用，可以处理运动过程中任何碰撞情况，但是需要手动编码，处理起来也稍难；而 move_and_slide() 方法则更加特别，这对于新手朋友来说也会感觉相对简单。 第三个，使用方式不同，也就是说这两个方法的签名是完全不一样的： 方法 move_and_collide move_and_slide 返回值类型 KinematicCollision2D ：包含碰撞相关信息 Vector2 ：移动碰撞后的实际速度 参数1 rel_vec ：Vector2 类型，表示实际速度，记住需要乘以 delta linear_velocity ：Vector2 类型，表示速度，不需要乘以 delta 参数2 ✨ infinite_inertia ： 3.1 版本新增参数，默认为 true floor_normal ： Vector2 类型，表示地面法线方向，默认值 (0, 0) 参数3 ✨ exclude_raycast_shapes ： 3.1 版本新增参数，默认为 true slope_stop_min_velocity ：最小速度，斜坡上速度小于该值则停止滑动，默认 5 参数4 ✨ test_only ： 3.1 版本新增参数，默认为 false max_bounces ：停止运动前最大碰撞次数 ，数值过低可能会直接终止运动，默认 4 参数5 - floor_max_angle ：能移动的最大斜坡角度，弧度计，默认值 0.785398 即 45° 参数6 - ✨ infinite_inertia ： 3.1 版本新增参数，默认为 true 说明：上面有一些标注了 ✨ 的参数是 Godot 3.1 版本中新增的参数，暂时没有详细的文档说明，等待正式版以及文档发布后会有详述，另外 3.1 版本新增了一个 move_and_slide_with_snap() 方法，值得关注。 两个方法中，上面列举的一些参数都还是很好理解的，对于一般场合下，方法的默认参数都够用。其中，参数 floor_max_angle 表示最大斜坡角度，低于该角度的斜坡都被认为是“可滑行”的地面，另外参数 floor_normal 表示地面的法线，可以结合 KinematicBody2D 的几个方法： is_on_floor() （在地面上）， is_on_wall() （在墙壁上），以及 is_on_ceiling() （在天花板上）搭配使用。 第四个，通过上表可以看出来，如果我们需要检查玩家碰撞后的反馈信息，我们可以使用 move_and_collide() 方法的返回值即可，如果使用 move_and_slide() 能不能即使获取相关信息呢？当然也可以，稍微繁琐，我们可以使用 KinematicCollision2D get_slide_collision(int slide_idx) 方法以及 int get_slide_count() 正确处理即可，示例代码如下： 1234567func _physics_process(delta): var velocity = move_and_slide(velocity) var count = get_slide_count() for i in range(count): var collision = get_slide_collision(i) var collider = collision.collider print('collider ', i + 1, ': ', collider.name) 3. 应用实践这两个方法确实有点绕，别急，先搞清楚他俩的相似点以及不同点，然后我们就可以在不同场合中灵活使用了。 1. 最基本的移动 观察下图这个示例，使用 move_and_collide() 方法在没有遇到障碍物时一切正常，但是遇到墙壁后，如果玩家的速度方向与墙壁表面相交，就会出现卡住的奇怪现象。究其原因，这是因为我们虽然使用了碰撞移动方法，但是遇到碰撞后的反馈并没有手动处理，所以 move_and_collide() 这个方法在玩家遇到碰撞时只能停下而表现出“卡注”的现象。 解决这个问题的方法很简单，把方法替换为 move_and_slide() 即可。该方法不仅能正确处理碰撞反馈，还能告诉你在发生碰撞后物体的实际运行速度，即方法的返回值，在本 Demo 中你可以通过打开 use real velocity 这个开关查看碰撞后物体运动的实时速度。 那么，是不是所有的 KinematicBody2D 节点的移动都应该直接使用 move_and_slide() 方法呢？当然不是！一起来看第二个示例。 2. 碰撞反弹效果 考虑下这个场景，我们有一个用刚体（不反弹）做成的弹力球，这个球在碰撞到墙壁后能弹回去，但是墙壁是静态物体也没有弹性，这个时候如果使用 move_and_slide() 方法那么弹球遇到墙壁就会停止或者直接沿着墙壁下滑啦，如何处理呢？很显然，我们需要一点代码！ 这就是 move_and_collide() 方法的用武之地了，我们可以利用这个方法的返回值进行相关处理，返回值是一个 KinematicCollision2D 类型的碰撞结果，其中包含我们所需要的数据，比如碰撞体的表面方向，即碰撞体的法线方向（垂直方向），把弹力球的速度按法线方向将其反射，那么球就能顺利反弹了！ 代码可以参考上文，图效果可以看下： 3. 2D 平台游戏 平台游戏应用非常广泛，常见的跳跃类型的游戏很多都是 Platform Game ：左右移动，上下跳跃。平台游戏场景中静态物体元素比较多，一般有地面，墙壁，还有斜坡等，那么玩家在这些平台上如何移动呢？其实核心代码非常简单，这不得不归功于 Godot 提供给我们的 move_and_slide() 方法的了！这种情况在 Unity 中就稍显麻烦了，你还得使用射线（ Raycast ）处理与墙壁、地面等的碰撞检测，而 Godot 中对于小游戏而言，一个方法就能解决所有问题，听起来是不是有点小激动？别急，先看代码： 123456func _physics_process(delta): var collision = self.move_and_collide(velocity * delta) if collision: velocity = velocity.bounce(collision.normal) if collision.collider.has_method('hit'): collision.collider.hit() 当然， Godot 中也有射线节点，后面会提到，下面是一个普通的 move_and_slide() 方法的应用示例： 三、总结枯不枯燥？烦不繁琐？哈哈，啰嗦了一大堆， Godot 的强大和方便之处领悟到了吗？哈哈，如果还不能马上体会，你可以到我的 Github 仓库下载源码，然后打开每一个场景，使用快捷键 F6 单独运行场景查看效果；如果本文对你来说很简单，那么是不是迫不及待地想写一个平台游戏练练手啦？ Just do it, man! 好了，总结一下本文的相关理论知识吧： 三种 2D 物理节点以及 Area2D 节点的回顾 碰撞层和碰撞掩码理论知识 KinematicBody2D 两个方法详述 简单的应用场景分析 本篇的 Demo 以及相关代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos ， 2018 年最后一篇文章，原创不易，希望大家喜欢，我们 2019 年见！ 参考文档：官方 API 文档： http://docs.godotengine.org/en/3.0/classes/class_kinematicbody2d.html?highlight=kinematicbody2dGodot 3.0: Using KinematicBody2D ： http://kidscancode.org/2018/02/godot3_kinematic2d/我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之十一：Godot中的粒子系统与射击游戏（下）","url":"/2018/12/25/introduction-of-godot-3-part-11-introduce-the-particles-system-and-make-a-shooter-game-part-2/","text":"一、前言继续讲解我们的第二个小游戏：太空射击游戏，本篇为上一篇文章的继续。在上一节中我给大家介绍了 Particles2D 粒子节点的相关参数以及简单的应用，这一节则介绍这个小游戏中的主要场景和关键的代码实现。 PS ：在写文章的这两天， Godot 官方又紧凑地发布了第四个 Alpha 版本，大家可以到这里下载： Godot 3.1 Alpha4 ，本以为圣诞节前会发布第一个 Beta 版本，目前来看还会有第五个 Alpha 版本， Beta 版本肯定要等到 2019 年啦！嗯，热情期待中…… 主要内容：太空射击游戏场景与代码（下篇）阅读时间： 12 分钟永久链接： http://liuqingwen.me/2018/12/25/introduction-of-godot-3-part-11-introduce-the-particles-system-and-make-a-shooter-game-part-2/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 介绍 Godot 中自带的粒子系统（上篇） 了解其他几个常见节点的使用（上篇） 本射击游戏场景介绍和代码 游戏所有场景太空射击游戏的场景主要分为：玩家、敌人（外星人和岩石）、子弹、 UI 界面 、入口主场景等，每个场景的构造都很简单，所应用到的几个新节点我也在上一篇文章中作了简短的介绍，其他节点相信看过我本系列文章的朋友都应该很熟悉啦，哈哈。 提醒大家的是，子弹场景有两个： Bullet.tscn 和 EnemyBullet.tscn ，从名字可以看出来，一个是用于玩家发射的子弹，一个是敌人发射的子弹，他们除了子弹的图片也就是外观不同之外，其他部分，包括代码都是完全一样的，因为 EnemyBullet.tscn 就是直接从 Bullet.tscn 继承实例化而来。（如何实例化一个场景？还记得 🔗 这个图标吗？找一找吧。） 浏览一下所有场景“构造图”，接下来简单地一一介绍下所有场景及其核心代码部分。 1. 子弹场景首先是子弹场景，它比较特殊，有两个。子弹场景主要用于玩家和敌人发射的子弹，每颗子弹在发射后会一直往一个方向飞行，飞行过程中检查是否与其他对象相撞，然后在代码中做出相应的处理： Bullet.gd12345678910111213141516171819202122232425262728293031323334353637extends Area2Dsignal destroy_object(type)# 子弹种类：玩家、敌人export(String, 'player', 'enemy') var type = 'player'var _velocity = Vector2() # 子弹速度func _process(delta): self.position += _velocity * deltafunc _on_Bullet_area_entered(area): # 敌人的子弹击中玩家 if area.is_in_group('player') &amp;&amp; type == 'enemy': area.destroy() self.queue_free() # 子弹击中敌人，对玩家子弹和敌人子弹处理不同 elif area.is_in_group('enemy') || area.is_in_group('rock'): if type == 'player': area.destroy() var objectType = 'enemy' if area.is_in_group('enemy') else 'rock' self.emit_signal('destroy_object', objectType) if ! (area.is_in_group('enemy') &amp;&amp; type == 'enemy'): self.queue_free() # 敌人的子弹和玩家子弹相撞 elif area.is_in_group('bullet') &amp;&amp; area.type != type: area.queue_free() self.queue_free()# 子弹飞出屏幕func _on_VisibilityNotifier2D_screen_exited(): self.queue_free()# 设置子弹速度func start(velocity): velocity = velocity 那么如何在玩家和敌人场景中分别使用这两个子弹场景呢？只需要在 Player 脚本以及 Alien 脚本代码中，添加一句代码即可： export(PackedScene) var bulletScene ，也就是把各自要用到的子弹场景暴露为显示在编辑器中的变量，这样我们就可以直接拖拽相对应的子弹场景到各自的 bulletScene 属性中。 一个场景（节点）应用到多个场合在游戏中是很常见的，对于子弹场景除了我所采用的这种处理方式，还有另外一种常见的方法：只需要设置一个 Bullet.tscn 子弹场景，然后在代码中创建子弹的时候，动态设置子弹的材质就可以了。这样一个子弹场景就能轻松地被玩家和敌人分别使用，伪代码如下： 1234567var playerBulletImageTexture = load('res://Assets/Images/player_bullet.png');var enemyBulletImageTexture = load('res://Assets/Images/enemy_bullet.png');func setType(type): match type: 'player': $Sprite.texture = playerBulletImageTexture; 'enemy': $Sprite.texture = enemyBulletImageTexture; 关于资源加载函数 load() 我想在后面会继续讨论。一般游戏中会优先使用第二种方式，但是第一种方式更加适合新手，而且扩展性也更好，比如我想在敌人的子弹场景中再加一些其他的效果，让它变得更酷，这都是非常方便且直接的，另外结合 export(PackedScene) 更可以轻松的拖拽其他场景到对应的场景属性下，非常方便，大家多多感受下。 2. 背景场景关于背景图片我已经在上一篇文章中说明过了，不过并没有详细阐述其原理，也没有提供任何代码，其实背景场景的代码是最少的： 1234567extends ParallaxBackgroundexport(float) var scrollSpeed = 50func _process(delta): # 手动控制背景滚动 self.scroll_offset.y -= scrollSpeed * delta 然后参考一下其相关节点的设置你就能明白其中的道理： 前面两个节点很好理解，实际开发中，对于 ParallaxBackground 背景节点，我们一般会应用于有摄像机节点的游戏中，这样背景会自动跟随摄像机滚动，在 2D 游戏中我们可以设置多层背景，比如靠近玩家的树木、远离玩家的山岭、最远方的太阳或者月亮等，很显然，越远的物体滚动速度越慢，也就是 Scale 属性值越小，越近则滚动越快，大家可以结合之前的图片体会一下。那么，像本游戏中没有摄像机该如何处理呢？依然很简单，如上代码，手动设置背景的滚动属性就可以啦。 3. 敌人场景游戏中敌人主要有两种，一种是外星人，另一种是坠落的岩石，脚本代码也都很好理解，这里我给敌人添加了一些有趣的随机元素，它们可以水平移动并且随机发射子弹，核心代码如下： Alien.gd12345678910111213141516171819# 移动并发射，生命周期内无限循环func _moveAndShoot(): # 第一次移动，不发射子弹 var nextMovement = rand_range(0.5, 1.5) yield(self.get_tree().create_timer(nextMovement), \"timeout\") # 2/3几率发生水平移动，否则只做垂直运动 var shouldMove = randi() % 3 &gt;= 1 if shouldMove: _hMovement = randi() % 3 - 1 nextMovement = rand_range(1.0, 1.5) yield(self.get_tree().create_timer(nextMovement, false), \"timeout\") _hMovement = 0 # 如果在屏幕范围内，则发射子弹 if _isInShootableArea(): _shoot() # 继续下一轮操作 _moveAndShoot()# 省略代码…… 这是一个无限循环：外星人进入游戏场景后，随机飞行一段时间，随后有一定的概率发生水平移动，接下来判断外星人是否在屏幕范围内，在范围内则发射一颗子弹。方法中我使用了很多随机时间节点，也是为了丰富游戏场景，让游戏稍微有点挑战性吧。 对于岩石场景的代码我就不贴出来了，岩石只有滚动和一定大小的随机缩放，代码很简单，不再啰嗦。 4. 爆炸场景爆炸场景使用了 Particles2D 粒子节点，一个爆炸场景我使用在了这三个地方：岩石爆炸、敌人爆炸以及玩家爆炸。他们的处理方式稍微不同，这里可以从代码中看出来： Explosion.gd12345678910111213141516171819# 爆炸对象的类型：岩石、敌人、玩家var type = 'rock' setget _setTypefunc _ready(): match type: 'rock': self.amount = 40 _audioPlayer.stream = rockAudio 'player': # 延长玩家爆炸特效的时长 _lifeTimer.wait_time = 2.0 _audioPlayer.stream = playerAudio 'alien': self.amount = 50 _audioPlayer.stream = alienAudio _audioPlayer.pitch_scale = 2.0 _audioPlayer.play()# 省略代码…… 嗯，区别在于三种爆炸的音效不同，粒子数量稍微有点差别而已。关于粒子我在上篇文章中已经详细讲述，如果有不清楚的，大家可以下载源码参考一下。 5. 玩家场景玩家场景就非常熟悉啦，主要是控制玩家的移动，还有子弹的发射： Player.gd123456789101112131415161718# 射击函数func _shoot(): if bulletScene == null: return # 生成一个子弹对象 var bullet = bulletScene.instance() # 设置子弹的全局位置 bullet.position = _shootPoint.global_position # 调用子弹的公开方法，设置速度 bullet.start(Vector2(0, - bulletSpeed)) # 连接子弹的信号 bullet.connect('destroy_object', self, '_on_Bullet_destroy_object') # 把子弹添加到游戏root根节点 self.get_tree().get_root().add_child(bullet) # 音效 _shootSound.play()# 省略代码…… 这里核心代码在于 self.get_tree().get_root().add_child(bullet) 这一句，可以看出来，我把发射子弹后生成的子弹节点添加到了游戏的根节点 root 下，这样保证发射出去的子弹和玩家没有任何关系，不会发生内存泄漏。 6. 游戏主场景主场景是所有子场景和代码的组合，主要负责游戏的整体控制，关键代码在于生成并添加当前关卡的所有敌人，包括岩石和外星人，另外在 _process(delta) 方法中还会不断地判断敌人是否已经被消灭完或者游戏是否已经结束。 Game.gd12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var _isGameOver = false # 游戏是否结束var _score = 0 # 分数var _currentWave = 0 # 敌人波数var _totalAliens = 0 # 敌人总数var _totalRocks = 0 # 岩石总数var _enemyCount = -1 # 计数：敌人+岩石func _process(delta): # 如果计数为0，且所有敌人被移除则进入下一波 if !_isGameOver &amp;&amp; _enemyCount == 0 &amp;&amp; _enemyContainer.get_child_count() == 0: _enemyCount = -1 _nextLevel() # 如果游戏结束，且所有敌人被移除，显示开始按钮 elif _isGameOver &amp;&amp; _enemyContainer.get_child_count() == 0: _ui.showStartButton()# （重新）开始游戏func _restart(): _isGameOver = false _score = 0 _ui.updateScore(_score) _currentWave = 0 _audioPlayer.play() # 添加玩家到当前场景 if playerScene != null: var player = playerScene.instance() player.connect('game_over', self, '_on_Player_game_over') player.connect('score_updated', self, '_on_Player_score_updated') player.position = _startPosition self.add_child(player) # 开启第一关 _nextLevel()# 消灭（避开）所有敌人，进入下一关func _nextLevel(): _currentWave += 1 _ui.updateWave(_currentWave) yield(self.get_tree().create_timer(3.0), 'timeout') _ui.hideMessage() _calculateEnemies() _enemyCount = _totalAliens + _totalRocks _generateRocks() _generateAliens()# 每隔一定时间（随机）生成岩石func _generateRocks(): if rockScene == null: return for i in range(_totalRocks): if _isGameOver: return var rock = rockScene.instance() var yPosition = rand_range(-40, -100) rock.position = Vector2(80 * (randi() % 6) + 40, yPosition) _enemyContainer.add_child(rock) _enemyCount -= 1 var nextTime = rand_range(0.5, 1.5) yield(self.get_tree().create_timer(nextTime, false), 'timeout')# 每隔一定时间（随机）生成敌人func _generateAliens(): if alienScene == null: return for i in range(_totalAliens): if _isGameOver: return var alien = alienScene.instance() var yPosition = rand_range(-40, -100) alien.position = Vector2(60 * (randi() % 5) + 80, yPosition) _enemyContainer.add_child(alien) _enemyCount -= 1 var nextTime = rand_range(1.0, 2.5) yield(self.get_tree().create_timer(nextTime, false), 'timeout')# 根据当前关卡得出敌人数量func _calculateEnemies(): _totalAliens = _currentWave * 2 + 3 _totalRocks = _currentWave * 3 + 5# 省略代码…… 同样省略了一些代码，这里核心函数是 _nextLevel() 方法，方法里又调用了另外两个重要方法： _generateRocks() 和 _generateAliens() ，通过大量使用 yield 关键字创建时间计时器，这样让游戏更加随机性，让太空显得更加真实。 游戏完善好啦，看一下我们的成果吧，最终效果一览： 大家可以自己尝试做这么个小游戏，也可以直接下载源码然后运行，对于热爱游戏的朋友，我觉得不应该只停留在“ play ”上，这个游戏可以做得更加有趣，你觉得呢？所以，我建议新手朋友们可以继续尝试尝试以下几点完善： 可以丰富子弹系统，提供一些更加有趣的子弹样式、发射方式 可以丰富怪物系统，比如每个关卡设置一个最终 BOSS 等 可以实现多人游戏，这个对新手有点难度，我想以后会谈的 只是自己的一点点想法，哈哈。 三、总结这个小游戏的制作就此结束啦，总结一下本篇上下文的主要知识点： Godot 中自带粒子系统的相关参数说明 游戏中应用到的其他几个有用的节点 太空射击游戏的所有场景构造及其关键点 游戏代码逻辑的核心部分解析 本篇的 Demo 以及相关代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos ，最后，原创不易，希望大家喜欢吧！ 我的博客地址： http://liuqingwen.me ，我的博客即将同步至腾讯云+社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3sg12o13bvwgc ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之十一：Godot中的粒子系统与射击游戏（上）","url":"/2018/12/23/introduction-of-godot-3-part-11-introduce-the-particles-system-and-make-a-shooter-game-part-1/","text":"一、前言第一个收集金币的小游戏结束了，洋洋洒洒写了三篇文章，分别介绍了相关节点、场景以及所有的代码，作为新手能够独立使用 Godot 完成自己的第一个游戏也算是正式入门了！接下来，我们开启第二个完整的小游戏介绍：太空射击小游戏！同样很简单，但是有更多的发挥空间，当然，我只介绍最简单的游戏实现，更多的关卡设计、游戏思路和游戏元素则留给大家去摸索开发吧。 我选择这个游戏的灵感来自于我刚开始学习 Unity 游戏开发时，在官方视频教程中看到的一个游戏： Space Shooter tutorial ，你会发现我在游戏里使用的素材都是来自这个游戏。除此之外，我推荐大家去下载另一个使用 Godot 引擎制作的太空射击类小游戏： Space Rocks ，这个游戏的玩法截然不同，它的原理也更加值得新手去学习，代码中有许多的关于刚体模型物理碰撞的处理。 本节分为上下两篇文章，源码我已经完整地上传到 Github 仓库，欢迎大家克隆并提交 issue ，在开始之前我得申明一下： 我使用的 Godot 版本依然是最新的预览版： Godot 3.1 Alpha3 这已经是本系列教程的第十一篇，所以会忽略部分细节，有问题请随时留言 推荐加入国内 Godot 游戏开发 QQ 交流群： 691534145 （本人非群主） 主要内容：粒子系统的介绍（上篇）阅读时间： 9 分钟永久链接： http://liuqingwen.me/2018/12/23/introduction-of-godot-3-part-11-introduce-the-particles-system-and-make-a-shooter-game-part-1/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 介绍 Godot 中自带的粒子系统 了解其他几个常见节点的使用 本射击游戏场景介绍和代码（下篇） 粒子系统介绍中大型游戏中，几乎没有哪个游戏不使用粒子特效的。掌握粒子系统对游戏开发极其重要，合理地使用粒子特效对游戏效果绝对是锦上添花、如虎添翼，常见的粒子特效有：烟花、灰尘、火焰、爆炸、光环、雪花、雨滴、溅射等等等等。比如下面的这张非常熟悉的效果图，使用的就是粒子特效： 想要实现很酷的粒子特效是需要一定的学习和经验积累的，这里推荐大家去油管（ youtube ）上订阅一个名叫 Duc Vu 的泰国人的频道，专做特效视频教程，虽然他大部分教程里使用的是 Unity 粒子，但是思想理论和部分设置都是大体相同的，直达连接： https://www.youtube.com/channel/UC5ZauAWNyh931gRJUqB1QPw 在本射击游戏中，我在四个地方使用了粒子特效，不过这都是一些非常简单的效果，设置起来也很轻松，简单的参数调整即可，接下来我们一起来讨论下这些重要的参数吧！ 粒子系统参数粒子节点 Particles2D 是 Godot 中所有节点里参数最多的一个，这也是为什么同一个材质，打造出的粒子特效千变万化的原因之一。如果想要实现自己心中的效果，我们需要多尝试、多调试、多实践，当然，有几个参数是对结果影响最直接的，请听我一一道来。 首先是粒子节点中最基本的一些参数，大部分参数看名字就知道其意义，如下表格： 参数 解释 说明 Emitting 是否发射粒子 如果 One Shot 勾选， Emitting 将会被取消勾选 Amount ⭐⭐ 发射粒子的总数量 粒子消亡将重新产生新粒子，配合 Lifetime 生命周期参数 Lifetime ⭐⭐ 粒子的生命周期 通过计算，每隔 Lifetime/Amount 的时间产生一颗新粒子 One Shot 只发射一次 非常适用于爆炸等特效，在代码中控制发射 Preprocess 预热，提前发射粒子 比如游戏中的下雪场景，也叫 Pre-warm Speed Scale 速度缩放系数 整体效果，影响粒子材质中的 Velocity 速度参数 Explosiveness 爆炸系数 粒子从中间往四周扩散，爆炸特效必备 Randomness 随机系数 粒子产生的随机性，取值 1 为完全随机 Local Coords ⭐ 是否为本地坐标 位于 Drawing 子菜单，粒子运动在本地坐标还是世界坐标 这些是 Particles2D 节点的主要参数，控制粒子的一些整体效果，当然，仅仅依靠这些参数是不行的，当我们在使用粒子节点的时候，必须要给粒子节点添加一个 Material 材质，否则你不会看到有任何效果发生，在 Process Material 菜单下，材质分为两种： ShaderMaterial 和 ParticlesMaterial 。 这里我们选择给粒子节点创建一个新的 ParticlesMaterial 粒子材质，在粒子材质中又有更丰富的参数配置，通过调节这些参数达到我们想要的效果，主要参数如下表： 参数 解释 说明 Emission Shape 发射体的形状 有点、球体、方体、多点等形状 Spread ⭐ 粒子产生的范围 最大值为 180 度乘以 2 倍，即全范围发射： -180°~180° Gravity 重力加速度 设置为 0 粒子将不受重力控制 Initial Velocity ⭐ 粒子发射初始速度 与生命周期 Lifetime 参数结合产生特效 Angular Velocity 粒子的角速度 类似 Initial Velocity Linear Accel 粒子的加速度 与 Initial Velocity 参数配合 Radial Accel 粒子旋转加速度 与 Angular Velocity 参数配合 Damping 阻尼系数 类似遇到逆风、摩擦阻力的效果 Angle 粒子角度 粒子的旋转角度，非发射方向 Scale ⭐ 粒子缩放尺寸 可以设置随机，随时间变化而调整粒子的缩 Color ⭐ 粒子的颜色 可以设置渐变颜色，粒子颜色随时间而变化 粒子材质的这些参数非常好理解，其中比较重要的参数我已经标记了，大家可以自己尝试不同参数值对效果的影响。 一般来说，我们在使用粒子系统制作理想效果的时候，还会经常遇到随机参数以及曲线设置。粒子系统中很多参数设置都有曲线功能，比如 Scale 缩放参数，我们可以给它设置一个 Scale Curve 曲线，在曲线上通过添加、删除、移动锚固点来调整曲线的样式，最终粒子的大小缩放也就会随时间顺应曲线而变化。 如果你熟悉 Unity 粒子，你会发现 Unity 粒子的曲线功能调整更加方便，这里顺便赞一下 Unity 2018.3 新版本的一些新功能、新特性、新改进，互相学习很重要嘛。 除此之外，真正的特效一般都会使用到各种各样的图片作为粒子材质纹理， Godot 中粒子节点还支持使用 SpriteSheet 精灵图集、动画材质、地图材质等，位于 Textures 纹理菜单下，本游戏并没有使用到，大家可以去研究研究。 简单粒子效果我在射击游戏中实现的粒子特效都极其简单，也没有使用任何其他的图片作为粒子的材质纹理： 注意这三个效果中的爆炸效果需要 Explosiveness 参数的配合，相信大家都能做出以上简单的粒子特效。总之，对于粒子特效的应用就是对粒子属性的熟悉度，我给新手朋友们的建议是：尽量使用最少的参数配置出近视的效果，当效果接近理想目标后，再进行其他参数的调整。还有提醒大家的是： Godot 中的 2D 粒子完全可以使用在 3D 游戏中！骚年们，充分发挥自己的创意，尽情打造酷炫的效果吧！ 其他几个节点游戏中除了 Particles2D 节点，我还使用了其他三个新的节点： VisibilityNotifier2D/ParallaxBackground/TextureButton ，这里我也简单地说明一下： VisibilityNotifier2D 用于控制节点进出视窗、屏幕通知，比如用于物体飞出屏幕就删除等 TextureButton 一个按钮控件，和普通按钮不同的是，它可以设置按钮在鼠标的各种状态下的图片显示 ParallaxBackground 节点配合 ParallaxLayer 实现滚动特效，主要属性参数为 Scroll 和 Scale 等 说明：游戏中我就是使用 ParallaxBackground 节点实现的无限太空背景滚动效果，它需要一个或者多个子节点 ParallaxLayer 的配合，其原理就是通过各个 ParallaxLayer 层不同的滚动速度来实现背景远近的视觉效应，效果类似如下平台游戏： 三、总结（上）好了，上篇就介绍这些内容吧，下篇主要内容是代码的重点解析。总结一下本篇主要知识点： Godot 中自带粒子系统的相关参数说明 游戏中应用到的其他几个有用的节点 本篇的 Demo 以及所有代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos 未完待续……！","tags":"godot"},{"title":"解决Hexo博客批量上传的小问题：利用 Python 脚本提取 HTML 文件","url":"/2018/12/12/make-a-python-script-to-duplicate-blog-html-files-for-uploading-to-server/","text":"一、前言每次写完一篇文章后，我都要手动上传到我的博客空间服务器，虽然算不上麻烦，不过还是非常羡慕那些直接使用 git deploy 命令的朋友们，一键发布，方便快捷啊！ 因为 Hexo 博客框架所生成页面都是静态 HTML 文件，所以当我更新博客的某一个功能或者添加一个小插件的时候，所有的页面都会更新，包括图片等文件的修改时间！所谓：“牵一发而动全身”，这个时候我就非常痛苦了，需要重新上传本月的所有文章、今年的所有文章、去年的所有文字…… 所以，基于这个痛点，我早已在心里下定了决心，在某一天要亲手“解决它”！嗯，时机来了，最近有空闲时间的时候在自学 Python ，刚好可以尝试练习一下，利用 Python 脚本来提取需要更新的文件，然后复制到一个与源文件路径对应的临时文件夹中，最后批量上传到服务器覆盖即可，不得不说这句话是对的： 人生苦短，我（需要）用 Python ！ 另外，如果你还没有创建博客，推荐使用 Hexo 搭建；如果刚创建博客，还在搜寻可用插件的话，那么可以参考我之前的几篇文章： 「Hexo On Win10」新手搭建博客过程 分享几个实用的 HEXO 博客功能插件 分享一个精致实用的 HEXO 博客小插件：日历云 二、正文注意：本文仅适用于那些使用 Hexo 搭建博客，平时写的文章有大量图片，还需要自己手动上传服务器的朋友。其他同学就请随意啦！ 问题所在问题已经描述过了，比如之前我在自己的博客页面添加了一个日历云小插件，然后高兴地使用 hexo g 命令重新生成所有文章，接下来一顿崩溃： 我的文章比较多，网络不给力，上传所有文件到服务器非常耗时 直接覆盖全部文件会遇到断线重连的情况，导致服务器上某些文件“半途而废” 图片多而且不会发生变化，不需要把图片上传覆盖到服务器 如果选择手动提取 HTML 文件则非常耗时，因为文件夹“很有深度” 有点啰嗦，虽然我使用的 WinSCP 有选择覆盖“最新的文件”的功能，但是并没有什么卵用，我也没有在 Hexo 插件中找到相关解决方案的插件，所以只能自己动手了。 解决思路思路非常简单：只要把需要更新的类型的文件提取出来到一个临时文件夹，同时保持和源文件的文件夹结构相同，那么上传的时候只需要一次性覆盖最顶层文件夹就可以了！ 一般来说，需要重新上传覆盖的文件都很小，是一些数据文件，比如： hmtl/json/xml/js 等。 所有代码代码就不用说明了，非常简单，完全新手作品，主要使用 Python 的 shutil 模块就可以轻松解决文件提取和复制等问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import osimport shutildef searchFile(src_dir, ext_filters, result_list): if not os.path.exists(src_dir) or not os.path.isdir(src_dir): print('None exits folder or not a directory at all, for:', src_dir, 'and will be ignored!') return for file in os.listdir(src_dir): file = os.path.join(src_dir, file) if os.path.isfile(file) and os.path.splitext(file)[1] in ext_filters: result_list.append(file) elif os.path.isdir(file): searchFile(file, ext_filters, result_list)def getSearchedFiles(src_dir, ext_filters): results = [] searchFile(src_dir, ext_filters, results) print('Find %d files in %s directory!' % (len(results), src_dir)) return resultsdef copySingleFile(src_file, dst_dir): if not os.path.exists(src_file): print('No such source file') return src_dir = os.path.split(src_file)[0] if os.path.isfile(src_file) else src_file src_dir = os.path.relpath(src_dir) dst_dir = os.path.join(dst_dir, src_dir) dst_dir = dst_dir.replace('..\\\\', '') # for test! if not os.path.exists(dst_dir): os.makedirs(dst_dir) shutil.copy2(src_file, dst_dir)def createGeneratedFolder(): current_path = os.path.abspath('.') # 临时文件夹，自行修改吧 generate_path = os.path.join(current_path, 'temp') generate_path = os.path.join(generate_path, 'generated') if os.path.exists(generate_path): os.removedirs(generate_path) os.makedirs(generate_path) return generate_path# 修改这里为你的文件夹路径def getInputWorkDirectories(): dirs = [] # 你的文件夹路径，绝对路径，可以不写 use_default = input('Use default directories?(y/n):') if use_default not in ['n', 'no', 'NO', 'N']: return dirs path = input('Input the work directory(0 char to stop):') dirs = [path] while len(path) &gt; 1: path = input('Input the work directory(0 char to stop):') dirs.append(path) return dirsdef startWork(): gene = createGeneratedFolder() dirs = getInputWorkDirectories() if len(dirs) == 0: return extensions = getInputExtensions() # 方法已省略，返回扩展名数组 for d in dirs: files = getSearchedFiles(d, extensions) for f in files: copySingleFile(f, gene)if __name__ == '__main__': print('Start working......') startWork() print('Done!') 注：省略了一点点代码，可以直接到这里下载我写好的文件： copy_html.py ，最后代码中修改您的博客文件路径即可！ 在绝对路径和相对路径上，我写的还有点问题，还请大家多多包涵与指正，谢谢！ 三、总结代码太简单了，不过还算解决了我的一个小小烦恼。当然，你完全可以使用其他语言实现，比如 Kotlin/C#/JavaScript 等等，在这里我再次感受到了 Python 的简洁与方便。嘿嘿。 如果有大神看到了这篇文章，希望能打造一个 Hexo 内部功能或者插件，类似用于重新生成指定文件类型的命令，就像： hexo rebuild -html,json,xml 。（嗯，这个命令是我乱写的，别被忽悠！） 谢谢大家的观赏，欢迎留言交流！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"hexo python"},{"title":"Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（下）","url":"/2018/12/06/introduction-of-godot-3-part-10-introduce-some-node-types-and-make-a-new-game-part-3/","text":"一、前言继续前面的两篇文章，《Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏》一共分为三小篇，链接如下： Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（上） Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（中） Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（下） 主要内容：分析并制作一个完整的小游戏（下篇）阅读时间： 6 分钟永久链接： http://liuqingwen.me/2018/12/06/introduction-of-godot-3-part-10-introduce-some-node-types-and-make-a-new-game-part-3/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 了解学习游戏中的几个主要场景的制作 编写实现游戏中相关逻辑的代码 分析整个项目的一个开发流程 主要的场景请参考上一篇：Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（中）。 代码与逻辑部分代码见上篇文章：Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（中）。 相关的细节解释参考：Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（上）。 接下来是 UI 控件场景和 Main 游戏主场景的脚本代码，相对来说比较长，但是不难理解，相关重要的地方我已经做了注释，相信您能一目十行。 5. UI.gdUI.gd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657extends Control# 开始游戏的信号signal start_game()onready var _labelScore = $MarginContainer/HBoxContainer/LabelScoreonready var _labelTime = $MarginContainer/HBoxContainer/LabelTimeonready var _labelMessage = $VBoxContainer/LabelMessageonready var _labelReady = $VBoxContainer/LabelReadyonready var _buttonStart = $MarginContainer2/ButtonStart# 当前游戏是否被暂停，初始为“是”var _isPaused = true# 监听用户的输入func _input(event): if event.is_action_pressed('start'): # 这个if条件语句只会在游戏开始时运行一次！ if self.get_tree().paused != _isPaused: self.emit_signal('start_game') _isPaused = ! _isPaused self.get_tree().paused = _isPaused if _isPaused: _labelMessage.visible = true _labelMessage.text = 'Paused' else: _labelMessage.visible = false _buttonStart.visible = false# 开始游戏按钮被按下func _on_ButtonStart_pressed(): _isPaused = false _labelMessage.visible = false _buttonStart.visible = false self.emit_signal('start_game')# 显示Ready和目标金币数文本func displayReady(target = 0, display = false): _labelReady.text = '%d, Ready!' % target _labelReady.visible = display# 游戏结束显示的信息func showGameOver(): _isPaused = true _labelMessage.text = 'Game Over' _labelMessage.visible = true _buttonStart.text = 'Restart' _buttonStart.visible = true# 显示分数（金币个数）func showScore(score): _labelScore.text = str(score)# 显示时间（剩余时间）func showTime(time): _labelTime.text = str(time) UI 子场景代码稍复杂，不仅要显示一些文字信息，比如当前时间、收集到的金币数等，还负责接收响应玩家的键盘输入，处理开始、暂停以及游戏重试等。当然，逻辑并不复杂。 唯一要注意的地方是 if self.get_tree().paused != _isPaused: 这个判断语句，我在代码中已经作了相关说明，它的判断结果只有在游戏开始运行的第一次时为 true ，其他任何时间都为 false （因为 _isPaused 的初始值的原因），也就是表示在开始游戏的时候玩家按了 start 按键（我在 Input Map 中设置 start 输入为空格和回车），然后发射游戏开始的信号。当然，你完全可以再定义一个变量来实现游戏的开始和暂停等。 6. Game.gdGame.gd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141extends Node2Dexport(PackedScene) var coinScene = nullexport(PackedScene) var powerScene = nullexport(float) var minPlayerDist = 80export(float) var minObstacleDist = 120onready var _player = $Playeronready var _startPosition = _player.positiononready var _ui = $HUD/UIonready var _pointsCurve = $CactusPoints.curveonready var _cactus = $CactusPoints/Cactusonready var _coinContainer = $CoinContaineronready var _countTimer = $CountTimeronready var _powerTimer = $PowerTimeronready var _gameOverAudioPlayer = $GameOverAudioonready var _levelAudioPlayer = $LevelUpAuidovar _level = 0 # 当前关卡var _timeLeft = 0 # 剩余时间var _totalCoins = 0 # 金币总数var _collectedCoins = 0 # 收集金币数func _ready(): randomize() # 保证每次游戏都随机 _player.isControllable = false# 游戏结束初始化某些变量func _gameOver(): _level = 0 _countTimer.stop() _ui.showGameOver() for coin in _coinContainer.get_children(): coin.queue_free()# 重新开始游戏调用方法func _restartGame(): _player.isControllable = false _totalCoins = _calculateTotal(_level) _timeLeft = _calculateDuration(_level) _collectedCoins = 0 _ui.showScore(_collectedCoins) _ui.showTime(_timeLeft) _spawnObstacles() _spawnCoins() _player.restart(_startPosition) _ui.displayReady(_totalCoins, true) # 关键代码，如果不明白可以参考后面的解释 yield(self.get_tree().create_timer(1.5, false), \"timeout\") _ui.displayReady() _player.isControllable = true _countTimer.start() _spawnPowerup()# 进入下一关卡func _nextLevel(): _level += 1 _restartGame()# 玩家收集金币发出的信号处理func _on_Player_coin_collected(count): _ui.showScore(count) if count &gt;= _totalCoins: _countTimer.stop() _levelAudioPlayer.play() _nextLevel()# 玩家受到伤害，游戏结束信号处理func _on_Player_game_over(): _gameOver()# 玩家收集到能量币发出的信号处理func _on_Player_power_collected(buffer): _timeLeft += buffer _ui.showTime(_timeLeft)# 游戏时间超时，游戏结束func _on_Timer_timeout(): _timeLeft -= 1 _ui.showTime(_timeLeft) if _timeLeft &lt;= 0: _player.isControllable = false _gameOverAudioPlayer.play() _gameOver()# 能量币定时生产func _on_PowerTimer_timeout(): var power = powerScene.instance() var pos = _makeRandomPosition() power.position = pos self.add_child(power)# UI界面点击开始按钮触发开始信号func _on_UI_start_game(): _nextLevel()# 创建当前关卡的所有金币func _spawnCoins(): if coinScene == null: return var playerPos = _player.position var obstaclePos = _cactus.position for i in range(_totalCoins): var coin = coinScene.instance() var pos = _makeRandomPosition() # 如果金币产生位置在玩家或者障碍物内，则重新生成一个位置 while pos.distance_to(playerPos) &lt; minPlayerDist || pos.distance_to(obstaclePos) &lt; minObstacleDist: pos = _makeRandomPosition() coin.position = pos _coinContainer.add_child(coin)# 设置当前关卡的障碍物置func _spawnObstacles(): var index = randi() % _pointsCurve.get_point_count() var position = _pointsCurve.get_point_position(index) _cactus.position = position# 设置能量币出现的时间并计时func _spawnPowerup(): var powerTime = _makeRandomPowerAppearTime(_timeLeft) _powerTimer.wait_time = powerTime _powerTimer.start()# 根据当前关卡设计金币总数func _calculateTotal(level): return level + 5# 根据当前关卡设计超时时长func _calculateDuration(level): return level + 5# 当前时间下设计随机能量出现时间func _makeRandomPowerAppearTime(timeLeft): return rand_range(0, timeLeft)# 根据窗口尺寸设计随机金币位置func _makeRandomPosition(): var x = rand_range(0, ProjectSettings.get('display/window/size/width')) var y = rand_range(0, ProjectSettings.get('display/window/size/height')) return Vector2(x, y) 嗯，这代码有点长！当然，这是这个小游戏的核心代码部分了。 Game.gd 脚本把主场景中所有的子节点都相互关联在一起，让每个子场景相互配合，工作得有条不紊，另外它还会动态地创建一些其他的子节点，比如金币、能量币等。 代码中的主要逻辑在于处理游戏的开始、暂停、进入下一关卡以及结束等逻辑。对于每个关卡的元素合理设计，比如当前关卡的金币总数、超时时间、能量币的出现时机设计等，我没怎么用心，算法不是很合理，如果大家有兴趣，完全可以发挥自己的创造力丰富一下游戏的可玩性吧！嘿嘿。 其他需要注意的代码我在这里列出来： randomize() 这个方法只需调用一次就可以在每次游戏运行时产生真实的随机效果 for coin in _coinContainer.get_children(): 获取该节点的所有子节点（金币） self.get_tree().create_timer(1.5, false) 创建一个计时器，关键在 false 这个参数，表示场景暂停计时同步暂停 var position = _pointsCurve.get_point_position(index) 获取 Path2D 节点曲线上的某个点的位置值 关于 yield 关键字可以在上一篇文章中查看。最后运行游戏，进行测试吧！ 三、总结嗯，这个不好玩的小游戏总算完成了，总结一下我们的内容： 学习了一些新的 Godot 节点，以及一些新的关键词 探讨了一些基本的游戏开发规则，包括编写代码的规范 编写实现游戏中相关逻辑代码，完成我们第一个完整的小游戏 本次小项目以及相关的代码已经上传到 Github ，地址： https://github.com/spkingr/Godot-Demos ，原创不易，希望大家喜欢吧！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（中）","url":"/2018/12/05/introduction-of-godot-3-part-10-introduce-some-node-types-and-make-a-new-game-part-2/","text":"一、前言在上一篇文章中，我们一起学习探讨了几个常用的新节点，也顺便了解一下 GDScript 脚本中几个重要关键字的用法，最后总结了我个人认为比较实用的几个所谓“最佳实践”，写了这么多的目的就是为了本篇和下一篇服务的：我们使用 Godot 3.1 Alpha2 版本制作一个小游戏。 这个游戏非常简单，网上也有不少类似的案例，本来打算只需要上下两篇文章即可，后面发现加上代码后整篇文章显得“篇幅过长”，如果通过删减一些代码来缩短篇幅的话，对新手又很不友好，所以我再加一篇，分为“上-中-下”三篇吧。 温馨提示：中篇以及下篇内容中的代码会比较多，如果对这个游戏感兴趣，而且已经入门的话，我推荐直接到我的 Github 仓库下载源码运行查看即可，或者遇到了问题再来翻阅此文更合适。 主要内容：分析并制作一个完整的小游戏（中篇）阅读时间： 12 分钟永久链接： http://liuqingwen.me/2018/12/05/introduction-of-godot-3-part-10-introduce-some-node-types-and-make-a-new-game-part-2/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 了解学习游戏中的几个主要场景的制作 编写代码实现游戏中相关功能的逻辑 完整游戏项目的一个开发流程 主要的场景这是一个简单的“金币收集小游戏”，游戏设计的主要思路和玩法大致如下： 玩家可以在自由的世界里随处奔跑，遇到心爱的金币可以尽收囊中 玩家要避免被仙人掌刺伤，这也是游戏的唯一实体障碍物 每个关卡有超时时间设计，超时游戏结束，规定时间内收集完金币可进入下一关 每关随机冒出一个特殊“能量币”，玩家收集能量能够延长超时时间 嗯，时间紧迫，上车，赶紧出发！ 1. Player 玩家子场景玩家子场景是这个项目的最核心游戏元素，可以说是小游戏的灵魂所在。玩家子场景的制作非常简单：以碰撞体 Area2D 作为根节点，添加一个 Sprite 图片精灵、一个 CollisionShape2D 绘制碰撞区域、 AnimationPlayer 节点制作动画以及一个 AudioStreamPlayer 音频流播放节点。如果对这些节点的使用不熟悉，可以参考我之前的文章。 另外，因为我把玩家的动画图片制作成了一个 SpriteSheet 精灵图集，所以制作动画的时候需要注意图片的显示区域，玩家有三个动画状态，都比较简单，参考如下： 2. Coin/Cactus/Power 金币/障碍物/能量子场景我把这三个小场景放到一起讨论，原因是它们的结构非常简单且很相似，都是为游戏中的“玩家”服务。三个子场景的制作一目了然，功能单一，相互独立，这也符合我们的最佳实践原则之尽量保持场景的独立性。另外，在对游戏资源的管理中，我把这三个场景以及场景的相关资源（图片）放在了 Items 一个文件夹下。 需要注意的是：能量币场景中的 LifeTimer 时间节点表示金币在规定时间内会自动消失，而能量币的出现时间并不由自己控制，这里不要混淆了，后面在代码中会有介绍。 3. UI 界面元素控件子场景主要用于界面显示，主要有：金币数量、剩余时间、开始按钮、文字信息显示等。这里我使用了 MarginContainer 容器配合 HBoxContainer/VBoxContainer 来对界面元素进行排版。提醒新手朋友们：设置 MarginContainer 的边距需要在 Custom Constants 属性下进行设置。 另外 UI 子场景也用于接收玩家的键盘输入，控制游戏的一些基本逻辑：开始、暂停、重试等，这些我们都会在代码中具体实现。 4. 游戏主场景这是游戏中最重要的场景了，也是包含并协调多个子场景的根场景。游戏的主场景中可以手动添加其他的节点或者子场景，也可以通过代码添加任意多个子场景，比如金币。同时，主场景负责并处理每个子场景之间通信链接，作为一个总指挥让每个子场景各司其职，及时得到并处理各自的相关任务。 值得注意的是：我把障碍物场景（ Cactus ）作为子节点放在了 Path2D 路径节点之下，也就是图中的蓝色路径。场景中的 CoinContainer 为一个空节点，作为动态生成的金币节点的容器。 逻辑与代码在 Godot 中每一个节点都能添加代码，而且最多只能关联一个脚本，一般子场景的功能相对单一，我们优先考虑给子场景的根节点添加一个脚本，而其他节点可以视需求添加，需要说明的是：子场景中需要暴露出来的供其它场景调用的公开方法最好写在根节点的脚本代码中。 另外，实现游戏的相关功能以及逻辑代码并不是只有唯一的一种方式，你完全可以根据自己的需求、设计原则、游戏规则等来进行代码编写。 说明：这个小游戏的灵感和图片资源都来源于《 Godot Engine Game Development Projects 》这本书，我参考了它的代码，但是我的设计方式与之稍有不同，比如在处理玩家和金币碰撞的逻辑上有两种方式，是在 Player 玩家场景中检测碰撞并调用 Coin 的方法，还是在 Coin 金币场景中检测碰撞并调用 Player 的方法，此书的作者采用了前者，而我选择了后者。我的观点是：游戏元素为玩家服务，玩家不需要关心游戏世界里有哪些元素。当然，运行结果完全相同。 接下面我把游戏中的主要代码贴出来供大家参考阅读，如果遇到不懂的地方可以随时翻阅我之前的文章，或者直接在 Godot 编辑器中按 F4 搜索查看相关的 API 说明，相信配合我在脚本中的注释，看懂代码的具体逻辑没什么问题。 1. Player.gdPlayer.gd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384extends Area2D# signal groupsignal coin_collected(count) # 金币收集信号signal power_collected(buffer) # 能量币收集信号signal game_over() # 游戏结束信号# exportexport(int) var moveSpeed = 320export(AudioStream) var coinSound = nullexport(AudioStream) var hurtSound = nullexport(AudioStream) var powerSound = null# onreadyonready var _animationPlayer = $AnimationPlayeronready var _audioPlayer = $AudioStreamPlayeronready var _sprite = $Sprite# enum, constant# variablevar isControllable = true setget _setIsControllable # 是否允许玩家被控制var _coins = 0 # 当前关卡所收集金币的数量var _boundary = &#123;minX = 0, minY = 0, maxX = 0, maxY = 0&#125; # 移动范围# functionsfunc _ready(): var scale = _sprite.scale var rect = _sprite.get_rect() # 设置玩家能移动的上下左右最大范围 _boundary.minX = - rect.position.x * scale.x _boundary.minY = - rect.position.y * scale.y _boundary.maxX = ProjectSettings.get('display/window/size/width') - (rect.position.x + rect.size.x) * scale.x _boundary.maxY = ProjectSettings.get('display/window/size/height') - (rect.position.y + rect.size.y) * scale.yfunc _process(delta): # 根据玩家键盘输入设置玩家的移动方向和速度 var hDir = int(Input.is_action_pressed('right')) - int(Input.is_action_pressed('left')) var vDir = int(Input.is_action_pressed('down')) - int(Input.is_action_pressed('up')) var velocity = Vector2(hDir, vDir).normalized() self.position += velocity * moveSpeed * delta self.position.x = clamp(self.position.x, _boundary.minX, _boundary.maxX) self.position.y = clamp(self.position.y, _boundary.minY, _boundary.maxY) if hDir != 0: _sprite.flip_h = hDir &lt; 0 if hDir != 0 || vDir != 0: _animationPlayer.current_animation = 'run' else: _animationPlayer.current_animation = 'idle'# isControllable属性的set方法func _setIsControllable(value): if isControllable != value: isControllable = value self.set_process(isControllable) _animationPlayer.current_animation = 'idle' if ! isControllable else _animationPlayer.current_animation# 重新开始的方法，传递一个玩家初始位置func restart(pos): _coins = 0 self.position = pos# 收集金币方法，传递收集金币数量func collectCoin(num = 1): _coins += num _audioPlayer.stream = coinSound _audioPlayer.play() self.emit_signal('coin_collected', _coins)# 收集到能量调用的方法func collectPower(buffer): _audioPlayer.stream = powerSound _audioPlayer.play() self.emit_signal('power_collected', buffer)# 玩家受到伤害时用方法func hurt(): _animationPlayer.current_animation = 'hurt' _audioPlayer.stream = hurtSound _audioPlayer.play() self.set_process(false) self.emit_signal('game_over') 玩家场景的代码部分相对较多，在此我特意标明了我的源码编写习惯，一般保持良好的代码风格是有利于游戏的调试和功能的扩展的，代码中我习惯的编码顺序是： signal/group 信号、分组写代码文件最前 export 接着是显示在编辑器中可编辑的相关变量 onready 主要表示一些对场景中的节点的引用 enum/constant 枚举、常亮定义部分（无实际代码） variable 普通变量定义部分（公开的、私有的） functions 最后是方法函数定义部分（公开的、私有的） 关于函数部分也要注意一些小细节， GDScript 脚本中有公开方法和私有方法，这些方法的位置可以随意，只要自己看着舒服就可以啦。其中几个关键地方我简单解释下： self.set_process(false) 这个方法能暂停或开启 _process(delta) 方法的运行，部分类似暂停游戏 self.emit_signal(&#39;power_collected&#39;, buffer) 发射信号的方法，已经讨论过了，不过这里额外添加了一个参数 _audioPlayer.stream = xxx 玩家场景中只使用一个音频节点，通过设置不同的 stream 音频流可以播放不同的音效 其他部分请参考注释吧。 2. Coin.gdCoin.gd123456789101112131415161718extends Area2D# 玩家名字，根据玩家名字判断金币否被收集export var playerName = 'Player'# 障碍物名字，如果金币与障碍物重叠则重新生成export var obstacleName = 'Cactus'onready var _collisionShape = $CollisionShape2Dfunc _on_Coin_area_entered(area): # 判断碰撞体是否为玩家 if area.name == playerName &amp;&amp; area.has_method('collectCoin'): _collisionShape.disabled = true area.collectCoin() self.queue_free() # 如果是障碍物则删除该金币 elif area.name == obstacleName: self.queue_free() 金币节点非常简单，代码也很简洁，主要功能是：玩家收集后自动消失，同时调用玩家的收集函数 collectCoin() 。为防止调用出错，我在代码中对玩家是否有该方法做了判断。 3. Cactus.gdCactus.gd12345678extends Area2Dexport var playerName = 'Player'func _on_Cactus_area_entered(area): # 与玩家相撞，调用玩家的hurt方法 if area.name == playerName &amp;&amp; area.has_method('hurt'): area.hurt() 这是最简单的子场景了！游戏规则就是：玩家碰到障碍物（仙人掌）后，玩家收到伤害，游戏结束。逻辑代码可以参考 Player 场景的 hurt() 方法。 4. Power.gdPower.gd12345678910111213141516171819202122232425262728293031extends Area2Dexport var playerName = 'Player'export var power = 2 # 能量蕴藏的时间参数onready var _collisionShape = $CollisionShape2Donready var _sprite = $Spriteonready var _timer = $LifeTimeronready var _tween = $DisappearTween# 使用Tween节点实现放大到消失的动画func _startTween(): _tween.interpolate_property(_sprite, 'modulate', Color(1.0, 1.0, 1.0, 1.0), Color(1.0, 1.0, 1.0, 0.0), 0.25, Tween.TRANS_CUBIC, Tween.EASE_IN_OUT) _tween.interpolate_property(_sprite, 'scale', _sprite.scale, _sprite.scale * 4, 0.25, Tween.TRANS_CUBIC, Tween.EASE_IN_OUT) _tween.start()func _on_Power_area_entered(area): # 玩家收集到能量 if area.name == playerName &amp;&amp; area.has_method('collectPower'): _collisionShape.disabled = true area.collectPower(power) _timer.stop() _startTween()# 一定时间后能量币消失func _on_LiftTimer_timeout(): self.queue_free()# 动画结束后消失func _on_Tween_tween_completed(object, key): self.queue_free() 和金币、障碍物一样，也是一个很简单的子场景，不过我们使用了 Tween 节点，利用代码实现能量币的消失动画。关于 Tween 节点可以参考上一篇文章，对于方法中每个参数的定义可以直接查阅官方 API 文档。 其他部分其他部分的代码以及总结部分见下篇！未完待续…… 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（上）","url":"/2018/11/30/introduction-of-godot-3-part-10-introduce-some-node-types-and-make-a-new-game-part-1/","text":"一、前言时间飞快，我有一段时间没有发表博客了，这段时间并不忙，一方面我自己也在不断学习，另一方面暂时不知写哪方面的内容了，感觉 Godot 中一些基础的部分我都或多或少谈到了，所以我打算使用我们学习过的知识来做一个小游戏吧。 这个游戏非常简单，但是对于完全“门外汉”的初学者来时还算有一定难度，不过别急，我会把我制作这个小游戏的一些思路以及常用的技巧娓娓道来，而且源代码我于上周就已经上传到 Github 啦： https://github.com/spkingr/Godot-Demos ，另外这个游戏来源于一本书：《 Godot Engine Game Development Projects 》，官网也有这个 Demo(Coin Dash) 以及其他示例的代码，我的思路和代码和官方有点不同，也实现了一些其他功能比如游戏暂停、金币数量显示等，强烈建议大家去围观。 本文分上下两篇，第一篇，也就是在进入“金币”小游戏的开发制作讲解之前，我先把之前文章里没有遇到过的一些非常重要的节点介绍一下，还有一个提醒：最好的学习方法应该是先尝试一遍或者边思考边把代码浏览一下，然后再来看我的文章，这样效果会比较好。嗯，废话不多说，我们开始吧！ 主要内容：认识一些新的节点和代码学习阅读时间： 10 分钟永久链接： http://liuqingwen.me/2018/11/30/introduction-of-godot-3-part-10-introduce-some-node-types-and-make-a-new-game-part-1/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 学习使用一些新的 Godot 节点 最基本的游戏开发规则 编写代码的规范 Godot 中常用节点1. Timer 节点 看名字就知道这是一个“计时器”。在 Godot 中一切皆节点，所以看到这种纯功能性的节点不要觉得奇怪，同时，我们完全可以不使用节点，直接使用代码 Timer.new() 动态创建一个计时器也是没任何问题的；甚至我们完全可以通过设置变量，利用 _process(delta) 方法来计算时间，不过显然没有 Timer 节点来得方便简洁！ Timer 时间计时器节点的属性非常简单，根据需求可以设置其等待时间、重复计时以及是否自动开始，这些属性我们也可以在 GDScript 脚本中使用代码修改： wait_time ：等待时间，即计时时长，结束触发 timeout 信号 one_shot ：是否是一次性，如果是，只会触发一次 timeout 信号 autostart ：自动开始，载入场景后计时，也可以使用 start 方法手动开启 游戏中计时功能使用非常频繁，不过，有部分计时场合我们还可以使用 yield 关键字代替，这样会省去节点的创建和信号的连接等繁琐、重复代码，这是分使用场合的，后面我会详述。 2. Tween 节点 在游戏开发过程中，我们一般使用 AnimationPlayer 节点来实现移动、缩放、颜色渐变等动画效果，但实际上，在有些场景中我们可能会直接使用 AnimatedSprite 节点，再结合一系列图片来实现动画特效，这个时候由于图片的限制（比如我们只做了金币的闪耀图片，并没有做金币的消失图片），我们并不能添加实现其他普通动画，那是不是没有其他办法呢？——办法当然有，这就需要 Tween 节点的隆重登场了！ Tween 即渐进/过渡的意思，从一种状态在一定时间内变化到另一种状态，从而产生一种视觉动画。渐变节点使用非常简单方便，可以对一个物体的任意属性进行动画控制，当然，也可以同时处理多个动画对象。其主要方法有以下几个： repeat ：是否重复 start() ：开始渐变，结束后触发 tween_completed 信号 interpolate_property() ：设置进行动画的节点属性以及时长等，需要传递属性名称、开始结束值、时长等参数 这里最重要的方法是 interpolate_property() ，可以在 Godot 编辑器中按 F4 搜索 Tween 类进行查看。当然，和 Timer 节点一样，我们完全可以在代码中动态创建 Tween 对象。 3. Path2D 节点 Path2D 是一个路径节点，由很多位置点组成，这个路径可以是曲线，也可以是直线。实际上 Path2D 一般是与 PathFollow2D 配合使用，关于 Path2D 的使用，我推荐去看看官方的一个例子： Your first game 。 在我要讲解的这个小 Demo 中，我使用 Path2D 路径节点绘制了一些点来保存需要用到的位置，后续我会详述。 GDScript 几个重要关键字1. export(PackedScene)/export(AudioStream) 在之前的文章中我们使用过 export(int) var speed = 10 来定义一个可以在编辑器中修改设置的整数值，以表示速度，同样地，我们可以使用 export 关键字来定义可以在编辑器中编辑的其他类型变量，比如：子场景、音频流等。 export(AudioStream) 用于定义一个音频流变量， export(PackedScene) 用于定义一个子场景变量，想象一下，游戏中我们制作了 3 种不同颜色的金币，每个关卡使用的金币可能不一样，这里我们就可以在关卡中定义一个 PackedScene 变量，然后直接在编辑器中选择对应的金币进行设置就可以了，非常方便。有点抽象，不过在后面的游戏代码中我们会应用到。 2. preload(‘res://resource.tscn’) preload 方法可以在代码中动态加载场景、文字、图片、音频等资源，比如我们可以预加载制作好的金币子场景，然后在代码中实例化，生成多个金币节点并添加到舞台中，实现动态添加金币的效果。 preload 是一个常用方法，不过在这个游戏中我并没有使用到，暂时提一下，以后讲 Singleton 单例再详述吧。 3. ProjectSettings.get(‘display/window/size/width’) 在游戏创建的时候，我们都会对项目相关属性进行设置，比如游戏屏幕显示尺寸大小等，那么如何在代码中动态获取这些参数值呢？我们可以直接使用 ProjectSettings 这个单例，通过传入属性的路径，比如窗口大小的高度： display/window/size/height 即可获取相对应的配置值，这样能避免硬编码，即使修改了配置游戏依然能正常运行！ 4. rand_range/randomize/randi 很多游戏中都会大量使用随机值，比如金币数量随机、金币品类随机、出现时机随机等等，在 GDScript 脚本中使用随机同样非常简单直接，一个方法 randi() 即可生成一个随机整数，不过这个整数的范围很大，需要生成范围限制的随机数则可以用 rand_range() 方法，接收两个参数，一个最小值，一个最大值。 除了这两个方法，还有一个 randomize() 方法，这个方法有什么用呢？如果你在游戏中使用随机数，你会发现每次运行游戏，这个随机数都是相同的，这是因为生成随机数需要一个 seed 也就是名为种子的整数，因为种子并没有随机，所以根据这颗种子生成的随机数自然也就不会变化了，如何做到真正的随机呢？——在使用随机方法前，调用一下 randomize() 方法就可以啦！ 5. get_tree().paused 我在游戏中添加了暂停的功能，相信大部分游戏都有这个功能吧。在 Godot 中暂停功能非常容易实现！直接调用 get_tree().paused = true 这一行代码就可以了，是不是感觉非常轻松直接？哈哈，不过记住：一旦运行这行代码后，我们的游戏会完全处于暂停状态，也就是说不论游戏本身、还有输入、甚至弹出的 UI 界面等都一律等闲视之——后果就是你不能继续游戏了！ 当然，解决这个问题是非常简单的，我们只需要把那些不被默认暂停的元素（暂停状态下依然可用）的 Pause Mode 暂停模式设置由 inherit 属性改成 process 就可以了： 6. yield() 这可以算是 GDScript 脚本的一个高级功能，它和 Python 中的 yield 关键字如出一辙，如果你熟悉协程的概念，像 Unity C# 中的 StartCoroutine() 方法， Kotlin 中的 Coroutine 协程， Dart/JavaScript 语言中的 await/async 关键字，那么 yield 的工作原理是很好理解的。 对于新手来说，我觉得可以把协程简单地理解为：程序运行到该位置（ yield ），暂停挂起在当前位置，继续执行其他代码，当时机到来，回到刚才挂起的位置继续执行。 嗯，听起来有点玄乎，不过在代码中使用起来非常简洁，参考运行下面的代码吧： 123print('开始运行程序……')yield(get_tree().create_time(1.0), 'timeout') # 挂起 1 秒钟print('1秒钟后输出：结束运行。') 游戏开发的几个小 Tips几个实用的小技巧或者说开发规则，也是我自己在开发实践中、他人的书籍里、一些博客文章中学到的，总结的不多，不过对于初学者来说还是比较重要的，可以先按部就班，之后再发展处自己的风格思路吧！ 1. 文件夹的管理 在我之前的文章里，对于小项目我都没有做特殊的文件管理，但是当游戏项目越来越大的时候，我们需要引起足够的重视，因为这会影响开发速度、以及团队合作的效率。其实，你完全可以按照自己的风格去管理资源文件，但是更推荐官方的一些做法和建议： Project organization 12345678910111213/project.godot/docs/.gdignore/docs/learning.html/models/town/house/house.dae/models/town/house/window.png/models/town/house/door.png/characters/player/cubio.dae/characters/player/cubio.png/characters/enemies/goblin/goblin.dae/characters/enemies/goblin/goblin.png/characters/npcs/suzanne/suzanne.dae/characters/npcs/suzanne/suzanne.png/levels/riverdale/riverdale.scn 这里我简单地比较了 Unity 和 Godot 中文件管理的风格样式，我个人更倾向于 Godot 的文件组织方式，因为等会我还会讨论一条重要的开发原则：尽量保持每个子场景的独立性！ 2. 保持场景独立 嗯，我认为这是 Godot 中开发游戏最重要的一条原则了！它能明显地提升开发效率，提高团队合作，更利于 Debug 调试。因为 Godot 中一切基于场景，场景中可以包含多个子场景，子场景依然可以由多个其他子场景组成，而且每个子场景是可以单独运行的！打开子场景，按 F6 来单独运行、测试，及早发现问题，提高程序的健壮性。 如何保持场景独立？这就需要我们去仔细思考了，具有独立功能的部分我们都可以抽离出来作为一个单独的子场景，通用、具有类似功能的节点也可以抽离出来以继承关系实现，需要说明的是：独立并不意味着不与其他场景发生任何关系了，独立只是让它能单独运行，能单独测试一部分功能，这是很重要的。 3. 代码编写规范 代码构成了游戏的灵魂，代码编写不规范带来的直接后果就是： 自己看不懂，遇到 BUG 后越改越乱 团队里其他开发者看不懂，很难或者无法 DEBUG 不利于后续功能的开发、重构等 和文件组织管理方式一样，其实代码编写规范也会因人而异，在 Godot 中官方所推荐的方式如下： 1234567891011121314151617# 枚举、常量等变量命名enum State&#123;INIT, IDLE, PLAYING, DEAD&#125;const CONST_GRAVITY = 98# 普通变量、私有变量命名var player_sprite = 1var _walk_speed = 2# 私有方法命名func _private_method(): get_tree().paused = true pass# 公有方法命名func public_method(): _private_method() pass 注意，在 GDScript 中是没有 private/public/protected 等关键字来规范访问限制的，类似 Python ，这也正是我们需要保持一定的编码规范的原因之一。不过，你会发现我的命名方式会有所不同！我比较习惯 Java/C#/Dart 等语言的命名规则，采用驼峰式，同时利用 _ 下横线来标记私有变量或者方法，而且调用内部方法的时候我都会显式使用 self 关键字： 12345678910111213141516# 枚举、常量等变量命名enum State&#123;INIT, IDLE, PLAYING, DEAD&#125;const CONST_GRAVITY = 98var playerSprite = 1 # 公有变量var _walkSpeed = 2 # 私有变量# 私有方法命名func _privateMethod(): self.get_tree().paused = true pass# 公有方法命名func publicMethod(): _private_method() pass 至于选哪种，我觉得只要保持规范，符合个人或者团队共识就好啦！ 三、总结本篇文章算是一个经验小总结吧，也是为了更好地解释我们后面要出场的游戏项目，林林总总地列举了一些不成文的条条列列，不知道大家看后的感受是怎样的呢？ 嗯，有两周没有写文章了，因为最近有其他的事情和同学在忙乎，不过我一定会坚持下去的，还是那句话，原创非常不易，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"【翻译】TextClassification介绍（三）","url":"/2018/11/20/translation-of-textclassification-part-3/","text":"一、说明这是一个关于介绍 TextClassification API 的系列文章，总共分三篇，本文是最后一篇。上一篇在此：【翻译】TextClassification介绍（二） 原文作者：Mark Allison阅读时间： 5 分钟原文链接：https://blog.stylingandroid.com/textclassification-part-3/ 二、正文在 API 26 （奥利奥）中安卓引入了一个新的文字功能系统： TextClassification 。这个系统将会在 API 28 （ π ）中进一步改进完善。在本次简短的系列中，我们主要会探讨它是一个什么样的系统，如何使用它，以及如何为它添加一些自定义行为。 上一篇文章中我们开始研究自定义 TextClassifier 的实现，并研究了如何实现我们自己的“文本选择建议”。在本系列的最后一篇文章中，我们将会实现相应的 classifyText() 方法，并应用到我们自定义的 TextClassifier 文本分类器的实现中。 这里的 classifyText() 方法的实现实际上非常简单直接。我们检查选择的文本是否与请求中所选择的相匹配，如果相匹配则返回一个 TextClassification 的实例，这个我们稍后再详细了解。如果选择的文本与我们的正则表达式不匹配，那么我们会将结果进行回滚（也就是 TextClassifier 的默认实现）： StylingAndroidTextClassifier.kt12345678910111213141516171819202122override fun classifyText(request: TextClassification.Request): TextClassification &#123; //line 36 return if (regex.matches(request.subSequence())) &#123; factory.buildTextClassification( //line 38 request.subSequence().toString(), listOf(TextClassifier.TYPE_URL to 1.0f), listOf(factory.buildRemoteAction( context, R.drawable.ic_stylingandroid, stylingAndroid, contentDescription, stylingAndroidUri )) ) &#125; else &#123; fallback.classifyText(request) &#125;&#125;private fun TextClassification.Request.subSequence() = text.subSequence(startIndex, endIndex) 这里有一个 TextClassification.Request 的扩展函数，它返回文本中已选择的子文本 subSequence ，我们正是使用它来匹配正则表达式（第 36 行）。然后，我们构建一个 TextClassification 对象，它需要一些参数，包括匹配到的字符串（第 38 行），分类类型与其各自的可信度分数列表（第 39 行），以及一列 RemoteAction 实例对象，每个 RemoteAction 对象对应一个分类类型条目（第 39-45 行）。 这里的 buildRemoteAction() 方法返回每个 RemoteAction 实例： TextClassifierFactory.kt12345678910111213141516171819override fun buildRemoteAction( context: Context, drawableId: Int, title: String, contentDescription: String, uri: String): RemoteAction &#123; return RemoteAction( Icon.createWithResource(context, drawableId), title, contentDescription, PendingIntent.getActivity( context, 0, Intent(Intent.ACTION_VIEW, Uri.parse(uri)), 0 ) )&#125; 这里 RemoteAction 的构造函数需要四个参数：一个 Icon 对象，它将显示为操作按钮中的一部分；一个要显示的文字；一个表示可访问的内容描述；最后还需一个 PendingIntent 对象，它表示用户在点击操作按钮时将会执行的操作。在我们的示例代码中，我们使用了一个 Styling Android 标志图形作为图标，使用了 “Styling Android” 作为标题，以及简单的一些内容描述，再加一个能登录浏览器打开 URL 链接 “https://blog.stylingandroid.com&quot; 的 PendingIntent 对象。 buildTextClassification() 函数使用 TextClassification.Builder 实例来创建 TextClassification 对象： TextClassifierFactory.kt12345678910111213override fun buildTextClassification( text: String, entityTypes: List&lt;Pair&lt;String, Float&gt;&gt;, actions: List&lt;RemoteAction&gt;): TextClassification &#123; return TextClassification.Builder() .run &#123; setText(text) entityTypes.forEach &#123; setEntityType(it.first, it.second) &#125; actions.forEach &#123; addAction(it) &#125; build() &#125;&#125; 这里需要传递三个参数：匹配到的文本，一系列以类型及其对应的可信度范围作为 Pair 的列表，以及与每个类型/置信度组合所对应的 RemoteActions 列表。在这里示例中，这些参数分别是被选定的子字符串，包含一对 TextClassifier.TYPE_URL 及其可信度为 1.0f 组成的 Pair 的列表，以及一列包含我们刚刚说过的 RemoteAction 类单例的列表。 TextClassifier 已经完成了，剩下的事情就是将它连接到我们的 TextView 文本控件中： MainActivity.kt1234567891011121314151617181920212223242526272829class MainActivity : AppCompatActivity() &#123; private val emailText = \"dummy@email.com\" private val urlText = \"https://blog.stylingandroid.com\" private val hybridText = \"Email: $emailText\" private lateinit var textClassificationManager: TextClassificationManager override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) textClassificationManager = getSystemService(Context.TEXT_CLASSIFICATION_SERVICE) as TextClassificationManager classifier() text1.textClassifier = StylingAndroidTextClassifier(this, textClassificationManager.textClassifier) &#125; private fun classifier() = async(CommonPool) &#123; val textClassifier = textClassificationManager.textClassifier val emailClassification = textClassifier.classifyText(emailText, 0, emailText.length, LocaleList.getDefault()) println(emailClassification) val urlClassification = textClassifier.classifyText(urlText, 0, urlText.length, LocaleList.getDefault()) println(urlClassification) val suggestions = textClassifier.suggestSelection(hybridText, 10, 11, LocaleList.getDefault()) println(suggestions) &#125;&#125; 一行代码就可以实现我们要做的一切。我们创建了一个自定义 TextClassifier 对象，并将其作为参数传递给默认的 TextClassifier 对象的构造函数，并将 TextView 的 textClassifier 属性设置为我们的自定义实例。 我们目前得到的文本处理行为是：如果用户长时间按下的文字是无法识别的类型，那就只有简单的复制，粘贴和选择所有的选项功能；如果他们长时间按下系统默认的文本分类器所支持的任何类型，那么他们会得到我们在第一篇文章中所看到的所有相同的行为和动作；但是，如果他们长按 “Styling Android” 字符串（或者与正则表达式相匹配的类似字符串），那么将获得我们所自定义的“流行广告”操作，这个操作将启动浏览器并登录加载链接： https://blog.stylingandroid.com ： 在 TextClassifier 文本分类器中还有一个机制，用来识别具体的文本类型，然后使用文本生成链接，不过在本系列文章中我们不会去研究它，因为我们这里所看到的技术已经涵盖了 TextView 和 WebView 内置的一些主要功能。如果看到这里有人对此感兴趣，那么请告诉我，我将会单独写一篇文章作详细说明。 三、总结这篇文章的源代码可以在这里找到： https://github.com/StylingAndroid/TextClassification/tree/Part3。 © 2018 ， Mark Allison 。保留所有版权。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"android 翻译"},{"title":"【翻译】TextClassification介绍（二）","url":"/2018/11/15/translation-of-textclassification-part-2/","text":"一、说明这是一个关于介绍 TextClassification API 的系列文章，总共分三篇，本文是第二篇。上一篇在此：【翻译】TextClassification介绍（一） 原文作者：Mark Allison阅读时间： 3 分钟原文链接：https://blog.stylingandroid.com/textclassification-part-2/ 二、正文在 API 26 （奥利奥）中安卓引入了一个新的文字功能系统： TextClassification 。这个系统将会在 API 28 （ π ）中进一步改进完善。在本次简短的系列中，我们主要会探讨它是一个什么样的系统，如何使用它，以及如何为它添加一些自定义行为。 上一篇文章中我们研究了如何对文本进行分类的两个不同步骤：首先将选择的文本扩展为可能会被分类为具体类型的小段，接着执行该分类，并确定相关的操作。如果要编写我们自己的文本分类器，我们需要通过覆盖 TextClassifier 接口中相对应的方法来实现这两个步骤，这个接口也是我们将要实现的。两个方法 suggestSelection() 和 classifyText() 都具有两种形式，一种是带有独立的参数，另一种是带有包含所有这些参数的 Request 对象。覆盖 Request 类非常重要，因为另一个方法仅仅是一个简单的包装而已，它使用传递的各个参数构造出一个 Request 实例，然后在方法中调用该 Request 实例。因此，使用这种方式重写意味着我们不需要再做其他的形式了： StylingAndroidTextClassifier.kt123456789101112131415161718class StylingAndroidTextClassifier( private val context: Context, private val fallback: TextClassifier, private val factory: TextClassifierFactory = FrameworkFactory()) : TextClassifier by fallback &#123; private val stylingAndroid = \"Styling Android\" private val stylingAndroidUri = \"https://blog.stylingandroid.com\" private val regex = Regex(\"Styling\\\\s?Android\", RegexOption.IGNORE_CASE) override fun suggestSelection(request: TextSelection.Request): TextSelection &#123; return fallback.suggestSelection(request) &#125; override fun classifyText(request: TextClassification.Request): TextClassification &#123; return fallback.classifyText(request) &#125;&#125; 大部分方法都会被代理到一个名为 fallback 的 TextClassifier 实例，实际上这个实例就是默认的系统分类对象，因此如果我们所自定义的 TextClassifier 对象在检测文本匹配遇到失效时，那么我们将回滚到系统分类对象并得到其分类结果。我们仅需要覆盖两个方法来将执行自定义分类。 我们的自定义文本分类器 TextClassifier 将检测目标字符串 &quot;Styling Android&quot; 并创建一个自定义的操作，这个操作会在浏览器中打开 “https://blog.stylingandroid.com&quot; 网页链接，并附有一个自定义的标题和图标。让我们先来看看我们是如何覆盖 suggestSelection() 方法的。在第一篇文章中，我们研究了如何将用户选择的文本，扩展到包含当前选择的最小具体类型文段。我所选择使用的算法有点粗糙，并且很可能不是最高效的（特别是当文本很长的时候），但不管怎样还是能用：首先它从正则表达式 Styling\\sAndroid （非大小写敏感）开始搜索整个字符串，因此我们会找到类似 &quot;Styling Android&quot; ， &quot;styling android&quot; ， &quot;StylingAndroid&quot; 的结果，以及所有他们的组合案例；然后它会将每个匹配到的文本范围与当前的选择进行比较，如果当前选择的文本完全落在其中的某一个匹配的范围内，那么将选择扩展至该范围： StylingAndroidTextClassifier.kt123456789101112131415161718override fun suggestSelection(request: TextSelection.Request): TextSelection &#123; return findRangeOfMatch(request) ?: fallback.suggestSelection(request)&#125;//line 23private fun findRangeOfMatch(request: TextSelection.Request): TextSelection? &#123; //line 24 return regex.findAll(request.text) .firstOrNull &#123; it.range.contains(request.startIndex until request.endIndex) &#125; ?.range ?.let &#123; factory.buildTextSelection(it.start, it.endInclusive + 1, TextClassifier.TYPE_URL, 1.0f) &#125;&#125;private fun &lt;T : Comparable&lt;T&gt;&gt; ClosedRange&lt;T&gt;.contains(range: ClosedRange&lt;T&gt;) = contains(range.start) &amp;&amp; contains(range.endInclusive) 这里的 findRangeOfMatch() 方法处理了所有的逻辑，如果匹配失败则返回一个空值，因此 Elvis 运算符会在默认的系统文本分类 TextClassifier （第 17 行）上调用 suggestSelection() 方法，这样我们至少能尝试并获取系统所匹配它所支持的类型。 这个 factory 实例是一个对象工厂用于保持代码可以被测试使用，我之前已经介绍过，另外还有几个单元测试可以用来检查它是否按我们所期望的那样运行。 这里的 findRangeOfMatch() 方法首先会搜索字符串中符合正则表达式的所有实例（第 23 行）。这会返回一个 Sequence 对象，它包含所有匹配到的详细信息，我们使用 firstOrNull 方法来筛选出包含当前选择的第一个匹配项，如果没有则返回 null 空值（第 24 行）。最后两行使用工厂方法构造出 TextSelection 对象实例，不过前提是匹配到的包含当前选择的 MatchResult 对象为非空范围。这里的安全调用操作符确保了空值 null 的安全性，但是，如果没有找到有效的匹配项，那么整个方法将返回一个空值 null 。代码中的 contains 扩展方法是一个将整个搜索落入更大范围的便利功能，这个扩展也提高了代码的可读性。 在我们构造 TextSelection 对象时，我们提供了扩展范围的开始下标和结束下标，以及我们将要识别的文本的具体类型（在这里的情形下，我们使用 TextClassifier.TYPE_URL 常量表示其为一个 URL 链接），并传入 1.0f 为可信度得分，因为我们需要确保这是一个正确的匹配项。 在这个工厂方法的实现中使用了 textSelection.Builder 方法并加上这些参数来实现创建出一个 TextSelection 实例： TextClassifierFactory.kt12345678910override fun buildTextSelection( startIndex: Int, endIndex: Int, entityType: String, confidenceScore: Float): TextSelection &#123; return TextSelection.Builder(startIndex, endIndex) .setEntityType(entityType, confidenceScore) .build()&#125; 在接下来的文章里，我们需要实现 classifyText() 方法来执行文本分类，这个我会在本系列的最后一篇文章中详述。 三、总结这篇文章的源代码可以在这里找到： https://github.com/StylingAndroid/TextClassification/tree/Part2。 © 2018 ， Mark Allison 。保留所有版权。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"android 翻译"},{"title":"Godot3游戏引擎入门之九：创建UI界面并添加背景音乐","url":"/2018/11/09/introduction-of-godot-3-part-9-add-audio-effects-and-ui-elements/","text":"一、前言本文开篇必须提到两个值得高兴的消息： 有读者专门给我来信了，鼓励我坚持下去，有点受宠若惊，心里非常高兴，希望有更多读者，更多交流，有建议欢迎留言到我的微信公众号或者博客。 新预览版： Godot 3.1 Alpha2 已经发布，也就是第二个预览版了，修复了一些问题，距离 Godot 3.1 正式版的发布又近了一步！着实激动人心。 之前的文章里我已经申明过：我使用的是 Godot 3.1 预览版，如果要使用我所上传的 Github Demo 代码，那么务必到官网相应的版本哦！下面附上最新预览版下载地址： Godot 3.1 Alpha2 各版本以及模板 Template 下载地址： https://downloads.tuxfamily.org/godotengine/3.1/alpha2/ Windows 操作系统 64 位版本文件，我这里已经单独列出来： https://downloads.tuxfamily.org/godotengine/3.1/alpha2/Godot_v3.1-alpha2_win64.exe.zip Godot Engine 官方关于最新预览版的相关介绍： https://godotengine.org/article/dev-snapshot-godot-3-1-alpha-2 工欲善其事必先利其器，好了，继续我们的 Godot 入门系列。依然基于上一篇文章，本篇我会给大家熟悉的“金币收集者骑士”小 Demo 划上一个句号，几个简单必要的任务是：添加常见的 UI 界面；然后再加一点料——游戏的音乐效果。再浏览之前，请务必参考上一篇文章： Godot3 游戏引擎入门之八：添加可收集元素和子场景。 主要内容： 创建 UI 界面以及添加一些音效阅读时间： 8-10 分钟永久链接：http://liuqingwen.me/2018/11/09/introduction-of-godot-3-part-9-add-audio-effects-and-ui-elements/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 给游戏添加 UI 控件 创建独立的游戏主界面，使用按键切换游戏场景 添加一些背景音乐和其他效果 Godot中的分组在添加 UI 控件显示金币收集数量之前，我们需要思考三个小问题，这三个问题解决好了界面就非常简单了，接下来我们一个一个解决。第一个问题就是：如何判断游戏场景中的金币已经被收集？ 这个问题其实很好解决，在上一篇文章中我们已经在 AnimationPlayer 制作消失动画并结合代码实现的过程中已经解决了：使用 Signal 信号！金币在被采集的时刻，也就是玩家 Player 和金币 Coin （ Area2D ）发生碰撞的那一刻，节点会发出 body_entered 的信号，我们通过连接这个信号做出处理并切换了金币的消失动画，同样的道理，我们可以利用这个信号在游戏主场景中加以利用，在信号订阅函数中进行计数处理，但与之前不同的是： 信号处理场景不同：一个在金币子场景，一个在 Game 游戏主场景 信号处理数量不同：子场景中只有一个 Area2D 节点，主场景有很多个金币实例 信号处理方式不同：子场景中手动连接信号，主场景中我们要避免手动连接信号 因为这几点不同，我们引出了第二个问题：既然金币数量不确定，我们要避免手动连接信号，那么如何在代码中连接信号呢？这个问题非常简单，一句代码解决： coin.connect(&#39;body_entered&#39;, target, &#39;your_method&#39;) ，代码种 connect 方法第一个参数为信号名称，第二个为目标即订阅者，第三个为处理信号的函数。这和我们之前使用编辑器连接信号是一样的效果，同样的，我们可以使用 disconnect 方法取消信号的连接。 两个问题都解决了，那么我们的模板代码大概是这样的： 12345678910# 这里的self指当前节点$Coin1.connect('body_entered', self, '_on_Coin_collected')$Coin2.connect('body_entered', self, '_on_Coin_collected')$Coin3.connect('body_entered', self, '_on_Coin_collected')# ……# 碰撞处理函数func _on_Coin_collected(body): # 处理金币收集 pass 明显地这里引出了第三个问题：那么多金币，如何简便地、一次性地获取场景中所有金币呢？解决这个问题的核心在于使用 Godot 中的另一个重要概念： Group 分组！考虑一下分组的应用场景：游戏场景中有很多金币，他们同属于某个金币分组，我们通过 GDScrip 代码的某个方法，获取了这个分组的所有金币信息，然后使用一个循环就可以轻松解决上面的重复代码问题了。这就是 Group 的一个最简单的应用场景。理论结束，实践起来非常简单：在编辑器中创建分组，然后添加到金币子场景的节点即可！ 如上图，我们创建了一个 coin 分组，之后我们并不需要在游戏主场景中对每一个金币实例进行分组的添加工作，只需在金币子场景中直接给根节点 Coin 添加 coin 分组就可以了。 控件和字体设置接下来我们需要把金币收集数量显示到游戏场景中！也是第一次接触 Godot 中的 UI 控件吧，哈哈。在 Godot 中使用控件和节点没有任何区别。 Godot 中所有的控件都是继承于 Control 节点，我们只需要添加相应的 UI 节点就能在场景中显示，需要注意的是：控件的渲染和普通节点一样，后面的节点会覆盖前面节点的显示！在游戏中 UI 界面一般都会显示在主界面的最上层，那么我们添加控件的时候就需要把节点置为根节点 Game 的最后一个子节点。但是，这样做有个缺陷：一旦有新节点添加到游戏场景中，默认位置为最后，这就难免还要去修改 UI 元素。对于游戏开发者来说，时间就是金钱，那有没有办法让 UI 层忽略其他节点，一直显示在最顶层，达到一劳永逸的效果呢？那就有请“金钱节约者” CanvasLayer 隆重登场！ CanvasLayer 节点是一个特殊节点，它能确保渲染在最顶层，这正是我们所需要的。我们只要把所有控件节点设置为 CanvasLayer 层的子节点即可。说做就做，在主场景中添加一个 CanvasLayer 子节点，改名为 UI ，然后往它里面添加其他子节点：首先添加一个 HBoxContainer 控件节点，如同其名，这是一个内容水平排列的盒子容器；在该节点内部添加一个显示金币图片的控件 TextureRect 节点，以及一个计数文本标签节点： Label 控件。控件节点的属性设置如下： TextureRect 节点设置 texture 材质属性为金币图片 Label 节点更名为 Score ，修改 text 属性即文本内容为： Score: 0 HBoxContainer 容器节点的位置调整，在子菜单栏中点击 Layout 选择 Top Wide 即可 如上图，这里的 Layout 属性是所有容器节点具有的属性， Top Wide 即顶宽，占据视窗顶部位置并拉伸宽度到最大。不过，现在有一个问题就是：文本标签中 Score 中的文字太小了！作为程序员，第一反应肯定是去找字体大小属性设置即可，不过在 Godot 中控件的文字大小并不能直接设置，我们必须先提供字体资源然后在此基础上设置字体大小！ 这个字体资源就是 Custom Font 自定义字体，一般为 ttf 格式，准备好字体文件，点击 Label （ Score ） 标签，在 Custom Fonts 的 Font 属性标签下，选择 New DynamicFont 创建一个新的动态字体，点击新建的动态字体进入字体资源相关设置面板，把 ttf 格式的字体文件拖拽到面板的 Font Data 属性下，最后在属性面板里设置字体的大小，字体的轮廓、颜色等就可以了，操作稍微复杂，适应一下就好了。 注意：如上图，这里我把新建的字体资源保存成了单独的文件，该资源文件命名为 font.tres ，这些资源在后面可以重复利用，如果你不知道如何保存相关资源，可以翻一下我之前的文章。 添加代码金币分组已设置好， UI 界面也准备完毕，现在可以添加代码实现我们“梦寐以求”地计数功能了，哈哈。接下来，通过场景获取所有属于 coin 分组中的金币，然后把分组中的每个金币逐个连接到碰撞信号处理函数，最后在连接好的方法中实现计数功能，理论在前面已详述，在 Game 根节点代码基础上添加代码如下，可以参考我给的注释： 1234567891011121314151617181920212223# 省略代码……# 添加 UI 后的代码onready var scoreLabel = $UI/HBoxContainer/Scorevar score = 0 # 用于统计金币收集数量func _ready(): # 从场景数中获取所有属于coin分组的节点 var coins = self.get_tree().get_nodes_in_group('coin') for *Coin* in coins: # 手动连接信号，用connect方法，第三个参数为信号处理函数名 coin.connect('body_entered', self, '_on_Coin_collected')# 碰撞处理函数func _on_Coin_collected(body): score += 1 updateScore()# 更新UI界面func updateScore(): scoreLabel.text = 'Score: ' + str(score)# 省略代码…… 代码很简单，唯一值得注意的是 body_entered 信号处理函数需要传递一个参数。编写代码过程中如果遇到有任何问题，随时可以在 Godot 编辑器中按 F4 搜索查看相关说明。 一点点音效运行我们的游戏，左上角，终于知道自己口袋里有多少 Money 了吧？！不过好像还是缺少点什么？嗯，缺少点声音——金币收集后的音效。和很多其他游戏引擎一样，在 Godot 中添加普通的音效非常简单，准备好我们需要的音乐素材，一个节点即可搞定： AudioStreamPlayer ，注意，你会发现 Godot 中有其他两个节点： AudioStreamPlayer2D 和 AudioStreamPlayer3D ，它们分别应用于 2D 世界和 3D 世界中的音特，比如声音传播立体感、传输的距离感等，不过这里我们不需要。 我们给游戏添加两个音效，一个是金币收集后消失的音效，一个是游戏的背景音乐。 金币收集音效：在金币子场景中再添加一个节点 AudioStreamPlayer 作为音乐流载体，音效是在 disappear 消失动画开始播放后才同时进行，所以我们需要把音效添加到相应的动画轨道上。首先打开动画面板，选择我们已经创建好的消失动画，然后添加一个音频轨道： Audio Playback Track ，在弹出的界面中选择刚才添加的 AudioStreamPlayer 节点，然后把准备好的音乐资源文件直接拖拽到新建的音频轨道上即可！简单，方便，又不失强大。 游戏背景音乐：同样地，在游戏主场景中添加一个 AudioStreamPlayer 节点，然后设置节点的 stream 音频流属性，只需要把准备好的背景音乐直接拖拽过去即可！另外，可以适当调整一下音乐的音量，这里我把 Volume Db 音量的分贝设置为了 -20 降低了背景音乐的音量，比较合适。 最后，添加一行代码，让场景加载完后自动播放背景音乐： 1234567# 省略代码……onready var audioPlayer = $AudioStreamPlayerfunc _ready(): # 场景加载完毕后开启背景音乐 audioPlayer.play() # 省略代码…… 好了，运行游戏，收集几个金币，喝上几口凉茶，放松一下心情吧！骚年！ 创建主场景嗯，还没完！我们已经掌握了几个最基本的 UI 控件，在此基础上再把游戏打造的稍微完美一点。是时候介绍一波自己强大的游戏了！哈哈。和大部分游戏一样，我们给自己的 Demo 添加一个入口界面作为启动后的主界面，在这个界面的功能是突出显示游戏的名字，告诉玩家如何开始新的旅途，以及说明游戏体验是如何高大上，写明游戏的创作者有多牛逼……嗯，有点飘了，你继续，我来写。 这个界面并不复杂，两行文字即可，也恰如其分地体现了我们游戏的简陋，嘿嘿。首先新建一个子场景，因为主要是 UI 元素，使用Control节点作为根节点，改名为 StartMenu ，添加一个 CenterContainer 作为直接子节点，并在其下添加一个 VBoxContainer 垂直容器，容器内添加两个 Label 标签子节点。这几个节点的名字很好地解释了其功能： CenterContainer 是一个能把内容居中显示的容器， VBoxContainer 为一个内容垂直分布容器。这里我设置 CenterContainer 的 Layout 布局属性为 Full Rect 全屏显示，而两个文本标签都设置了 Align 对齐属性为 Center 居中，并写上几个“高大上”的文字。 给文本标签修改字体，这里我使用了之前保存的字体资源： font.tres 。不过，当我想在第二个标签中把字体放得更大、颜色更鲜艳、更突出表现的时候，你会发现一处修改，所有应用了该字体资源的文本标签都变了！为了标新立异，是不是又要重新创建一个独立的资源文件呢？别急，很显然， Godot 早已考虑到了这点，我们只需要让资源唯一化即可轻松达到目的！在标签属性面板中，选中我们的字体资源，然后打开属性面板上的选项，选择 Make Unique 就可以轻松搞定啦！ 最后，给主场景也添加一个背景音乐，和之前的节点设置稍微有差别的是，这里我给 AudioStreamPlayer 节点上勾选了 AutoPlay 属性，也就是自动播放而无需使用代码进行控制了。我们的游戏界面做完了，保存好，按下 F5 启动游戏运行，这时候游戏还是会自动进入骑士收集金币的界面，这不是我们想要的，我们需要从 StartMenu 场景开始，所以要对主场景进行修改，在 Project -&gt; Project Settings -&gt; Application -&gt; Run -&gt; Main Scene 中，选择创建好的主界面 StartMenu.tscn 即可修改主界面为我们创建的菜单界面， OK ，一切准备就绪！ 别忘了添加切换场景的代码，否则按 Enter 键或者空格键都不会有任何效果： 123456789extends Control# 游戏场景资源路径var gameScene = 'res://Game.tscn'func _input(event): if event.is_action_released('ui_accept'): # 当按下空格或者回车时切换场景到Game self.get_tree().change_scene(gameScene) 大功告成： 三、总结总算结束了——这个“高大上”且“及其无聊”的“骑士满地找钱”游戏，哈哈。不知道大家看完后感觉怎样？不管如何，我们还是来总结一下本次学习到的一些 Godot 中的新鲜知识点吧： 给游戏添加 UI 控件元素，使用 CanvasLayer 节点 创建独立的游戏主界面，使用按键切换游戏场景 添加背景音乐和其他声音效果及动画、代码控制 其他小知识点：分组、代码中信号连接、字体资源等 最后的最后，我所要提醒的是， Godot 所支持的音频文件包括 OGG 和 WAV 格式，前者一般用于背景音乐，后者用于短音效，而不支持 MP3 格式的音频，另外我们的游戏也缺少很多很多普通游戏应有的一些机制，比如结束、暂停机制，没有怪物敌人、粒子特效，无关卡设计，不支持多人游戏等等，当然，这完全有待我们将来的开发啦！尽情期待吧！ 本次代码已经上传到 Github ，还是那句话，原创非常不易，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之八：添加可收集元素和子场景","url":"/2018/11/02/introduction-of-godot-3-part-8-add-collectable-elements-and-sub-scenes/","text":"一、前言在前面的游戏地图基础上，我们已经实现了玩家的上下移动控制，也有了相应的碰撞体功能，一个小小的游戏世界已经打造好，不过对于一个完整的游戏来说还是缺少点什么，没有探索的乐趣就没有吸引力，因此，这也就是我们本篇要实现的目标——给游戏场景添加一些可爱的动画元素，比如金币，来供玩家探索吧！ 除此之外，我还会介绍 Godot 中两个非常重要的概念或者实用技巧：子场景的创建和 Godot 中信号的使用。和之前的文章一样，本篇也是基于上一篇文章： Godot3 游戏引擎入门之七：地图添加碰撞体制作封闭的游戏世界。 主要内容： 在游戏场景中添加互动元素阅读时间： 10 分钟永久链接： http://liuqingwen.me/2018/11/02/introduction-of-godot-3-part-8-add-collectable-elements-and-sub-scenes/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 创建子场景，实例化，并添加多个子场景 介绍 Area2D 节点的功能和应用 Godot 中的观察者模式实现：信号的使用 创建和使用包含函数调用的复杂动画 创建玩家子场景为什么需要子场景呢？这其实有点类似程序中的面向对象思想，如果你有使用 Unity 开发游戏的经验，那么你对 Unity 中深入人心的 Prefab 预制体概念肯定非常熟悉；同样地在 Apple 中开发 2D 游戏，使用 SpriteKit 也会创建很多的子场景： SKScene ，然后在主游戏中加以重复利用。 Godot 中也有类似的概念，想象一下，当你需要在场景中制作很多个功能类似的物体，比如多个相同的敌人，每个场景中数量还不一定一样，如果每个场景中都去单独制作一个个的敌人对象，那就显得非常地不优雅了，万一设计不合理，全部都需要修改呢？这个时候，你就可以把它制作成一个预制件，使用预制件来克隆多个敌人，当你需要修改某个功能的时候，你只需要修改这个预制件，那么所有的实例都能得到应用，方便高效，还能提高游戏性能。这就是 Godot 中所谓的 Sub-Scene 子场景概念了。 说的很多，实际上做起来很简单。首先，我又得做下比较了： Godot 中的子场景可比 Unity 中的预制体功能强大多了！子场景可以嵌套，可以覆盖，甚至还能单独运行，非常方便。其次，我们要了解到，什么情况下需要子场景：第一，独立的节点可以制作成子场景，方便开发、调试、合作；第二，重复利用的元素可以制作成子场景。最后，我们来使用子场景来改进一下我们当前的游戏结构。 在我们的游戏主场景中，玩家 Player 是一个五脏俱全的子节点，这里我们完全可以把它当做一个单独的场景进行开发利用，这样的好处在于可以单独修改 Player 节点，提高效率，而且当你有需求要在游戏的主场景中添加多个玩家的时候（这里不太可能，不过以后我们再谈多玩家局域网连线游戏），你会发现特别地方便！制作子场景一般有两种方式，这两种方式都非常简单，灵活采用。 我们先讲第一种方式：把场景中已有的节点转化为子场景。在我们的游戏主场景中，选择 Player 玩家节点，右键弹出菜单中，选择 Save Branch As Scene 即把该节点转化为场景，然后选择合适的位置，保存即可！现在 Player 节点变成了一个单独的子节点了，右边的 🎬 电影小标志说明该节点为一个子场景，你可以通过点击这个标志进入 Player 子场景进行编辑，非常简便、贴心。 前面说过，子场景类似预制体，可以进行克隆创建出多个子场景的实例，接下来我们就通过制作金币子场景对此进行讨论。 制作金币场景我们创建一些金币来丰富游戏的场景，供玩家探索发现。先构思一下金币在游戏世界中的表现：有一个金币，它闪耀在世界的某个角落，如果有幸被玩家拾取，将会播放一段动画，然后消失于人间！嗯，是时候把我们的想象力转化为实际操作了：我们来创建一个单独的金币子场景，包含有两个动画，一个是闪耀，另一个是消失动画，还要有碰撞反馈，最好能自我消失！ 这就是我要讲的第二种子场景制作方式，首先我们点击场景编辑器上方的 + 号按钮，创建一个单独的场景，选择什么节点作为金币场景根节点呢？这里我要介绍一个新的节点： Area2D 区域节点。为什么要使用 Area2D 节点而非普通的 Node2D 或者之前我们多次接触过的具有碰撞属性的 StaticBody2D/KinematicBody2D 节点呢？原因在此：我们只需要一个能检测碰撞，但不需要有任何物理反馈的节点。 Area2D 在此非常合适，它可以用来制作一个区域，检测玩家进出该区域，相比 PhysicsBody2D 下的物理碰撞属性节点，它没有质量、弹性等属性，所以性能更高，另外有了 Area2D 作为根节点，我们没必要使用 Node2D 节点了。 选择 Area2D 作为根节点，改名为 Coin ，然后添加碰撞区域节点和图片、动画节点，调整相应设置，按 Ctrl+S 保存为 Coin.tscn 场景资源，场景结果如下图： 接下来需要给金币制作动画，按照前面的分析，需要两个动画：一个是没有被收集时的闪耀状态，一个是被收集后立刻消失的动画。第一个动画 rotate 非常简单，对于第二个消失动画 disappear 则稍微复杂点，但是只要把动画思路弄清楚，然后分多个轨道单独进行设计，调整，做出好看的效果也就非常简单了，动画分多个轨道： 碰撞体禁用属性：玩家收集金币后碰撞体不再有效，启用 disabled 属性 金币位置属性：金币从下往上漂浮，即 position 位置属性 透明度属性：在颜色属性里让透明度变为 0 ，即 modulate 中的 alpha 值 缩放属性：再添加一个缩放动画，在位置变化过程中不断缩小，即 scale 的值 最后一个，金币需要回到第一帧，防止以某个侧面图片进行消失，设置 frame 为 0 即可 记得做动画过程中不断测试和调整播放时间。是不是感觉 Godot 中的 AnimationPlayer 简直是太强大了？嗯，甚至有点像 Adobe Animate （ Adobe Flash ）动画工具啦！最后，提醒一点：由于金币会在玩家碰撞后立刻进行消失动画，这个时候我们要保证玩家不会再和金币继续产生二次碰撞，所以一定要在消失动画的第一帧就禁用碰撞体，同时注意运行游戏之前别因误勾选而禁用了碰撞体，这点特别重要，如果不明白怎么回事，又发生了金币不能被正常收集，那么你可以参考我之前的文章，使用 Godot 的碰撞体调试功能测试一下吧！ 连接信号我们的场景已经准备完毕，现在需要添加一些操作来实现游戏的运行逻辑了。首先我们要做的是：当金币检测到与玩家有碰撞响应后立刻播放消失动画，表明已被收集。这个碰撞相当于一个触发器，而这个触发器在 Godot 中就是以 Signal 信号的方式传播出去的，我们收到信号之后立刻更改动画就可以了。那么，问题来了，这里涉及到一个非常重要的概念： Signal 信号，这又是什么鬼？别急，且听我慢慢解释。 编写过程序的朋友应该对程序设计模式中的观察者模式或多或少有所了解，观察者模式听上去很专业，高大上，实际上原理非常简单：有一个物体叫做事件源，也可叫被观察者，另外有一个物体叫订阅者，也叫观察者，或者事件侦听者，观察者订阅事件源的某个事件，当事件源发生了这个事件后，它并不需要知道谁订阅了它，只管把事件广播出去即可，然后那些订阅了这个事件的观察者们就能立刻侦听到这个事件，做出相应的处理，这就是所谓的观察者模式。 举个例子，想象一下有这么几个主角：某指挥中心、某急救中心和某狙击手。他们之间的关系和事件，如下： 狙击手作为被观察者，可随时发报 指挥中心作为观察者，时刻等待信号到来 急救中心同样订阅了狙击手的事件，作为观察者 狙击手发现敌人，发出信号：“大量敌人出现” 指挥中心收到信号，做出反应，立即派遣救援 急救中心并没有订阅这个事件，或者订阅了也不处理 狙击手被敌人干掉，发出信号：“ Help me! ” 急救中心订阅了该事件，马上行动，开始救援 这就是观察者模式，如果还不清楚的话，可以看下图： 理解了观察者模式，就理解了 Godot 中的信号，回到金币场景中，当 Area2D （ Coin ） 发生碰撞的时候，立刻发出“碰撞”信号，所有的“感兴趣的订阅者”收到这个信号后作出各自相应的处理，这个处理就是订阅者们的“某个函数”。在 Godot 中订阅事件或者信号叫 Connect 连接，信号发出后，连接了该信号的订阅者的相应函数会被调用，也就是成功处理了该事件，完成一个流程。如何使用 Signal 信号呢？原理简单，操作也不难： 按上图中的操作步骤：先给 Area2D （ Coin ）添加一个空脚本，然后点击发出信号的节点 Area2D （ Coin ），在 Node 面板的 Signals 下显示了 Area2D 节点的所有信号种类，这里我们选择 body_entered(PhysicsBody2D body) 也就是碰撞体进入信号，双击它或者单击右下方的 Connect… 按钮，在弹出框中选择接收该信号的订阅者（这里订阅者仍然是金币节点本身，自己处理自己发出的信号），设置处理信号的方法函数，注意 Make Function 默认开启，如果关闭了则需要在脚本中手动编写该函数！连接后我们打开脚本文件，可以看到 Godot 自动帮我们添加了一个方法，同时在 Area2D 的信号面板中也有了变化： body_entered(PhysicsBody2D body) 信号下有了新建方法的连接提示。啰嗦了点，图片能理解的朋友直接跳过吧！ 暂时丢下代码，我们转到主场景中添加我们制作好的金币子场景。在主场景中，点击 🔗 链接按钮，然后选择我们保存的金币场景资源 Coin.tscn 文件，即可实例化一个金币到主场景中，重复这个操作，多添加几个金币，放置到不同的位置，充分发挥你的想象吧！ 工作基本完成，第二种子场景制作方式也介绍了，信号的原理、使用、添加也了解清楚了，最后就是逻辑处理啦。 逻辑代码回到金币子场景，打开 GDScript 脚本，添加代码： 123456extends Area2Dfunc _on_Coin_body_entered(body): $AnimationPlayer.current_animation = 'disappear' # 打印文字到控制台，作为测试用 print('Coin collected!') 代码再简单不过！当金币被玩家收集后，也就是发生碰撞的时刻，金币发出信号，在代码中处理信号让金币消失——运行消失动画。运行游戏，测试！ 貌似一切 OK ，实际上这里潜伏了一个大问题：硬币被收集后虽然表面上看不见，但实际上并没从场景中消失！如果你开启碰撞体调试就能清楚地看到这个问题的存在，这可能会引起一个运行 Bug ：如果金币一直存在，游戏占用内存越来越多不能及时释放，以至于可能发生内存溢出而导致游戏崩溃！如何处理呢？会不会添加很多逻辑？哈哈，完全没必要，只需再添加一个简单的信号函数就可以轻松搞定！ 我们已经在上一节做到了金币收集这个动作，接下来要处理的事情是：当金币的消失动画运行到最后一帧，要把它从游戏中真正的移除！这有涉及到信号的处理，当 AnimationPlayer 播放到最后一帧的时候也会发出一个信号： animation_finished(String anim_name) 动画结束事件，和 Area2D 的碰撞事件类似，选择 AnimationPlayer 节点下的相应信号，把这个信号连接到金币根节点 Coin 上，在方法处理中把该金币从游戏场景中移除！ 12345678910extends Area2Dfunc _on_Coin_body_entered(body): $AnimationPlayer.current_animation = 'disappear' print('Coin collected!')func _on_AnimationPlayer_animation_finished(anim_name): if anim_name == 'disappear': # queue_free方法将出该节点 self.queue_free() 唯一要注意的地方在于代码中的一个判断条件： if anim_name == &#39;disappear&#39; ，这是因为其他动画播放结束的时候也会发出该信号，而我们只想在消失动画结束时候做相应处理。 大功告成，运行查看效果！ Bonus: 函数动画嗯，并没有结束，学无止境！我们再学习一个 Godot 中动画节点 AnimationPlayer 的新特性：函数调用关键帧！试想一下，如果我们可以在消失动画 disappear 的最后一帧自动调用金币根节点的 queue_free() 方法，那么不就可以实现场景中删除金币而无需连接信号、编写方法、处理逻辑了吗？ Godot 3.1 就是这么强大，如你所愿！ 首先，我们为了不重复处理同一个事件，我们需要取消动画播放结束的信号。只需要在已连接好的信号下方，点击 Disconnect 按钮取消关联即可。 其次，需要稍微修改消失动画。在动画面板中，插入一个新的轨道： Call Method Track 即方法调用轨道，然后选择目标为 Coin 根节点；创建轨道后，在动画的最后插入一个新的关键帧，弹出 Select Method 方法选择框；搜索 void queue_free() 方法，在 Node 类下，点击确定，完成方法关键帧！大致步骤如下图： OK ，总算结束了，高高兴兴地去全世界收集金币吧，骚年！ 三、总结本章文字偏多，内容并不多，主要介绍了 Godot 中的两个关键特性，希望大家能理解并应用到自己的小游戏中。本篇代码已经上传到 Github ，最后总结一下本次学习到的知识点： 创建子场景并实例化子场景 连接订阅事件信号，处理信号 学习使用 Godot 3.1 动画中的方法调用特性 其他： Area2D 节点简介，碰撞处理，多轨道动画设计 够啰嗦了，还是那句话，原创实属不易，希望大家喜欢！ PS: 图片有一个单词写错 disappear -> disapear ，已经在源代码中更改，注意注意。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"【翻译】TextClassification介绍（一）","url":"/2018/10/28/translation-of-textclassification-part-1/","text":"一、说明这是一个关于介绍 TextClassification API 的系列文章，总共分三篇，本文是第一篇。非常好的文章，翻译出来分享给大家。 原文作者：Mark Allison阅读时间： 5 分钟原文链接：https://blog.stylingandroid.com/textclassification-part-1/ 二、正文在 API 26 （奥利奥）中安卓引入了一个新的文字功能系统： TextClassification 。这个系统将会在 API 28 （ π ）中进一步改进完善。在本次简短的系列中，我们主要会探讨它是一个什么样的系统，如何使用它，以及如何为它添加一些自定义行为。 TextClassification 相当于一种机制，系统通过这种机制可以识别出特定类型的文本，并在用户选择到该文本的时候添加一些适当的操作。常见的文本类型有电话号码，电子邮件地址和 URL 链接，这些特定文本会分别触发启动系统拨号程序，电子邮件客户端和 Web 网页浏览器的操作。所有这些特性属于 TextClassification 的默认服务，并且已内置于 Android 系统，因此，我们要做的第一件事就是先来弄清楚这种服务的工作原理。 我们可以通过适当的系统服务来获取系统默认的 TextClassificationManager ： MainActivity.kt12textClassificationManager = getSystemService(Context.TEXT_CLASSIFICATION_SERVICE) as TextClassificationManager 值得注意的是，当手动执行文本类型检索处理的时候，记住这个操作在计算上是比较耗时的，原因是系统默认的 TextClassifier 服务使用了机器学习模型进行文本分类操作的。出于这个原因，我把这些函数调用包装在了一个使用 CommonPool 作为上下文的异步协程中，这样它能高效地运行在后台线程上： MainActivity.kt1234567891011121314151617181920class MainActivity : AppCompatActivity() &#123; private val emailText = \"dummy@email.com\" private val urlText = \"https://blog.stylingandroid.com\" private val hybridText = \"Email: $emailText\" private lateinit var textClassificationManager: TextClassificationManager override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) classifier() &#125; private fun classifier() = async(CommonPool) &#123; textClassificationManager = getSystemService(Context.TEXT_CLASSIFICATION_SERVICE) as TextClassificationManager //... &#125;&#125; 文本分类检索服务由两个基本操作组成。首先是分类检索本身。所以我们先传递一个字符串，这个字符串包含了我们所需要分类的文本信息，还需要传递所选子字符串的开始和结束位置，以及一个区域列表。前三个参数意思很明显，最后一个参数需要稍微解释一下。之前我提到过，系统默认的 TextClassifier 使用的是 ML 机器学习模型来执行文本分类的，但实际上根据不同的语言和区域设置会存在多个模型，因此我们需要指定我们所感兴趣的区域，以让它应用正确的模型。当然，我们有必要保持这个列表尽可能的小，因为使用多个 ML 模型进行分析会快速地增加计算开销。 要运行电子邮件地址文本分类，我们首先需要从 TextClassificationManager 中获取 TextClassifier 对象实例，并调用它的 classifyText() 方法： MainActivity.kt123val textClassifier = textClassificationManager.textClassifierval emailClassification = textClassifier.classifyText(emailText, 0, emailText.length, LocaleList.getDefault())println(emailClassification) 运行代码返回的 TextClassification 实例如下： 123456TextClassification &#123;text=dummy@email.com, entities=&#123;email=1.0&#125;, actions=[android.app.RemoteAction@4e67771, android.app.RemoteAction@eb7956], id=androidtc|en_v6|754483982 &#125; 我们可以看到，运行后它将文本标识为一个可行度为 1.0 的电子邮件地址（可信度取值范围为 0.0-1.0 ，因此这是一个百分百确定匹配）。尽管在我们人眼看来，这显然是一个虚假的电子邮件地址，但它仍然符合有效邮件地址的标准。 我们可以使用同样的 TextClassifier 实例执行另一个分类，这次使用一个包含 URL 链接的字符串： MainActivity.kt12val urlClassification = textClassifier.classifyText(urlText, 0, urlText.length, LocaleList.getDefault())println(urlClassification) 这次生成的 TextClassification 将其标识为一个 URL 地址： 12345TextClassification &#123;text=https://blog.stylingandroid.com, entities=&#123;url=1.0&#125;, actions=[android.app.RemoteAction@33dd4e2], id=androidtc|en_v6|-1332134748 &#125; 除了能识别特定文本类型的文字之外， TextClassification 还包含零个或多个对已识别类型的处理操作。这些方法操作封装在一个包含 PendingIntent 对象的 RemoteAction 对象中。我们可以调用 RemoteAction 对象，并触发一个载有文本对象的 PendingIntent 对象。当我们检测到一个电子邮件地址时，将会返回该 RemoteAction 并触发一个 PendingIntent 对象以启动邮件客户端，撰写发送给此邮件地址的信件。同样地，返回 URL 链接的同时会启动 Web 浏览器以查看此链接。我们将在本系列的后面部分详细探讨 RemoteActions 。 这里有一件非常重要的事情需要注意的是，当我们调用 classifyText() 方法时， start 和 end 的值必须精确地包含有给定类型的子字符串内容。也就是说，如果我们使用字符串 &quot;Email：dummy@email.com&quot; 作为分析内容，那么对整个字符串进行文本分类的时候，将不会得到一个电子邮件类型的字符串，而是一个“其他”类型的字符串。只有当我们传入合理的、能正确划定 &quot;dummy@email.com&quot; 子字符串在原字符串中的开始和结束位置时，它才能正确的处理并标识出一个电子邮件地址。 这就引出了一个问题：我们如何划分出正确分类类型的子字符串的开始和结束下标？这就需要 TextClassifier 的其他操作了。 proferenceSelection() 方法能标识出一个可以划分为某具体类型的子字符串，但它的工作方式与我们所想象到的稍微不同。如果我们看一下之前例子中的字符串 &quot;Email：dummy_email@address.com&quot; ，我们可能会想到，如果我们传入整个字符串那么它将识别出正确类型的子字符串，但这并不是它的运作方式。它实际上是从一个给定的不确定类型的子字符串的范围开始，一直增长到一个具体类型的较大的子字符串范围，而不是从整个字符串范围缩小到较小的子字符串。这里的用例是当用户长按 TextView 文本控件时，最初始的选择是单个字符，接着 TextClassifier 可以扩展选择范围。在专业术语中，这意味着如果用户长时间按住的是一个包含电子邮件地址的长字符串，那么初始选择将是非常小的，然后会扩展到整个电子邮件地址。 我们可以通过调用 suggestSelection() 方法来查看并实现这个行为，方法的参数与 classifyText() 方法参数一样。在这种情况下，开始和结束位置仅划分出一个单字符，该字符出现在字符串的电子邮件地址子字符串中： MainActivity.kt12val suggestions = textClassifier.suggestSelection(hybridText, 10, 11, LocaleList.getDefault())println(suggestions) 这会返回一个 TextSelection 对象实例，该实例包含子字符串的开头和结尾下标位置，这个位置包含了检测到的电子邮件地址，另外，还包含了文本类型和可信度分数： 123456TextSelection &#123; id=androidtc|en_v6|-456509634, startIndex=7, endIndex=22, entities=&#123;email=1.0&#125;&#125; 我们现在可以使用这里的开始和结束位置值来调用 classifyText() 方法了，但在实际应用中我们没必要这么做。应用 TextClassifier 的两个主要用例是 TextView 和 WebView ，但实际上它们都已经在使用它了。在这里，我们可以查看在允许选择的 TextView 控件中按下电子邮件地址或者 URL 链接的时候，扩展到正确的选择位置需要多长的时间，同时还会看到一个弹出窗口，该弹出窗口用于执行所选特定文本类型的相关操作。在这里的情况下，调用它会在 Chrome 浏览器中打开相应的 URL 网址： 我真的还想不出会在何种情况下你想要直接来调用使用 TextClassifier 对象，除非你有一个自定义的 View 用来选择一个文本块，而该 View 既不继承于 TextView 也不是 WebView 。如果有这种情况，那么请接受我的慰问吧。 你现在可能会认为我是在浪费你的时间，用来读这篇文章，但我向你保证我并没有。虽然实际上很少有 Android 开发人员调用这些 API ，但实现自定义分类器确是另一回事，很好地理解熟悉 TextClassifier 的工作原理是实现自己需求的基本条件。 在本系列的下一篇文章中，我们将一起探讨如何做到这一点。 三、总结这篇文章的源代码可以在这里找到： https://github.com/StylingAndroid/TextClassification/tree/Part1。 © 2018 ， Mark Allison 。保留所有版权。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"android 翻译"},{"title":"分享一个精致实用的HEXO博客小插件：日历云","url":"/2018/10/26/share-a-cute-hexo-blog-plugin-the-cloud-calendar/","text":"一、前言最近更新文章的频率比以前高了，在翻阅之前文章的时候发现我的博客页面有一个缺陷：不能快速浏览或者查看与日期相关的文章数据！我的博客主题使用已接近两年，整体来说还是偏于简洁实用型，基本上没有什么其他扩展功能，既然在官方网站没找到合适的插件，也不会自己打造一个插件，就一直保持了下来，现在用起来不便，才到网上搜索查找与日历相关的插件，还真发现了一个精致实用的日历云小插件，捣鼓了一番，用上后感觉非常实用，所以晾出来分享给大家，有需要的朋友可以拿去。 另外，如果你还没有创建博客，推荐使用 Hexo 搭建；如果刚创建博客，还在搜寻可用插件，那么可以参考我之前的两篇文章： 「Hexo On Win10」新手搭建博客过程 分享几个实用的HEXO博客功能插件 Hexo 博客主题非常丰富，根据不同的主题，相应的插件安装和配置都会有稍许差别，我的博客主题是： Phantom Blog Hexo ，并不支持 Widget 功能，如果你是以下两款主题，可以参考原文作者文章： Hexo-theme-light_cn 主题，那么可以直接参考这篇文章： Hexo 主题中添加日历云功能，文章解说非常详细，按步照班即可。 Landscape-F 主题，你可以参考这篇文章： Hexo 日历插件 ，博主正是插件的作者：净土。 其他主题，没有日历功能的，可以参考我的方法，在上面两篇文章的基础上加以修改，快速打造一款好用的精美日历云插件，请继续往下看。 二、正文安装过程稍许繁杂，大致需要完成以下几个步骤： 插件的安装，使用插件生成数据文件 插件的安装位置，即页面显示位置，由你来决定 插件的表现形式，也就是 CSS 样式，自由修改 准备几个代码文件，已备好下载链接：日历云相关文件，解压后复制到相应位置： calendar.ejs 为 HTML 脚本，放在博客主题的布局文件夹下： [blog_root]/themes/[your_theme]/laout/_widget/calendar.ejs ，我的主题没有 _widget 文件夹的，手动创建即可。 calendar.js 和 languages.js 脚本文件，我直接放在了主题的 js 文件夹下： [blog_root]/themes/[your_theme]/source/js/calendar.js ，两个文件一样，用于动态生成日历 HTML 代码。 calendar.css 为日历的样式文件，我放在 [blog_root]/themes/[your_theme]/source/css/calendar.css 目录下，如果你使用的是 styl 格式的样式文件，你也可以转化为 CSS 文件或者参考上面提到的博主的文章。 1. 安装插件和其他插件安装一样，首先需要安装 Calendar 日历插件 hexo-generator-calendar 的渲染源文件，在博客根目录下运行如下命令： 1cnpm install git://github.com/howiefh/hexo-generator-calendar.git --save 插件安装好之后，如果你使用 hexo g 重新生成博客代码同时，会产生一个 calendar.json 文件在博客的根目录，这也是最重要的数据文件，保存了你的所有文章的标题、链接、日期等信息，内容格式大致如下： calendar.json1234567&#123;\"2018-10\":[ &#123;\"title\":\"Godot3游戏引擎入门之六：制作TileMap瓦片地图\",\"date\":\"2018-10-19T12:16:24.000Z\",\"link\":\"/2018/10/19/introduction-of-godot-3-part-6-make-tile-map-in-godot/\"&#125;, &#123;\"title\":\"Godot3游戏引擎入门之七：地图添加碰撞体制作封闭的游戏世界\",\"date\":\"2018-10-22T12:23:17.000Z\",\"link\":\"/2018/10/22/introduction-of-godot-3-part-7-add-collision-and-move-player-in-map/\"&#125; ],\"...\":[\"...\"],\"...\":[\"...\"]&#125; PS: 这里有一个小 BUG ，如果你的博客配置了根目录 root 属性值，也就是说你的博客内容并不是放在服务器根目录，而是某个文件夹，那么 Calendar 插件生成的 JSON 数据文件中的链接 link 将全部无效，这时候需要手动 Hack 一下插件的源代码，当然你的配置是默认值 root: / 可以直接跳过。 以我的博客为例，我在全局配置文件 _config.yml 中配置了博客根目录： root: / 所以内容放在服务器下名为 / 的文件夹下，因此日历上的链接路径也应该加上 / 才能正常跳转，打开安装的插件源码，位置为： [blog_root]/node_modules/_hexo-generator-calendar@0.0.1@hexo-generator-calendar/lib/generator.js 修改代码如下注释部分： generator.js123456789101112131415161718192021222324module.exports = function(locals) &#123; var rootConfig = this.config; // 添加部分 //省略代码…… var posts = locals.posts.sort('date').filter(function(post) &#123; return post.published; &#125;).map(function(post) &#123; return &#123; title: post.title, date: post.date, // 修改链接生成代码 link: rootConfig.root + post.path // 添加博客根目录 &#125;; &#125;).reduce(function(prev, cur, index, array) &#123; var key = generateKey(cur.date); if (!prev.hasOwnProperty(key)) &#123; prev[key] = []; &#125; prev[key].push(cur); return prev; &#125;, &#123;&#125;); //省略代码…… 2. 添加JS代码插件和文件都安装配置好之后，需要添加一段 js 代码，用于渲染页面，在 [blog_root]/themes/[your_theme]/layout/_partial/after_footer.ejs 文件中，添加如下代码： 1234567891011121314151617181920&lt;!-- Calendar --&gt;&lt;% if (config.calendar)&#123; %&gt; &lt;script src=\"&lt;%- config.root %&gt;js/calendar.js\"&gt;&lt;/script&gt; &lt;script src=\"&lt;%- config.root %&gt;js/languages.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function() &#123; $('#calendar').aCalendar( '&lt;%= theme.calendar.language || config.language %&gt;', &#123;single:&lt;%= config.calendar.single %&gt;, root:'&lt;%= config.calendar.root %&gt;'&#125; ); // 下面的代码用于页面测试，可以不添加 &lt;% if(config.calendar.sample_id)&#123; %&gt; $('#&lt;%= config.calendar.sample_id %&gt;').aCalendar( '&lt;%= theme.calendar.language || config.language %&gt;', &#123;single:&lt;%= config.calendar.single %&gt;, root:'&lt;%= config.calendar.root %&gt;'&#125; ); &lt;% &#125; %&gt; &#125;); &lt;/script&gt;&lt;% &#125; %&gt; PS: 这里又遇到一个坑，我发现原版 JS 代码并不能正常解析我在主题目录下的配置文件中的相关参数，所以在这里我删除了与配置相关的代码： theme.config.calendar.options ，忽略相关配置参数，然后在 calendar.js 中修改代码如下： calendar.js123456789101112131415//省略代码……$.fn.aCalendar.defaults = &#123; months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], dayOfWeekShort: ['S', 'M', 'T', 'W', 'T', 'F', 'S'], dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], postsMonthTip: 'Posts published in LMM yyyy', titleFormat: 'yyyy LMM', titleLinkFormat: '/archives/yyyy/MM/', //这里我添加了我的博客根目录 blog headArrows: &#123;previous: '&lt;span class=\"cal-prev\"&gt;&lt;/span&gt;', next: '&lt;span class=\"cal-next\"&gt;&lt;/span&gt;'&#125;, footArrows: &#123;previous: '« ', next: ' »'&#125;, weekOffset: 0, single: true, root: '/calendar/', url: '/calendar.json' //这里我添加了我的博客根目录 blog&#125;; 特别注意代码中的两行注释，因为我的博客根目录 root 是在服务器的 / 文件夹下，所以添加了相应的路径，这和博客根目录下的配置文件 _config.yml 相符，可以参考一下我的部分配置： 1234567# URL## If your site is put in a subdirectory, ## set url as 'http://yoursite.com/child' and root as '/child/'url: http://liuqingwen.me/blogroot: /permalink: :year/:month/:day/:title/permalink_defaults: 3. 相关配置首先在博客根目录下的配置文件 _config.yml 中添加配置参数： 12345# Calendarcalendar: single: true root: calendar/ # only used when single=false sample_id: calendar-sample # only for samples in page content 这里最后一个参数 sample_id 是我自己添加的，用于渲染日历插件在某些特定页面上，可以做测试和展示，可以不用添加。 然后在主题根目录下的配置文件 [blog_root]/themes/[your_theme]/_config.yml 中添加配置参数： 12345# Calendarcalendar: language: zh-CN options: # 参数忽略 可以看到，因为我修改了 calendar.js 中的代码，这里的 options 参数配置直接忽略了。 4. 展示位置基本工作都完成了，最后一步就是日历云的页面摆放位置了。这里你可以自由发挥，找到相应位置的源代码添加日历云插件即可！ 以我的博客为例，我选择在菜单栏中显示日历最佳，所以找到博客主题的 .../layout/_partial/menu/ejs 菜单栏文件，添加日历云控件代码： 123456789&lt;!-- Menu --&gt;&lt;nav id=\"menu\"&gt; &lt;!-- 原代码，省略…… --&gt; &lt;!-- 增加日历代码 --&gt; &lt;div id=\"widget-calender-xxx\"&gt; &lt;%- partial('_widget/' + \"calendar\") %&gt; &lt;/div&gt;&lt;/nav&gt; 好了，工作全部完成，直接使用 hexo s 启动并查看效果吧！ Calendar Sample 最后，记得修改样式文件 calendar.css ，打造一款完全属于你自己的日历云样式哦！ 三、总结实用！精致！简单！当然，有几个小 BUG 还是需要手动 Hack 一下的，如果有朋友愿意修改一下源代码并提交 PR 更新插件，请告知，非常感谢！ Hexo 中的日历云插件，安装和分享，希望大家喜欢！最后附上文中提到的主要的源文件，下载链接：日历云相关文件。 参考： Hexo 主题中添加日历云功能： https://www.jianshu.com/p/b9665a8e8282 Hexo 日历插件： http://howiefh.github.io/2016/04/29/hexo-s-calendar-plugin/我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"hexo"},{"title":"Godot3游戏引擎入门之七：地图添加碰撞体制作封闭的游戏世界","url":"/2018/10/22/introduction-of-godot-3-part-7-add-collision-and-move-player-in-map/","text":"一、前言在前面的文章中，我分别介绍了如何上下左右移动玩家，以及使用瓦片集制作丰富的游戏地图，现在，是时候结合在一起，制作一个简单的游戏世界了，这个游戏世界既有丰富的场景元素，也有合理的碰撞检测，玩家可以在封闭的世界里自由移动。 Godot3游戏引擎入门之五：上下左右移动动画（下）Godot3游戏引擎入门之六：制作TileMap瓦片地图 上面的第一篇文章中，其实我们已经实现了一个简单的封闭世界，我们是这样实现碰撞检测的：给场景中的墙壁添加静态碰撞体，给玩家节点添加 RigidBody2D 刚体属性，我们在代码中设置玩家的线速度，而大部分物理属性由 Godot 引擎帮我们实现了。在第二篇文章中，我们又通过学习 TileSet 和 TileMap 可以在游戏中制作出复杂的场景，但问题是：地图上还缺少碰撞体，无法和玩家进行交互。 所以，这篇文章要解决上面两个小问题：第一，使用 KinematicBody2D 节点作为玩家对象，这样我们能自由控制物理反馈，实现相关的游戏功能；第二，我们需要给地图添加更多的真实的碰撞体，比如墙壁、障碍物等。这也是我们游戏开发的正常流程。 主要内容： 给 TileMap 地图添加碰撞体并测试阅读时间： 4-6 分钟永久链接：http://liuqingwen.me/2018/10/22/introduction-of-godot-3-part-7-add-collision-and-move-player-in-map/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 给地图中的瓦片添加碰撞体 玩家添加碰撞体，在地图中移动测试 学习几个实用的脚本函数 添加碰撞体在上篇文章的基础上，我们需要给每一个瓦片添加上碰撞体，这个操作很简单，直接添加具有碰撞体功能的节点即可。在 Godot 3.1 新版本中，设置步骤稍微繁琐，但是效果更加直观，效率也会更高。两种方式我们都了解一下，具体操作方式可以根据你的 Godot 版本而定。 3.0 版本 首先打开我们之前保存过的用于创建 TileSet 资源的游戏场景文件（ Tileset_Sprites.tscn 和 Tileset_SpriteSheet.tscn ），然后直接给每一个节点添加碰撞体。场景中的 Sprite 节点最终都会转化为 Tile 瓦片，要给每个瓦片添加碰撞体，只需要在每个 Sprite 节点下添加一个 StaticBody2D 静态碰撞体作为子节点，然后给静态碰撞体添加 CollisionShape2D 节点并设置碰撞体形状即可。 这些都在前面的文章里已经详细介绍过了，不过要特别注意的是：给所有 Sprite 节点都添加了碰撞体后，必须重新保存以覆盖之前的 TileSet 资源，才能把碰撞体更新到地图中，否则设置了碰撞体也不会有效果。文章后面我会介绍 Godot 中强大的 Debug 功能对碰撞体进行可视化测试，避免意外情况。 3.1 版本 Godot 3.1 新版本关于 TileMap 的一些新特性上一篇文章已经介绍过了，基本流程类似：划分 Region 区域 -&gt; 标记 Bitmask 掩码 -&gt; 添加 Collision 碰撞体区域。新版本不需要添加任何子节点，直接在相应的瓦片上绘制碰撞体形状即可。如下图，相关参数上一篇文章已经介绍过了： 注：黄色代表已绘制的碰撞体，蓝色代表正在绘制的碰撞体。操作提示：如果不方便设置自动吸附的参数，那么在绘制碰撞体形状的时候会出现很难精确点位的问题，这个时候我们可以取消吸附，选择粗略绘制完的碰撞体，点击 Points 属性值，对每一个点进行手动修改调整即可。 一般我们给墙壁和不可穿越物体设置碰撞体即可。设置完每一个瓦片集的碰撞体形状后，地图上就会出现相应的静态碰撞体了，新版本操作起来非常简单快捷！ 添加主角游戏世界里怎么能缺少玩家呢？老生常谈的话题，前面的文章已经多次介绍如何制作完整的 Player 玩家节点了，这里我们的地图是支持 Player 上下左右移动的，实现起来也不难，具体请参考上一篇文章的详细介绍：Godot3 游戏引擎入门之五：上下左右移动动画（下）。本次我们的主角 Player 主要有两种状态：静止（ idle ）和跑动（ run ），注意设置动画的总时长和开启循环播放。另外，由于原图稍大，不能直接放在地图中，我对玩家 Sprite 节点进行了缩放。 说明：和前面几篇文章不同的是，这里我使用了游戏中常用于制作玩家根节点的 KinematicBody2D 图形学节点作为 Player 对象的根节点，并添加一个 CollisionShape2D 节点作为碰撞体。这样做既能让 Player 参与物理响应，又能在代码中操作其移动。 另外有三个需要注意的地方： 第一个是碰撞体形状中的 Extends 属性值表示半宽和半高，这和 Box2D 物理引擎一样 第二个是我们设置的碰撞体形状要比图片稍小，这样能防止意外碰撞，产生不必要的碰撞运算和效果 第三个，也是非常重要的一点：不要缩放碰撞体形状，即：不要设置 scale 属性 第三点同样是为了防止产生意外碰撞情形，不过这点貌似在 Godot 3.1 版本中已经修正了：在绘制碰撞体图形时不能直接拖拽鼠标进行缩放碰撞体了： 准备工作已经完成，接下来就是最关键的部分：脚本代码了。 编写代码给游戏场景的根节点 Game 添加一个 GDScript 脚本，参考前面学习到的知识， 代码量并不多，新的方法已经做了注释，全部的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738extends Node2D# export使变量能在属性窗口中显示和设置值export(float) var speed = 1onready var player = $Playeronready var sprite = $Player/Spriteonready var animationPlayer = $Player/AnimationPlayer# 在这里不使用_process(delta)方法处理物理引擎，# 而应该使用_physics_process(delta)方法进行处理func _physics_process(delta): var velocity = Vector2() var isMoving = false if Input.is_action_pressed('ui_left'): velocity.x += -1 sprite.flip_h = true isMoving = true if Input.is_action_pressed('ui_right'): velocity.x += 1 sprite.flip_h = false isMoving = true if Input.is_action_pressed('ui_up'): velocity.y += -1 isMoving = true if Input.is_action_pressed('ui_down'): velocity.y += 1 isMoving = true if velocity.length() &gt; 0: velocity = velocity.normalized() * speed # 关键代码：移动并测试碰撞体，参数为玩家的移动速度 player.move_and_collide(velocity) if isMoving and animationPlayer.current_animation != 'run': animationPlayer.current_animation = 'run' elif ! isMoving and animationPlayer.current_animation != 'idle': animationPlayer.current_animation = 'idle' 新的关键词和脚本函数介绍； export 关键字修饰的变量能在编辑器的属性窗口中显示并设置值，类似 Unity 中的 public/[Serialized] 关键词 flip_h 布尔值表示图片是否水平翻转，产生向左或者向右的效果，相比使用 scale 缩放属性更加方便简洁 move_and_collide(Vector2) 这是本文 Demo 代码的精髓部分，传递一个速度矢量参数，游戏引擎将移动并处理物理碰撞，简洁又强大 效果调试全部完成了，按 F5 运行游戏，测试我们的最终成果吧。感觉如何？反正我还是有点激动的，“尽情”探索一个“未知世界”吧：有围墙，有障碍物，有墙壁，各种地形等，如果在跑动过程发现有任何问题，别慌，你还可以对地图的所有碰撞体进行 Debug 调试！这也是 Godot 的强大功能之一，在 Debug 菜单下勾选 Visible Collision Shapes 选项即可开启！ 开启碰撞调试后运行游戏的效果： 注意图中的蓝色形状体就是地图碰撞体，是不是和预期一样？调试的时候，我稍微放大了 Player 节点图片，测试的时候看得清楚些，如果你之前有多余的地图，那么场景中可能有多余的不可见的碰撞体存在，这样会影响游戏运行，避免的方法可以直接删除之前的 TileMap 测试地图，也可以在瓦片地图属性下对碰撞图层进行设置，取消碰撞图层和碰撞掩码即可，关于碰撞图层和掩码设置我在后面再讲，操作如下图： 确认场景没有问题后，关闭调试，运行游戏，享受一下自己的成果吧！ 三、总结本篇文章可以算是之前文章的一个结合，是不是感觉越来越简单了？开始动手实现自己的小游戏吧，骚年！不吹逼了，总结下本篇的知识点： Tile 瓦片碰撞体设置 Debug 调试地图、玩家的碰撞体运行状态 几个有用的 GDScript 脚本代码技巧 我想，接下来给大家介绍一些游戏开发中常用的、实用的技巧，以及帮助大家提高效率，在强大开源的 Godot 游戏引擎中以正确的姿势开发 2D 小游戏！“静候佳音”吧，哈哈。嗯，还是那句话，原创不易，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之六：制作TileMap瓦片地图","url":"/2018/10/19/introduction-of-godot-3-part-6-make-tile-map-in-godot/","text":"一、前言收到一个高兴的消息： 2018 年 Github 最新统计出炉， Godot 是所有项目里增长速度最快的第三位！所以，我还是非常看好它的，哈哈！链接在此： Fastest growing open source projects ，截图如下： 吹逼结束，本着承上启下的精神，本篇一起来学习并打造一个“美丽壮观”的游戏世界。使用的工具是 Godot 中的 TileMap 瓦片地图节点。注意：本系列文章包括本篇依旧使用 Godot 3.1 预览版讲述故事的经过，但这并不影响学习使用 Godot 3.0 版本中的瓦片地图制作，不过在此我要提醒的是：预览版中 TileMap 新增了一些强大且实用的功能，这些我会在后面讲解，然后请记得在使用这些新功能的时候，务必时刻保存你的游戏项目，不然有可能因为 Crash 发生奔溃而前功尽弃！嗯，预览版还是有点小 Bug 的， Good luck! 主要内容： Godot 2D 中瓦片地图 TileMap 的制作和使用阅读时间： 10 分钟永久链接：http://liuqingwen.me/2018/10/19/introduction-of-godot-3-part-6-make-tile-map-in-godot/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 了解瓦片地图的一些理论知识 使用图片制作瓦片集 TileSet 使用 SpriteSheet 制作瓦片集 TileSet 介绍 Godot 3.1 中 TileMap 的一些新特性 TileMap介绍要打造一个好的 2D 平面游戏，没有一个好的游戏地图，那是万万不行的！你可以没有悦耳的背景音乐，可以没有花哨的粒子特效，没有动人的剧情设计，但是你至少得有一个完整的游戏地图场景来证明你那“伟大”的游戏的存在吧？！在 2D 游戏中，要制作游戏地图相对来时还是很简单的，特别是涉及多个关卡地图，我们通常都是使用 TileMap 瓦片地图来实现， TileMap 操作简单，效率也高，支持的软件完善，很多游戏都采用它，比如我们小时候耳熟能详的一些“小霸王”游戏：超级玛利亚、坦克大战、魂斗罗等等。 瓦片地图，简单地说就是一个个瓦片堆积起来的一个地图。如果你有 iOS 游戏开发经验，熟悉 SpriteKit 的话，那么你肯定对 TileMap 非常了解， Xcode 对瓦片地图的支持非常完善，功能很强大也易于上手，缺点是 Xcode 只支持 Mac OS 或者 iOS 系统。另外，熟悉 Unity3D 的朋友们也知道，在 Unity 2018 版本之前，使用 Unity 制作 2D 游戏的地图也是很不方便的，如果你想在 Android 或者 Window/Linux 等其他操作系统上开发游戏，那么你需要使用其他的第三方软件来辅助制作地图了。 这里我强烈推荐一款开源软件名为 Tiled ，功能非常强大！使用超方便！能很好地支持并导出你设计好的地图到其他游戏引擎中使用，比如配合 LibGDX 框架开发跨平台 2D 游戏。本节的瓦片地图图片就是从 Tiled 软件自带的例子中拿过来的，建议大家了解一下这款软件，有兴趣的可以玩一玩，对瓦片地图的制作和了解还是有帮助的。 一个游戏场景就是一个简单的世界，我们可以为这个世界添加很多有趣的元素，让玩家有兴趣去探索，这里我们使用瓦片地图来制作我们的游戏场景，实际上，它是由很多小瓦片组成，当然，完全可以根据情况再添加一些背景，这些小瓦片我们称之为： Tile 。瓦片可以很简单，也可以非常复杂，但是在同一个游戏世界里其大小都是统一的，瓦片的类型主要有三种类型： 90° 直角俯视地图（ Orthogonal/Square ）、45° 等距斜视地图（ Isometric ）、等六边形地图（ Hexagonal ）。这三种类型在 Godot 中都是支持的，本篇文章我们主要讨论第一种类型，也是最常用的一种类型吧。 制作TileSet理论到此结束，撸起袖子开始干起！要打造瓦片地图，我们首先需要准备好所有的瓦片——也就是所谓的 TileSet 瓦片集。在 Godot 中制作瓦片集是非常简单的，我这里介绍常用的两种方式，以及第三种：利用 Godot 3.1 中瓦片地图新特性快速打造自动瓦片地图集！ 第一种方式：使用单独的图片制作瓦片 第一种方式算是比较古老的一种方法了，在图片数量比较少的时候我们可以选择这种方式，快捷又方便。首先我们需要准备一些相同大小的图片： 接下来，我们需要把所有图片制作成一个一个的 Sprite 精灵节点，这些节点最好是放在一个单独的游戏场景中，方便我们日后编辑。这里我单独创建一个名为 TileSet_Sprites 的游戏场景，然后把所有瓦片图片资源直接拖拽到场景中，并选择 Sprite 方式创建所有的节点。接着使用 Godot 菜单直接把场景中的所有 Sprite 节点转化为瓦片，制作 TileSet 瓦片集资源。在菜单栏中依次选中： Scene -&gt; Convert To -&gt; TileSet ，选择项目中某个位置保存资源为 tileset_sprits.tres ，一键完成制作我们所需要的瓦片集，既简单又快捷！ 瓦片集准备好了，下一步就是使用它来制作你那伟大的游戏地图了！我们制作地图的节点叫做 TileMap 瓦片地图，使用也很简单，只要把 TileSet 资源添加到 TileMap 即可。首先创建一个主场景，在根目录下添加一个 TileMap 地图节点，注意，这里一定要设置好地图的单元尺寸，即 Cell 属性，示例中瓦片尺寸都是 32x32 像素，所以按此设置即可。接着在 Tile Set 属性菜单下点击 Load 加载我们刚才制作完的瓦片集资源 tileset_sprits.tres ，这时你会看到所有的小瓦片都出现在编辑器中了，选中任意一个瓦片，开始你的艺术创作吧，骚年！ 第二种方式：使用图片合集制作瓦片 当我们制作的地图元素非常多的时候，第一种方式明显不合常理了！图片过多导致文件难以管理，加载性能也会下降，这时候我们一般会把图片制作成 SpriteSheet 图片精灵集，这样既能减少文件数量，方便管理，又能提高加载速度和游戏的性能，关于 SpriteSheet 的原理我推荐大家到 TexturePacker 软件官网上浏览开发者的相关文章： What is a sprite sheet? ，这篇文章图文详细介绍了什么是 SpriteSheet ，以及它的优势和原理。 除了图片资源形式不同，其他原理和第一种方式并没有什么不一样：我们把单张 SpriteSheet 图片转化为一个一个的 Sprite 节点，然后一键转换为 TileSet 资源就可以了。理论如此，但在操作过程中会有一个问题：一张大图由很多的小图拼成，这些小图需要制作成一个个的 Sprite 节点，那么如何精确的把这张大图划分为大小统一的小图呢？这样做工作量岂不是比第一种方式要大很多？——别急， Godot 肯定想到这点了，既然大小统一，我们只需要开启 Snap 吸附功能就可以轻松完成区域划分了！具体操作在场景窗口的上方菜单栏选项里，打开吸附功能，并设置相关参数，然后就可以精确地进行相关操作了： 停！！！貌似这并没有什么卵用啊？是的，这个吸附功能只在场景编辑操作中适用，和我们现在要制作的精灵节点并没有半毛钱关系，不过原理是一样的。创建一个 Sprite 节点，把 SpriteSheet 大图拖拽到 Texture 属性下，然后勾选开启 Region 特性，打开 TextureRegion 编辑工具窗口，吸附功能就在这个窗口中进行设置。注意：我所使用的这张图的每一个小图片都有偏移，偏移像素为 1 个像素，所以需要在 Grid Snap 网格吸附选项里进行相关设置。具体操作如下动图： 虽然我只操作了两张图，不过还是蛮快的，只要按住 Ctrl + D 复制一下节点，利用吸附功能框选一下 Sprite 的材质区域即可，付出一点耐心，很快就能把所有节点制作完成，最后和第一种方式一样，一键把场景转化为 TileSet 资源。在游戏主场景中，再创建一个新的地图，隐藏刚才的创建的地图，选择我们新建的 TileSet 资源进行地图绘画，效果如下，注意我框选的几个角落： 第三种方式：新版本中瓦片地图新特性 终于轮到新版本中的地图新特性了！这种方式最为方便，也是功能最强大的一种方式，操作流程也与上面两种方式截然不同。再次提醒一下：在使用 Godot 3.1 预览版中的 TileMap 新功能的时候，务必时刻保存你的游戏项目，因为预览版还不够稳定，有可能会产生意想不到的奔溃，牢记牢记！ 第一步，使用瓦片地图之前，我们需要手动创建一个空的 TileSet 资源，并保存到合适位置： 记住，这种方式同样适用于其他资源的创建。第二步就是愉快地使用 Godot 3.1 版本中的地图新特性了，使用新功能快捷创建一个强大的自动地图集。啥叫自动地图集？参考上面的那张效果图，注意几个角落，所谓的自动地图集，顾名思义就是画地图的时候不需要手动去添加那八个角落了， Godot 自动帮我们完成，是不是很方便？ 如果上图看不清可以查看大图： Godot 3.1 自动地图集操作详细动图。另外， TileMap 新特性中的有些功能是我们没见过的，比如，我们制作 TileSet 范围就是勾画 Region 区域，而 Bitmask 区域则是告诉 TileMap 如何自动完成整片地图的绘制， Priority 代表图片出现的概率， Icon 用来设置自动地图图标，还有我们后续游戏场景中会使用到的碰撞功能： Collision 碰撞区域设置，详细说明我在下图中都勾选出来了。总之，这么多新特性，大家可以多做一些尝试。 其他说明这里我们只是简单地尝试了一下 Godot 中的瓦片地图制作，后续有机会我还会介绍如何在瓦片地图上添加一些其他物理特性，比如光照遮挡，或者添加真正的碰撞体，以实现游戏世界中的墙壁、地面等。 最后， Godot 3.1 中还有一个辅助小特性，可以设置瓦片集合 Atlas ，即一组瓦片组成一个集合，方便地图绘制，如下图： 附加知识：关于旧版本 Godot 中的瓦片地图绘制，如果不熟悉可以先看看 Xcode 中的关于瓦片地图的一些标记： 这里有一个例子，如何画一片海洋区域： 三、小结本篇就这样利用多图完成了，不知道读者朋友们看完有啥感想？如果你能坚持从我的 Godot 系列第一篇文章读到本篇文章，那么非常感谢你的阅读，其实我最近更新的速度越来越慢，写完一篇文章至少要耗费我 3 天的闲暇时间，这篇文章更是花费了我一周，因为平时要工作，闲余时间还不一定有空，所以，等待更新的朋友要耐心点了。读完，我相信你应该会和我感受一样： Godot 必定能火！哈哈！最后，附上 InfoQ 中关于 Github 的最新统计信息报告： GitHub发布史上最大更新，年度报告出炉！ 原创实属不易，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之五：上下左右移动动画（下）","url":"/2018/10/11/introduction-of-godot-3-part-5-the-basic-top-down-movement-part-2/","text":"一、前言本篇是上一节文章：Godot3游戏引擎入门之五：上下左右移动动画（上）的继续。上一篇使用动画和代码实现了玩家的上下左右移动功能，接下来我们解决一个问题：给游戏添加碰撞体，让玩家在有限的地图中移动。 注意：我目前使用的是 Godot 3.1 预览版，与 Godot 3.0 正式版有一些区别，不过界面上影响不大，如果要使用我所上传的 Github Demo 代码，记得去官网下载 3.1 预览版然后就可以正常打开运行 Demo 了。 Good luck! 主要内容： Godot 2D 中玩家的上下左右移动及碰撞实现阅读时间： 4-5 分钟永久链接：http://liuqingwen.me/2018/10/11/introduction-of-godot-3-part-5-the-basic-top-down-movement-part-2/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 使用 AnimationPlayer 节点工具创建状态动画（上） 使用代码控制玩家的上下左右移动功能（上） 简单的摄像机使用和地图碰撞检测实现（上下） 通过代码实现 RigidBody2D 刚体节点的运动（下） 场景和代码基本场景的制作已经在上篇中详细解说过了，另外我们还在场景中增加了一个 Camera2D 摄像机节点，让场景的视窗时刻聚焦在玩家周围，但是玩家依然可以“鲤鱼跃龙门”，对场景中的墙壁视而不见，豪迈奔放！游戏运行结果如下： 接下来利用物理引擎相关知识解决玩家移动范围限制的问题。 添加碰撞体首先要做的是给墙壁添加上碰撞体，限制场景运动区域范围。由于墙壁是静止不动的物体，所以我们给它添加一个 StaticBody2D 静态碰撞体节点。你可以直接在 Sprite 节点下添加一个静态碰撞体，并设置好碰撞体大小；也可以把 Sprite 作为 StaticBody2D 的子节点，这也是推荐的流程。但是在没有特殊用途下（比如不需要添加代码等），你可以随便安排， Godot 中的节点是非常灵活的。 这里为了正确设置碰撞体的形状，我把之前单一的墙壁背景拆分为了四面独立的墙，然后分别设置碰撞体形状。接着要在玩家节点上添加碰撞体，这里我们需要谨慎操作：第一是注意节点的类型，和墙壁不同，玩家是可以移动的，且拥有物理属性，所以不能使用静态碰撞体；第二是节点的父子关系的顺序问题，我们因为要移动碰撞体，而不是 Sprite 精灵图片节点，所以 Sprite 应该作为碰撞体节点的子节点，且不能弄反！详细解说在我的入门文章第二篇中有详述： Godot3 游戏引擎入门之二：第一个简单的游戏场景。 和大名鼎鼎的 Box2D 开源物理引擎类似， Godot 中也有三种常用的物理碰撞体： StaticBody2D | RigidBody2D | KinematicBody2D ，同属于 PhysicsBody2D 类型下，它们之间的异同点大致如下； 节点名 StaticBody2D RigidBody2D KinematicBody2D 节点名称 静态碰撞节点（ 2D ） 刚体节点（ 2D ） 运动学节点（ 2D ） 基本特性 自动碰撞检测，位置固定不变 自动碰撞检测，产生碰撞响应：有线速度、角速度等 参与碰撞检测，无自动响应，完全由代码控制移动 使用场景 一般用于固定的墙壁、地面等 一般用于受外界影响而产生运动的物体，比如球体、陨石等 主要用于由代码控制的带物理属性的玩家 了解了这三种节点后，得出的结论是不是应该给我们的主角添加一个 KinematicBody2D 运行学节点呢？嗯……然而并不是，如果使用 KinematicBody2D 节点，我们需要自己手动控制物理反馈，虽然绝大多数的游戏应该这样，但是这不是本篇文章的做法，尽量不要动代码是我的出发点，以后再介绍 KinematicBody2D 节点，现在我们暂时使用简单一点的 RigidBody2D 刚体节点进行尝试。（是不是听上去有点不符合直觉？其实在有些游戏中，比如太空飞船射击游戏，就可以使用 RigidBody2D 作为玩家节点进行开发。） 理论到此为止，给我们的游戏场景添加一个 RigidBody2D 刚体节点，改名为 Player ，然后把之前的玩家 Player （ Sprite ）节点拖到 RigidBody2D 节点下作为其子节点，同时 AnimationPlayer 节点也要作为刚体节点的子节点，保持和 Player 节点平级的关系，最后添加一个 CollisionShape2D 节点用于设置碰撞体的形状。 最终场景中的节点如上图，唯一要设置的是把 RigidBody2D 的重力影响属性 Gravity Scale 设置为 0 ，即完全摆脱重力的影响，不这么设置的话，你会发现玩家会“情不自禁”地做自由落体运动。另外，值得注意的是，我在改名的过程中，原来的 Player 节点自动更名为 Player1 ，然后动画全部失效，解决办法很简单，在动画面板里把轨道的名字改过来即可，如下图： 最终代码场景一切就绪，接下来的任务就是修改代码了！因为我们的节点关系产生了变化，还有节点的行为也变了（ Sprite -&gt; RigidBody2D ），所以对于新手朋友我要特别提醒的是：玩家已经转变成 RigidBody2D 刚体节点了，刚体节点是会自动产生物理响应的，所以我们不能像刚才那样直接使用代码操作玩家的位置，相反，我们应该通过设置刚体的线速度、角速度来实现对刚体运动的控制！ 具体修改我都在代码中做了注释，代码量不大，相信大家都能看懂吧。这里全部的代码我就不贴出来了，修改部分如下： 12345678910111213onready var animationPlayer = $Player/AnimationPlayer # 修改后onready var camera = $Camera2Dplayer.linear_velocity = velocity # 添加部分，设置线速度，速度为0时有用player.angular_velocity = 0 # 添加部分，设置角速度，防止player打转# 速度不为0，移动玩家位置，同时更新摄像机if velocity.length() &gt; 0: # 注意这里normalize速度矢量 # player.position += velocity.normalized() * speed * delta # 删除 player.linear_velocity = velocity.normalized() * speed # 添加，更新速度 # 更新摄像机，玩家始终在视窗内活动 updateCameraPosition() # 省略代码…… 终于完工，按 F5 运行游戏，看看我们的杰作吧： 三、小结（下）相对来说，这篇的知识点还是非常简单的，当然对于编程初学者来说，代码还是一个需要克服的地方。在接下来的文章里，我会针对 2D 游戏中的地图创建做几篇文章，也就是 TileMap 节点的功能介绍和使用，打造一个游戏该有的丰富世界！ 最后，本篇上下节结束后，我要提醒新手朋友们几个注意点： 我们实际项目中使用 RigidBody2D 来作为玩家还是比较少的，相对多的还是 KinematicBody2D 节点 我们对物理碰撞的处理不应该放在 _process(delta) 方法中，而应该放在 _physics_process(delta) 方法中，后续再讲 地图太简单了，这也是这篇要埋下的伏笔，下篇介绍，“等着瞧”，哈哈 原创实属不易，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之五：上下左右移动动画（上）","url":"/2018/10/10/introduction-of-godot-3-part-5-the-basic-top-down-movement-part-1/","text":"一、前言前面的几篇文章陆陆续续开始介绍 2D 游戏中对玩家的一些基本操作流程了，不过功能实现非常有限，接下来我想完完整整的打造一个小 Demo ：在封闭的游戏场景里控制玩家自由移动，从而达到一些简单的目标。那么， first thing first ，从解决上下左右移动功能实现开始！ 上下左右移动也叫 Top-down 移动动画，这篇文章我会通过 Godot 中的节点以及相关的代码来实现玩家主角的基本移动控制。之后，再改造一下游戏场景，让我们的主角自由行走在有限的世界里。一如往常，老司机带路，如果你是编程新手，那么，前方高能请系好安全带啦！当然，前面的文章也讨论过了， GDScript 脚步非常简单，不熟悉的话可以浏览一下本系列之前的文章。 主要内容： Godot 2D 中玩家的上下左右移动及碰撞实现阅读时间： 5 分钟永久链接：http://liuqingwen.me/2018/10/10/introduction-of-godot-3-part-5-the-basic-top-down-movement-part-1/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 使用 AnimationPlayer 节点工具创建状态动画 使用代码控制玩家的上下左右移动功能 简单的摄像机使用和地图碰撞检测实现 通过代码实现 RigidBody2D 刚体节点的运动 创建动画相信看了上篇文章的朋友应该对 AnimationPlayer 这个功能强大的动画工具有了一定的了解。之前只是利用它最基础的功能实现了一个简单的天鹅飞舞动画，接来下我们要使用 AnimationPlayer 节点实现稍微复杂的动画制作——玩家的各种状态动画实现。 我们先创建一个场景，根节点改名为 Game ，添加两个子节点： Sprite （命名为 Player ）和 AnimationPlayer 节点。 Player 节点的图片材质是一张 4x5 的 SpriteSheet 精灵图集，四行分别代表下、左、右、上移动动画： 和上篇文章制作天鹅动画操作一样，分别制作四个移动动画，这四个动画都设置为循环播放，动画时长和步进大家可以自己尝试进行设置不同的时间，直到自己满意为止吧，我的就随便设置了： 时长 0.8 ，步进 0.2 ，具体设置参考上一篇文章：Godot3游戏引擎入门之四：给主角添加动画（下）。接下来才是重点：我们制作一个游戏启动时刻玩家入场动画。其实这个游戏大可不必这样做，完全是为了演示 AnimationPlayer 的强大功能，并增加一些喜感吧，当然也有一定借鉴意义，哈哈。 玩家 Player 入场动画的基本思路是这样的：主角从场景中央稍微偏上的位置快速移动到屏幕中央（ position ），同时尺寸由小逐渐放大到正常缩放（ scale ），并伴随透明度从完全透明到完全不透明（ modulate/a ），动画最后再加上一段玩家闪现的动画进行强调（ visible ）。哈哈，颇有主角粉墨登场的戏份啊！欢呼吧，骚年~ 思路有了，关键在于使用 AnimationPlayer 来进行创建了。之前的动画制作都是一个轨道解决一个动画，但是这个动画不同了，需要一个动画实现多个属性的控制，这里就需要多个轨道了，每个属性分别创建一个轨道，然后对属性设置关键帧进行动画控制，这里需要注意的第一点是： Godot 3.1 alpha 版本中对位置和缩放属性不能直接使用钥匙🗝️按钮创建相应的轨道和关键帧，会重复创建轨道，这应该是一个 Bug ，不过不要紧，我们使用普通的做法，手动创建 Property Track 属性轨道，选择 Player 节点的相应属性，之后可以正常使用钥匙🗝️按钮创建关键帧，部分操作如下图： 上图中的勾选贝塞尔曲线过渡方式大家可以尝试一下，看看和平滑过渡有什么不同的效果吧。接下来，动画中透明度的设置是通过 Sprite 节点的 Modulate 颜色属性的 Alpha(A) 通道设置实现的，至于闪现是通过控制节点的可见性 Visible 属性实现的，只要是属性， AnimationPlayer 就能创建动画，就是这么强！ 最后记得把入场动画（名为 start ）设置为自动播放，不要设置循环播放，毕竟主角登场了就不要重复了。 代码控制动画制作完后的任务就交给代码来实现了！代码和上一篇文章里的左右移动代码没啥本质区别，只是多了两个方向而已，不过有两点新鲜玩意。第一个是我设置了速度变量，它是一个 Vector2 矢量，这样做的目的是：即使我们同时按住两个按键，玩家依然可以跑动或者原地踏步！大家可以体会下和上一节的不同之处。 第二个可谓是一个可以“节约生命”的功能，还记得上一节里怎么监控按键的吗？需要一个一个的常亮比如： KEY_A/KEY_LEFT 表示 A 键和左方向键。如果你是 Unity 的开发者，那么你对按键设置肯定非常熟悉，这里我不得不说 Unity 在这方面做得还是非常棒的，对键盘、操纵杆的控制设置很到位。 Godot 中同样也可以进行简化设置，比如把 A 键和左方向键统一到自定义按键 left 中，具体设置在 Project Settings 中的 Input Map 下添加自定义输入控制： 设置完就可以开森地写代码了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152extends Node2Donready var player = $Playeronready var animationPlayer = $Playervar currentAnimation = 'start'var speed = 200func _ready(): camera.position = player.positionfunc _process(delta): var velocity = Vector2(0, 0) # 速度变量 var isMoving = false # 是否按键移动 var newAnimation = currentAnimation # 动画变量 if Input.is_action_pressed('left'): velocity.x += -1 newAnimation = 'left' isMoving = true if Input.is_action_pressed('right'): velocity.x += 1 newAnimation = 'right' isMoving = true if Input.is_action_pressed('up'): velocity.y += -1 newAnimation = 'up' isMoving = true if Input.is_action_pressed('down'): velocity.y += 1 newAnimation = 'down' isMoving = true # 速度不为0，移动玩家位置 if velocity.length() &gt; 0: # 注意这里 normalize 速度矢量，否则会出现斜着走速度比单方向速度快 player.position += velocity.normalized() * speed * delta # 根据是否有按键按下和新动作更新动画 updateAnimation(isMoving, newAnimation)func updateAnimation(isMoving, newAnimation): # 如果有移动按键按下，并且改变方向，则切换动画 if isMoving and currentAnimation != newAnimation: animationPlayer.current_animation = newAnimation animationPlayer.play(newAnimation) currentAnimation = newAnimation # 未移动，但又非开始的情况，那么止移动动画 elif ! isMoving and currentAnimation != 'start': animationPlayer.stop() currentAnimation = 'start' # 其他情况比如同方向继续移动，或者在开始的时候都不用处理 完成后效果： 摄像机节点对于上面实现的效果感想如何？嗯，移动是没问题了，入场动画有，只是没有录制进来，有兴趣的朋友可以到 Github 上下载源码自己运行看看效果。不过，问题是，玩家完全可以脱离视野离家出走啊——所谓破墙而走！三种解决方式： 第一种是限制移动，让玩家在固定视窗内行动，即通过判断玩家位置坐标计算有没有超出限制范围，上一篇介绍过了 第二种是使用物理碰撞，把假的墙壁设置为真实的墙壁，这种方式下面会将 第三种是非正面解决方式，即给我们的游戏添加一个摄像机，而这个摄像机时刻跟随主角运动，那么主角就不会脱离视野了 好吧，后面两种是这篇文章的目标，对于设置摄像机，和其他游戏引擎没有区别：添加一个摄像机节点，设置一下就好了，非常简单。在 Godot 中摄像机节点是 Camera2D ，添加一个节点到游戏场景后，我们通过代码控制摄像机保持和玩家位置一致，这里唯一一个要设置的地方就是：勾选 Camera2D 的 Current 属性，激活摄像机。同时，我还稍微拉伸了镜头，使得游戏场景被放大——通过设置摄像机的 Zoom 参数实现。 上图中，最下方的文字说明了视窗属性的设置：视口模式 Mode 为 2d ，缩放模式 Aspect 设置为 keep ，即保持比例，这些设置都在 Project Settings 里能找到。作用很简单，如果不设置，那么默认情况下，我们的游戏进入全屏状态后是不会进行缩放的，就像下面这样： 最后在 player.position += velocity.normalized() * speed * delta 这一句后面添加一点代码： 123456789101112# 省略代码......# 速度不为0，移动玩家位置if velocity.length() &gt; 0: # 注意这里 normalize 速度矢量，否则会出现斜着走速度比单方向速度快 player.position += velocity.normalized() * speed * delta # 更新摄像机，玩家始终在视窗内活动 updateCameraPosition() # 省略代码......func updateCameraPosition(): camera.position = player.position 运行游戏，查看效果： 接下来解决玩家移动无范围限制的问题。 添加碰撞文章有点长，偷下懒，暂时到这里，接下来的内容放到下一节。 Stay tuned! 三、小结（上）除了代码，这是一篇非常简单的文章，使用 AnimationPlayer 制作多个动画，以及单个动画多个轨道；使用 Camera2D 跟随玩家移动视野；设置按键规则和视窗缩放属性等。接下来的重点就交给本章的下节吧。 假期没有更新，带孩子在外面和家里玩了 8 天，哈哈！话说回来，嗯，还是那句：原创不易啊，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之四：给主角添加动画（下）","url":"/2018/09/27/introduction-of-godot-3-part-4-add-some-cute-animations-part-2/","text":"一、前言本篇是上一节文章：Godot3游戏引擎入门之四：给主角添加动画（上）的继续。在这两篇文章里，我会详细讲述 Godot 3 中制作简单精灵动画的三种方法，其中上部分包含两种，下部分讨论第三种方式。 主要内容： Godot 2D 小游戏入门之三种动画创建方式（第三种）阅读时间： 8-10 分钟永久链接：http://liuqingwen.me/2018/09/27/introduction-of-godot-3-part-4-add-some-cute-animations-part-2/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 使用动画精灵 AnimatedSprite 节点创建 Sprite 骑士动画（上篇） 使用 Sprite 节点和 GDScript 脚本代码共同创建背景滚动效果（上篇） 使用 AnimationPlayer 节点制作天鹅飞舞的关键帧动画（下篇） 创建动画首先，简单回顾一下本篇上节内容中的两种游戏动画制作方式： 第一种方法：使用 AnimatedSprite 制作骑士动画 非常简单又符合直觉的一种方法，最适合于打造单个人物或物件的精灵动画特效。 AnimatedSprite 制作动画的原理相当简单，只需要提前准备好必须的图片资源即可，具体操作参考上节的内容。 第二种方法：使用代码控制背景天空滚动 这种方式相对第一种可以说是最符合程序员的思维习惯的的：通过代码直接控制并移动背景图片的位置就能达到我们所想要的动画特效。在上一节内容中，我们还了解到了 Godot 中图片的坐标原点位置的相关设置。 第三种方法：使用 AnimationPlayer 关键帧制作天鹅动画 上文介绍的两种动画制作方式简单也不失灵活性，在实际游戏开发过程中使用的也会比较多，但是，如果你认为 Godot 就这点能耐的话，那你也太小看它了，哈哈。接下来我们开始探讨第三种动画制作方式：关键帧动画！现在，隆重请出我们今天的主角： AnimationPlayer ！ 在深入讨论之前，我们先了解一下 SpriteSheet 相关知识，如果你有使用过 LibGDX 跨平台游戏框架开发游戏的经验，或者熟悉 Unity 中的 2D 游戏动画制作，那么你肯定对 SpriteSheet 会非常了解。我们想象一下第一种动画方式，使用 AnimatedSprite 制作动画虽然简单，但是如果涉及到人物多种状态，比如攻击、跳跃、行走、死亡等，那么图片资源是不是会多如牛毛？而且操作过程中还容易出错，这就是 SpriteSheet 的由来之处了！简而言之， SpriteSheet 就是把很多图片，甚至不同类型的图片资源，放到一个大图片里，方便管理操作和使用，听说过 TexturePacker 这个软件吗？它就是专门干这事的。 理论到此结束，我们来瞻仰一下我们要实现的天鹅动画的图片资源 SpriteSheet 精灵图集： 图片结构很单一，可以看得出是由 8 张连续的小图拼接而成的，怎么使用呢？首先，我们还是和往常一样使用一个 Sprite 精灵节点来显示天鹅图片，改名为 Swan ，但是这里还需要进行一些简单的设置： 如上图，我们设置属性 Vframes 值为 1 ， Hframes 为 8 ，意思很明确，即纵向分 1 帧，横向分 8 帧，然后总共 1x8 帧，而第三个属性 Frame 就表示当前显示第几帧画面，可以设置为 0-7 共 8 帧画面，操作浏览一下效果试试，你会发现 Frame 值从 0 到 1 然后慢慢设置到 7 的时候，天鹅图片就产生了一种不连续的动画效果，对，动画原理就是这么简单！这个时候你会想：我如果在代码中获取 Swan 的 Frame 属性，然后把它的值每次往前加 1 不就可以生成动画了吗？的确可以！代码如下： 12345func _process(delta): if $Swan.frame == 7: $Swan.frame = 0 else: $Swan.frame += 1 这和第二种方法的道理完全相同，也很值得一试！不过运行游戏场景后，你会发现天鹅飞舞的动画太快了！当然，这并不是什么大问题，添加一个时间控制的变量，让帧属性慢点往前加 1 就可以了。不过这不是我们要讨论的重点，我所要给大家介绍的是 Godot 中强大到能够控制一切的关键帧动画节点工具： AnimationPlayer ！ 对，在 Godot 中 AnimationPlayer 的确能操纵一切，简单的如位置、旋转、缩放的控制，还有其他节点的任意属性值的控制，甚至连方法的调用都能在 AnimationPlayer 中进行动画设定！同时，不仅强大，使用起来也非常简单。如何实现天鹅动画，这里我做了一个简单的操作示意图，大家可以感受下 AnimationPlayer 节点的使用步骤： 下面进入细节部分，首选我们需要在游戏根节点下创建一个 AnimationPlayer 节点，这里要强调一下：我们要对 Swan 节点进行动画，所以他们需要放置在同一级别上！当然， AnimationPlayer 完全可以同时对其他节点比如天空背景或者主角骑士节点进行动画，你可以尝试一下。接下来，选择 AnimationPlayer 节点，新建一个动画轨道： 然后对我们新建的动画轨道进行设置：自动播放、重复播放、动画时长等，部分细节如下图： OK ，大功告成，运行结果： 最后，虽然动画有了但是天鹅并不能移动位置，我们需要让它随着时间不断移动位置就可以了。这里介绍一个小技巧：我们可以直接在节点上添加脚本！ Godot 推荐我们这么做，尽量让每一个节点独立，也就是和整个游戏场景解耦，在大项目中让合作开发更高效。 Talk is cheap, show me the code! 选择 Swan 节点，点击添加脚本，编写代码： Swan.gd12345678910111213extends Sprite# 速度常量const SPEED = 100# 最左边界和最右边界var minX = -100var maxX = 800func _process(delta): position.x -= SPEED * delta # 如果天鹅飞到左边边界，把它的x坐标置为最右边界 if position.x &lt; minX: position.x = maxX 最终效果： 所有代码我们的游戏终于完成了，这里我附上所有的代码，如果你已经阅读过前面两篇文章：Godot3游戏引擎入门之三：移动我们的主角，那么请跳过。 Game.gd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 继承于Node2Dextends Node2D# 常量，表示速度（像素）const SPEED = 200const SKY_SPEED = 50# 定义一些变量，不需要类型var maxX = 600 # 角色运动右边界var minX = 0 # 角色运动左边界# onready关键词使变量在场景加载完后赋值，保证不为nullonready var knight = self.get_node(\"Knight\")# 在Godot中$符号可以直接加子节点名字获得子节点对象，相当于get_node方法onready var sky1 = $Sky1onready var sky2 = $Sky2# 节点进入场景开始时调用此方法，常用作初始化func _ready(): maxX -= knight.frames.get_frame('idle', 0).get_size().x / 2 minX += knight.frames.get_frame('idle', 0).get_size().x / 2# 每一帧运行此方法，delta表示每帧间隔func _process(delta): # 移动背景天空位置，生成滚动动画 updateSkyAnimation(SKY_SPEED * delta) # Input表示设备输入，这里D和右光标表示往右动 if Input.is_key_pressed(KEY_D) or Input.is_key_pressed(KEY_RIGHT): moveKnightX(1, SPEED, delta) return elif Input.is_key_pressed(KEY_A) or Input.is_key_pressed(KEY_LEFT): moveKnightX(-1, SPEED, delta) return # 没有键盘控制，让骑士动画为idle状态 if knight.animation != 'idle': knight.animation = 'idle'func updateSkyAnimation(speed): # 移动，更新背景的位置 sky1.position.x -= speed sky2.position.x -= speed # 如果滚动到最左边，那么移动到右边来 if sky1.position.x &lt;= -1200: sky1.position.x += 2400 elif sky2.position.x &lt;= -1200: sky2.position.x += 2400 # 自定义函数，direciton表示方向，speed表示速度，delta是帧间隔func moveKnightX(direction, speed, delta): # 有键盘控制，让骑士动画为run状态，跑起来 if knight.animation != 'run': knight.animation = 'run' if direction == 0: return # position属性为节点当前置，Vector2向量简单乘法 knight.position += Vector2(speed, 0) * delta * direction # 越界检测 if knight.position.x &gt; maxX: knight.position = Vector2(maxX, knight.position.y) elif knight.position.x &lt; minX: knight.position = Vector2(minX, knight.position.y) knight.scale = Vector2(direction, 1) 三、小结（下）三种方式已经全部讲解完毕，这里简单总结一下 Godot 3 中动画制作三种方式的优缺点： 节点名 AnimatedSprite Sprite + GDScript AnimationPlayer 优点 简单明了，最适合制作主角多种状态动画 思路清晰，适合简单的动画，代码可控度高 最强大的动画系统，几乎能操纵一切元素来实现复杂的动画 缺点 只能使用图片，而且必须使用很多张图片，资源文件数量大增 对于复杂的属性动画很难使用代码达到理想效果 仅仅操作稍复杂点，节点的位置必须同级别 本篇上下节内容结束，还是那句话：原创不易啊，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之四：给主角添加动画（上）","url":"/2018/09/25/introduction-of-godot-3-part-4-add-some-cute-animations-part-1/","text":"一、前言说明：我目前使用的 Godot 3.1 预览版，所以会与 Godot 3 的版本有一些区别，界面影响不大，如果要使用我上传的 Github Demo 代码，记得去官网下载 3.1 预览版（或者等之后正版发布）然后就可以正常打开运行 Demo 了。 本篇文章我会详细讲述 Godot 3 中制作动画的三种方式，篇幅有点长，所以分成上下两部分，请留意。 主要内容： Godot 2D 小游戏入门之三种动画创建方式（前两种）阅读时间： 10-15 分钟永久链接：http://liuqingwen.me/2018/09/25/introduction-of-godot-3-part-4-add-some-cute-animations-part-1/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 使用动画精灵 AnimatedSprite 节点创建 Sprite 骑士动画（上篇） 使用 Sprite 节点和 GDScript 脚本代码共同创建背景滚动效果（上篇） 使用 AnimationPlayer 节点制作天鹅飞舞的关键帧动画（下篇） 游戏场景还是上篇一样的场景：绿油油的草地上站着一位能左右打滑的扛着大刀的小正太！嗯，不合格的武士只能打滑，不能跑，还不能正常呼吸，怎么看都不舒服，所以，我们这篇文章的任务就是：让他真正地动起来——给我们的游戏场景添加一些生动的动画元素。 由于涉及到动画，这会导致在 2D 游戏中图片资源数量急剧增加，不过别担心，我已经分门别类地放置好了，在 Godot 项目中可以使用文件夹管理资源，如下： 项目 Demo 已经上传到 Github ，您可以到我的 Github 主页上下载整个游戏的相关资源和代码，如果需要直接运行，请注意使用 Godot 3.1 预览版打开。 接下来，我们在原来场景的基础上：让我们的主角真正地跑起来，再增加一个卡通云朵飘过的天空，以及一只在天空中飞舞的勤奋的小天鹅。 创建动画我们要添加的三个动画元素，分别使用三种方法制作，当然，你完全可以只选择其中一种或两种动画方式来完成，这取决于你，这里我只是把这几种常用方式都介绍一下，希望达到一个抛砖引玉的效果，哈哈。 第一种方法：使用 AnimatedSprite 制作骑士动画 这种方法使用非常简单但又不失强大，最适合于打造单个人物、物体的精灵动画特效。 AnimatedSprite 制作动画的原理很简单：如同电影胶卷一样，一张一张图片播放，当播放速度达到一定程度，就感觉是在播放动画了！ 如果你有使用过 Apple iOS 的 SpriteKit 框架的经验，那么你会发现这种动画制作方式在游戏开发中使用是非常频繁的。 Godot 中使用的是 AnimatedSprite 节点，制作动画非常简单，你需要准备的是很多张主角的一系列动作图片即可。本次 Demo 中我们将应用到骑士两种动作状态： idle 休息状态和 run 奔跑状态。 视频： http://liuqingwen.me/2018/09/25/introduction-of-godot-3-part-4-add-some-cute-animations-part-1/Logo%20disney-%20Steamboat%20willie.mp4 理论说多了，不如实践！我们开始动工。首先，和上一篇不一样，我们不使用 Sprite 创建主角，取而代之的是 AnimatedSprite 动画精灵节点，添加节点后改名为 Player ，操作结果如下图，忽略节点后的警告小三角形： 接下来按上图，先选中 Player 骑士玩家（ AnimatedSprite 节点），在属性面板 Frames 下点击新建一个 SpriteFrames 即所谓的精灵帧组，创建完后点击 Open Editor 打开精灵帧动画编辑工具面板（注意：此处和 Godot 3.0 版本略有区别，之前的版本中无此按钮，也不需要点击此按钮！），主界面下方就出现了我们创建主角各种动画状态的工作区域了。这里我们创建两个动画，分别命名为 idle 和 run ，然后对应地把各自状态的 10 张图片（命名 (1) 到 (10) ）拖到空白内容栏即可，步骤如下： 完成后，我们需要调整每个状态动画的帧率（ FPS ），也就是每秒显示几帧或者几张图片。我这里设置 idle 状态是 8 FPS ，跑步 run 动画状态是 16 帧每秒，你可以按需设置，接着选中骑士玩家节点，在属性面板，如上面第二张图中突出部分，勾选 Playing 选项框，然后在 Animation 属性中选择你想查看的动画状态（ idle/run ）就可以在编辑器中实时查看人物动画效果了，是不是很贴心啊？ 不知道你的感觉是怎样，反正我感觉 Godot 的动画精灵非常简单又灵活，其实在 Unity 中也有帧动画，即 Animation ，但是在 Unity 中创建动画相对 Godot 要繁琐点，需要创建帧，然后一帧一帧地设置图片，最后需要创建 Animator Controller ，在 Godot 中可以直接拖拽一步到位，设置也非常简单。 第一种方式基本完成，接下来就是控制显示玩家的状态了，原理非常简单：如果玩家移动，那么把玩家节点的动画状态调整为 run ，否则设置为 idle 静止。参考上一篇的代码， 新增核心代码如下： 12345678910111213141516171819202122# ...省略一些代码，和上一篇文章代码一样# ...可以在 Github 上下载源代码func _process(delta): # Input表示设备输入，这里D和右光标表示往右动 if Input.is_key_pressed(KEY_D) or Input.is_key_pressed(KEY_RIGHT): moveKnightX(1, SPEED, delta) return # 有设备输入，直接返回 elif Input.is_key_pressed(KEY_A) or Input.is_key_pressed(KEY_LEFT): moveKnightX(-1, SPEED, delta) return # 有设备输入，直接返回 # 没有键盘控制，让骑士动画设置为idle状态 if knight.animation != 'idle': knight.animation = 'idle'# 自定义函数，direciton表示方向，speed表示速度，delta是帧间隔func moveKnightX(direction, speed, delta): # 控制骑士移动，让骑士动画为run状态，跑起来 if knight.animation != 'run': knight.animation = 'run' # ...省略其他代码，和上一篇文章代码一样 运行以下，效果如图： 第二种方法：使用代码控制背景天空滚动 现在进入第二种动画方式，相对第一种，这种方式可以说是最符合程序员直觉的：直接控制移动背景图片的位置就能达到我们想要的效果。所以，为了让云朵动起来，我们需要一点点代码。在编写代码之前，我们先搞懂一个 2D 游戏中经常遇到的概念：原点（ Origin ）位置。 在 Godot 中坐标系原点位于舞台的左上角，往右为 x 正方向，往下为 y 正方向，和大部分手机游戏框架类似，同时 Sprite 图片精灵的原点位置默认为图片的正中心点，所以当图片坐标为坐标系原点 (0, 0) 的时候，图片只有右下角部分显示在场景中，想要图片从左上角开始全部位于场景中，需要往右下方向移动图片大小的一半，这样我们使用代码处理起来很不方便，如果能把图片的原点位置置于图片左上角（比如 Adobe Flash 中的 Sprite/MovieClip 默认如此），那处理起来会更加方便，可否这样设置呢？——当然可以！ 首先，我创建了两个一模一样的 Sprite 节点，分别命名为 Sky1 和 Sky2 ，材质属性也一模一样，都是一张天空背景图，选中每一个节点，在节点属性的 Offset 下，取消勾选 Center ，即取消居中即可，比较一下两种方式的显示异同： 设置好之后，接下来就是编写代码了，代码的工作原理大致是这样的： Sky1 和 Sky2 挨着放置在一起，同时往左移动，当左边那张图移出舞台的左边界后，马上移动到右边那张图后面，倒换顺序，继续滚动，如此循环以实现背景的无视差连续运动： 最终实现效果如上图，主要代码如下，这里我介绍了两个关键词： onready 和 $ ，用法我在注释中有说明： 12345678910111213141516171819202122232425# ...省略一些代码，和上一篇文章代码一样# onready关键词使变量在场景加载完后赋值，保证不为null# 效果和上一篇在 _ready() 方法中初始化一样onready var knight = self.get_node(\"Knight\")# 在Godot中$符号可以直接加子节点名字获得子节点对象# $Sky1相当于self.get_node(\"Sky1\")onready var sky1 = $Sky1onready var sky2 = $Sky2func _process(delta): # 移动背景天空位置，生成滚动动画 updateSkyAnimation(SKY_SPEED * delta) # ...省略一些代码# 移动背景天空位置，生成滚动动画func updateSkyAnimation(speed): # 移动，更新背景的位置 sky1.position.x -= speed sky2.position.x -= speed # 如果滚动到最左边，那么移动到右边来 if sky1.position.x &lt;= -1200: sky1.position.x += 2400 elif sky2.position.x &lt;= -1200: sky2.position.x += 2400 第三种方法：使用 AnimationPlayer 关键帧制作天鹅动画 第三种方法将下一篇： Godot3 游戏引擎入门之四：给主角添加动画（下）中介绍。 三、小结（上）好了，上部分的两种动画方式都已经介绍完毕，剩下第三种动画制作方法介绍先卖个关子吧，一次性阅读文章太长不好掌握，而且还附有不少源代码，所以留给下篇。 总结一下本篇讲解到的 Godot 3 中的知识点： 使用 AnimatedSprite 节点创建多个多图动画 使用 Sprite 节点和 GDScript 脚本代码创建背景动画 介绍了 Sprite 节点的原点设置：左上角或者居中 相关 GDScript 脚本知识：onready/$/position/animation 下篇继续，还是那句话：原创不易啊，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"游戏开发者的福音——电子书打包福利价","url":"/2018/09/20/get-bundle-of-game-development-books-with-big-discount/","text":"一、书籍和视频这几天在网上逛了逛，突然在 GameFromScratch 上发现有关 Game Development 的书籍打折，而且还是好多本一起打包促销，“定金”一看， Bundle 里有我喜欢的 Godot 书籍： Godot Engine Game Development Projects ，作者是 Kids Can Code 的创始人，我还专门上 CSDN （穷人首选免费的 ）搜索没找到这本书，国内貌似还没有相关资源，然后在京东上看到有此书销售，标价多少呢？ 180 大洋！我去，别开发游戏了，这“豪门”啊，入门太贵。 这不打折促销价格美丽，机会来了挡都挡不住，我赶紧到 Humble Bundle 上注册了账号，登录，添加到购物车，选择支付金额（对，土豪你可以多付款！），支付宝付款方式，扫码支付，一气呵成！总金额：￥ 103.68 ，这接近二十本书，总价格比京东上一本书的价钱还便宜。 除了 Godot 还有 Blender 以及 Unity 等相关书籍，也是我喜欢的，当然还有大名鼎鼎的 Unreal 引擎书籍和相关教学视频，加上 VR/AI/C# 、游戏编程最佳实践等，总共 18 本游戏开发书籍，以及 7 个相关教学视频！ 上面是我购买后的书籍列表，有三种格式可以下载： PDF/EPUB/MOBI ，下面列表是视频教学，大部分是 Unreal/Blender 相关： 打包价格 15 美元，人民币 103.68 元（人民币越来越贬值，速买），就说值不值？ 二、小插曲我在购买的过程中出了个小插曲：使用 Alipay 支付宝支付的时候对方居然没收到货款，所以我也一直没有收到订单号，我马上用邮件联系了客服。我是晚上买的，太平洋时间刚好是早晨，他们办公时间是太平洋时间早上 8 点，所以直到第二天我才收到回复，不过依然没有解决——他们也没有收到钱！ 庆幸的是第二天快中午的时候我收到了支付宝的退款，真是坑爹啊。接下来就是重新购买了，我依然选择支付宝，因为其他付款方式需要一定的手续费（费用不高），支付成功这次能正常跳转页面，愉快地查看订单！ 三、最后Wow, that’s a lot of value for $15! 直达链接：https://www.humblebundle.com/books/game-development-books PS: 我是不是要送出去几本？如果你有需要（非常中意哪本），刚好又在我的博客上看到了我的这篇博文，那加我微信好友吧（通过公众号可以留言），嘿嘿！ 视频的话，我也打算赠送，因为我粗略地浏览了一下 Unity 和 Blender 的视频教程，非常基础的入门教程，可以选择性地（因为文件比较大，还在考虑上传）送给刚入门的朋友（英语水平稍微要有点哦）。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"随笔 书籍"},{"title":"Godot3游戏引擎入门之三：移动我们的主角","url":"/2018/09/18/introduction-of-godot-3-part-3-move-character-with-inputs/","text":"一、前言说明：我目前使用的 Godot 3.1 预览版，所以会与 Godot 3 的版本有一些区别，界面影响不大，如果要使用我上传的 Github Demo 代码，记得去官网下载 3.1 预览版（或者等之后正版发布）然后就可以正常打开运行 Demo 了。 主要内容： Godot 2D 小游戏入门之使用键盘控制移动阅读时间： 4-5 分钟永久链接：http://liuqingwen.me/2018/09/18/introduction-of-godot-3-part-3-move-character-with-inputs/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 了解图片材质在 Godot 中的导入功能 创建简单的场景，调整节点渲染次序，给节点添加脚本 简单的 GDScript 脚本功能介绍和使用 创建场景首先是创建我们的游戏主场景，相比上一节，这个场景会更加简单，首先场景尺寸我在项目设置中设成了 600x600 ，添加一个 Node2D 节点作为根节点，并改名为 Game ，然后添加两个子节点，一个是我们的主角 Sprite 节点，命名为 Knight ，再添加一个 Sprite 节点作为游戏中的地面，单击，命名为 Ground ，接着修改相应的图片材质属性。这里的操作有几点需要注意： 1. 图片的导入 如果你滚动鼠标滚轮，放大我们的视窗，你会发现我们的主角：骑士的图片放大后有点模糊，这里我希望能像有些像素游戏一样能够清晰地显示图片各个像素（ 2D 游戏中一般叫完美像素： Pixel Perfect ），那样即使图片很小，像素化后依然显得更加逼真，如何在 Godot 中实现呢？非常简单， Godot 已经为我们预制好了，选中图片，在属性面板上方导入设置中进行相应的设置即可，非常简单，记得设置好之后一定要点击 Reimport 重新导入: 经过像素设置，我们的主角图像放大后像素更加清晰，是不是感觉更加 2D 了？熟悉 Unity 的同学知道，其 2D 场景是伪 3D 场景打造所以并没有 Pixel Perfect 功能。想深入了解 Godot 中更多关于图片压缩模式的知识，可以参考官方的压缩文档： Importing Images - Compression 2. 重铺图片导入 接着是地面的图片设置，还是使用上一节中的图片，之前我已经提到了如何设置普通图片材质的平铺属性，不过，之前的设置在重新打开后会丢失，如果保存平铺设置？我们需要在图片导入的时候进行相关的设置，保存并重新导入即可，相关设置如下图： 大致的步骤就是：先选中图片，启用 Repeat 功能，最后点击 Reimport 重新导入图片材质，接着选中地面 Ground 节点，开启图片的 Region 区域设置，设置高度和图片原高度相等，为 256 ，宽度设置为你想要的宽度，比如我设置的是 800 （或者更高）。最后你会发现我们的地面图片在宽度方向上会沿着 X 轴方向自动平铺， OK ，完美解决！ 3. 节点渲染顺序 有一个小问题是在我们添加了两个子节点后，移动位置，我们的场景显示是这样的： 主角干嘛躲在草丛后面啊？别怂，出来干啊！哈哈，其实原因在上图我已经说明了，这是由于 Godot 中节点的渲染顺序引起的，越在上面的节点，渲染顺序越前，所以下面的节点会最后渲染，造成的结果就是：可能会覆盖之前渲染的上面的一些节点。解决方案很简单，移动一下地面和主角节点的次序就可以了。 添加脚本简单的场景打造好了，接下来就是如何使用键盘输入控制骑士的位置移动了，学习 GDScript 脚本语言的最佳时机到来，本篇作为脚本开场白，仅仅做一个简单的介绍，然后编写代码实现一些简单的功能。 在了解 GDScript 脚本之前，我想比较一下 Godot 与 Unity 脚本的一些共同点，如果你有游戏开发经验，你会发现他们有很多相似点。首先，我们选中 Game 根节点，然后在右上角点击添加脚本，创建一个简单的脚本文件，写上一些方法（ # 号代表注释，和其他语言里的 // 一样）： 12345678910111213141516171819# 节点激活后运行该方法func _ready(): print('ready!')# 每帧运行此方法func _process(delta): print('process with delta time: ', delta)# 处理物理引擎的方法func _physics_process(delta): print('physics process with delta time: ', delta)# 处理设备输入的方法func _input(event): print('input event: ', event)# 处理设备输入的另一个方法func _unhandled_input(event): print('unhandled input event: ', event) 上面的代码通过方法名字和我的注释说明应该能明白它的含义了，现在看下 Unity 中 C# 脚本组件的语法： 1234567891011121314151617181920void Awake()&#123; Debug.Log(\"Awake\");&#125;void Start()&#123; Debug.Log(\"Start\");&#125;void Update()&#123; Debug.Log(\"Update: \" + Time.deltaTime);&#125;void LateUpdate()&#123; Debug.Log(\"LateUpdate: \" + Time.deltaTime);&#125;void FixedUpdate()&#123; Debug.Log(\"FixedUpdate: \" + Time.deltaTime);&#125; 惊人的相似，不是吗？所以说，开发游戏有时候只是软件不同，思路大体还是相同的，正所谓道不同、理相同！好的，装逼到此结束！开始拿起笔头编写脚本吧，这里我把基本完工的脚本贴出来，你可以从英文单词释义或者我的注释中得到每一行代码的功能是什么样的，具体如下： 12345678910111213141516171819202122232425262728293031323334# 继承于Node2Dextends Node2D# 常量，表示速度（像素）const SPEED = 200# 定义一些变量，不需要类型var maxX = 600 # 角色运动右边界var minX = 0 # 角色运动左边界var knight # 骑士节点# 节点进入场景开始时调用此方法，常用作初始化func _ready(): # 获取节点并赋值给变量knight knight = self.get_node(\"Knight\")# 每一帧运行此方法，delta表示每帧间隔func _process(delta): # Input表示设备输入，这里D和右光标表示往右动 if Input.is_key_pressed(KEY_D) or Input.is_key_pressed(KEY_RIGHT): moveKnightX(1, SPEED, delta) elif Input.is_key_pressed(KEY_A) or Input.is_key_pressed(KEY_LEFT): moveKnightX(-1, SPEED, delta) # 自定义函数，direction表示方向，speed表示速度，delta是帧间隔func moveKnightX(direction, speed, delta): if direction == 0: return # position属性为节点当前置，Vector2向量简单乘法 knight.position += Vector2(SPEED, 0) * delta * direction # 越界检测 if knight.position.x &gt; maxX: knight.position = Vector2(maxX, knight.position.y) elif knight.position.x &lt; minX: knight.position = Vector2(minX, knight.position.y) OK ，大功告成，运行我们的游戏，效果是这样的： 不过……有点问题啊：主角显然能置身于场景之外啊，而且往左移动的时候居然是迈克尔杰克逊附身——没有转身！别急，解决方法非常简单： 第一个：场景边界问题，在 _ready() 方法中的最后加入代码： 123# get_rect方法获取节点边框maxX -= knight.get_rect().size.x / 2minX += knight.get_rect().size.x / 2 第二个：左移转身问题，只需在 moveKnightX(...) 方法的最后加入代码： 123# 节点的scale属性为缩放矢量# 缩放矢量x值为1就是往右，-1表示往左缩放knight.scale = Vector2(direction, 1) 终于完工，尽管没有真正的角色跑步动作（后续文章会讲解如何使用 Godot 强大的动画工具创建角色动画），但是我们的移动功能算是完整了，看图，最终结果： 三、总结本篇讲解到的知识点： 图片材质的导入模式 节点渲染顺序 最基础的 GDScript 脚本入门 使用脚本获取节点属性，侦听输入控制主角移动 PS: 我使用的是 Godot 3.1 版本，源码已经上传到 Github ，如果需要在 Godot 3.0 版本上运行你可以自行创建节点，把图片和代码复制过去即可，建议使用最新 3.1 预览版，因为 3.1 即将发布！哦吼！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"给买笔记本的新手程序员学生的一点建议","url":"/2018/09/12/some-suggestions-on-buying-a-laptop-for-fresh-programmers/","text":"一、前言最近有同学问我关于买笔记本能否提供一些建议，据我所知，大部分的学生对笔记本硬件或者配置相关知识几乎是空空如也，如果去了电脑城，必定会在各种忽悠之间晕头转向。所幸的是，现在是二十一世纪，有京东、天猫、亚马逊、易迅等网上商城，价格品质服务一览无余，童叟无欺，还可以边看介绍边悠然地比下价格，不像我们八零后、七零后，不仅要承受高价格，还要承受各种忽悠，甚至不断在正品和水货之间徘徊，犹豫不决。 即便如此，面对众多的笔记本品牌，各式各样的高档配置，各种各样的折扣价格，结合自己的需求，我相信很多朋友还是会在选择面前左右为难。看来，要做一个选择对于初学者来说，还算是一个小难题，这里我必须声明的是我并不是什么笔记本大神，即使是，也被科技的日新月异所淘汰了，对市场同样也没有那么熟悉了，好在我对笔记本的一些配置，或者硬件系统还算是比较了解的。所以，从我个人的角度来说，我不能直接帮助任何一位决定最终选择，但是我可以给一些有效的建议吧。 首先申明一下我在提出建议之前，我的一些经验和局限之处： 从 06 年我的第一台联想笔记本（现在还在老家用着）到现在已有 12 年的笔记本电脑使用、拆机经验 十多年我用过的笔记本（真正属于我自己的）应该超过 50 台了，涵盖了大部分品牌，目前我手头在用的新旧笔记本有 7 台 尽管如此，我所用的几十台笔记本中几乎全是清一色的二手笔记本，新的电脑不过三台，所以在购买新笔记本上我肯定是欠缺经验的 对笔记本硬件我算是了如指掌，不过只限于 2016 年前，现在已经没有任何兴趣去了解这些了，不过老旧的经验还能凑合排上用场 我所使用的笔记本品牌包括：苹果、戴尔、联想、惠普、神舟、宏碁、华硕、明基，屏幕尺寸有： 14/15/17 寸 基于这几点，我把大家关心的热门话题分几个方面稍微讨论一下，尽力给出个大概的、有效的建议。 二、正文苹果还是其他 我算是见证了苹果（ Apple ）在中国的迅猛崛起。苹果手机无处不在，同时也带热了现在的苹果笔记本电脑（ Mac 操作系统 ），很多学生就是冲着苹果那高端大气上档次的逼格去的。不过，问题在买回来以后，有些新手发现在苹果笔记本上连个 java 环境变量和一个文本编辑器都找不着北。所以这个问题上，我的看法是： 首先你得承认，在中大型公司中，用苹果笔记本的绝对不是小数，苹果系统和 Linux 系统相比 Window 系统对程序员更加友好的，不过这是工作后的事情 如果你是学生，不玩游戏，又善于折腾，卡里存款数字优美，那么我推荐苹果笔记本是没错的：它轻便美观，对程序员也挺友好，而且续航时间给力 如果你还需要考虑玩游戏的话，那么其他因素暂时可以忽略了：放弃苹果，看看其他品牌吧！显卡性能、散热和轻薄外观必定是鱼和熊掌的关系 新品还是二手 如果我自己买笔记本电脑或者换笔记本的话，毫无疑问我会考虑二手（闲鱼上淘的多），一个原因肯定是因为价格便宜，另外追求性能的我升级更换笔记本会稍微频繁些，二手笔记比转手价格折损不大，相比新的就像手机等电器一样，前几年买的苹果 6 花了六千多，如今二手的闲置转手价值仅仅六七百，可见硬件更新换代之快！除此之外，还有一个很重要的因素就是：我对笔记本硬件的了解和拆装都特别熟悉。我买的二手笔记本很多都是空机，啥意思？就是说没有内存、硬盘之内，甚至有些笔记本 CPU 也可以更换升级（厚重的那些比如灵蛇、雷电、战神等显卡都可以更换），所谓家中常备内存条、固态硬盘，哈哈。 买二手一定要考虑出了问题怎么解决，所以也是我不推荐大部分学生直接购买二手本本的原因。目前我手头有一台苹果 Air ，去年键盘出了问题我就换过，你可能觉得换个键盘很容易，我告诉你，你说的那是其他品牌，在苹果笔记本上，键盘由 60 多个铆钉固定，拔铆钉都得花费几个小时，然后还要用合适的螺丝装上，你可以拆拆试试，为此我专门发表了一篇博文记录我更换苹果笔记本键盘的痛苦历程：修理更换苹果AIR笔记本键盘。 另外一方面，特别是对于大部分学生来说，售后服务也是一个非常重要的考虑要素，即使价格稍贵，但是花钱买的是服务，是多一份保险，出了问题不会修理的情况下可以快速直接找客服解决（戴尔有上门服务，不过是针对工作站和外星人系列）。这算是我的小建议。 性能还是散热 如果说笔记本有一个老生常谈的话题，那么我猜肯定是：性能 vs 散热这个热门话题了。买笔记本肯定要挑选性价比高的，而性价比就体现在硬件性能上，比如现在的笔记本 i3 的 CPU 都很少见了，低配也得选个 i5 是吧， i7 也贵不了多少。但是，别忽略了笔记本的散热功能：散热不良严重影响性能发挥！ 实际上，笔记本由于自身原因肯定会比台式机散热差，那么是不是不要考虑性能而应该根据散热好坏来挑选呢？也不完全对，我的建议是，大家在性能也就是配置方面没必要看得太重，一方面作为初学者来说根本就用不上那些高大上、耗内存、耗 CPU 的软件，相反一般的软件对性能需求是比较低的，配置一个 i3 的 CPU 加上个合格地显卡、固态硬盘、内存条配置平时用用都足够了，另一方面，可别忘了，大部分的笔记本是可以升级的！没错，买个低配，然后等性能不够用了，加个内存条，换个固态硬盘，让笔记本重焕生机，再战个三五年不成问题！ 既然散热好的笔记本那么有优势，怎么才知道哪款笔记本散热到底是好还是不好呢？这个问题算是难住我了，嗯，我的建议是，得在以下几个方面花点功夫了解下： 多去笔记本相关论坛了解你所感兴趣的某个品牌型号的笔记本关于散热方面的测试和评价 现场观察笔记本的外壳，购机时开启无数个程序然后查看 CPU 和显卡方面的温度报告 当然，不是说买个个散热好的笔记本就毫无后顾之忧了，至少每年需要清理灰尘和更换硅脂一到两次，否则散热再好，时间久了也是灰尘满满，温度飙飙！ 这个时候，考虑外观的同学就会犹豫了，毕竟越轻薄的笔记本散热越差，这没办法，鱼和熊掌不可兼得，但是也别担心，这里我建议注重外观，想购买轻薄笔记本的同学就没必要再挑选配置很高的型号了，一方面配置高的 CPU 、显卡发热量大，另一方面对于初学者来说，笔记本电脑一般都是性能过剩的，相信我，哈哈。 PS ：除了苹果笔记本，还有一款超薄推荐：微软的苏菲（ Microsoft Surface ），价格合适可以上。 国货不如人？ 什么时代了？都 21 世纪了，如果你还有这个观点，那我……只能说，哎哟，小伙不错哦。 这个问题在 10 年前也算个热门，我也认为国产笔记本确实有点那啥，不咋滴吧，但是现在是什么时代？我曾用过 17 寸的神舟战神系列笔记本电脑，它的做工甚至比我使用过的其他某些国外牌子还好（应该是蓝天代工制作）。当然，我并不是夸奖国产笔记本一定就很好，但是你要知道，即使是国产笔记本，它的 CPU 不依然是使用国外英特尔或者 AMD 的？独立显卡不还是 AMD 或者英伟达？所谓外表国产内心充满洋货啊。抬头看下你的苹果手机，它还是富士康制造的呢！哈哈。 游戏还是学习 这个话题我不就不讨论了，原因你懂的！告辞，不送~ 三、总结嗯，就这些吧，洋洋洒洒写了几百上千字，也没有什么实质性地建议，我觉得嘛，预算有限的同志，还是多去论坛了解以下，或者多听听有经验的朋友们的建议，多学点东西不是坏事啊。总结并附上我的一些建议： 笔记本大部分性能有剩余，考虑超薄再加散热过得去即可 配置的话， i5 够用，显卡能选择独立显卡更好，内存 8G 我看够用， 16G 绝对浪费 在过去十多年里，我个人认为笔记本的性能瓶颈在于硬盘的读写上，所以我是极力推荐直接上固态硬盘 品牌差别真心不大，配置相当下肯定可以考虑价格因素，别被所谓的高档货或者高配置忽悠了，另外还要注意售后 对了，有人问我自己的使用的电脑型号，我的是戴尔的工作站 M3800 （二手，无疑问），打算今年底更换成 M5510 ，戴尔、惠普的笔记本都有工作站系列，对性能有需求的朋友可以了解一下。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"随笔"},{"title":"Godot3游戏引擎入门之二：第一个简单的游戏场景","url":"/2018/09/11/introduction-of-godot-3-part-2-game-scene-and-node/","text":"一、前言最近工作时间安排地非常紧凑，除了周日一天，已经没有其他空闲时间了。不过到了 10 月份会慢慢恢复，目前我在抽出一点时间好好准备这个 Godot 系列，边写边学习边迎接 Godot 3.1 版本的到来，也算是一件高兴地事情，哈哈。 主要内容： Godot 2D 小游戏入门之场景和节点创建阅读时间： 6-8 分钟永久链接：http://liuqingwen.me/2018/09/11/introduction-of-godot-3-part-2-game-scene-and-node/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文本篇目标 学习场景的创建和基本设置，游戏的运行，第一个小 Demo 了解几个基本节点的相关功能： Node2D/Sprite/RigidBody2D/CollisionShape2D/ 丰富我们的小游戏场景，学习静态物体和刚体碰撞以及 Debug 功能 创建场景我们的目标是在 Godot 中创建一个物理小世界，做个碰撞小测试。相关的图片资源和最终项目我会上传到 Github ，算是第一个小 Demo 吧。 第一步：首先是进行一个视窗设置，游戏最终窗口大小。在菜单栏 -&gt; Project -&gt; Project Settings -&gt; General 下，选择 Display -&gt; Window -&gt; Size 下设置宽度和高度，如果找不到设置选项可以点击搜索，我这里设置的是 600 x 1000 ，根据自己的需求随意设定，另外我们还可以设置游戏的视口（ viewport ），这里暂时不设置，后续文章我再详谈。 第二步：如果你现在急着运行的话， Godot 会提示你没有选择初始场景入口，所以我们先要在场景中创建一个主节点。在节点窗口添加一个根节点，你可以选择 Node ，也可以选择 Node2D ，甚至其他节点都没关系。还记得上一篇我介绍过的吗？ Node 是 2D 和 3D 节点的共同父节点，所以 2D 游戏场景中使用 Node 作为父节点没任何问题。我这里选择的是 Node2D ，接着单击命名为 Game ，保存场景为 Game.tscn ，然后按 F5 运行，选择刚保存的 Game 场景作为游戏启动入口，确定运行。 第三步：在上一步完成后游戏运行我们知道啥都没有是因为场景中只有一个空的根节点。是时候添加一些游戏元素了，这就是 Godot 中丰富的节点体系。我们要做一个自由落体小 Demo 。简单描绘一下：有一个地面作为静态物体，做一个球体从空中自由落下，观察碰撞情形。非常非常简单，是不是？如何在 Godot 中实现呢？有两种方式，如下： 第一种方式： 在场景中添加一个 Sprite 作为圆球显示载体（把属性 Texture 设置为圆球图片），既然我们需要做自由落体，那么也就是需要一个刚体，所以我们给 Sprite 添加刚体属性，如果你学过 Unity 的话，那么你会很熟练地在对应的 GameObject 上添加一个 Rigidbody2D Component ，即所谓的刚体组件，然后设置刚体的质量、弹力、角速度等，在 Godot 中理论是一样的，但是实现却不一样，我们实现刚体特性是通过添加其他功能子节点来实现父节点的相关特性的。这里我们选中 Sprite 节点，按 Ctrl+A 快捷键添加一个 RigidBody2D 节点，接着出现一个警告小三角，点击它会有如下提示： 意思很清楚，就是告诉你， RigidBody2D 刚体节点没有碰撞形状节点是不能进行正常物理交互的！解决这个问题很简单，给 RigidBody2D 添加一个 CollisionShape2D 的子节点就 OK 了，这时候你会发现另一个警告： 同样的道理， CollisionShape2D 也需要一个实实在在的形状来进行碰撞交互，这个形状的创建非常简单，选择 CollisionShape2D ，在它的属性面板里的 Shape 属性下点击选择 New CircleShape2D 创建一个圆形碰撞体，场景中立刻出现一个蓝色的圆，这个圆就是用于物理交互的碰撞体，碰撞体形状默认大小很小，我们可以点击 Shape 里刚才创建的这个圆形碰撞体进入 CircleShape2D 的详细设置面板，然后设置半径 Radius 为 28 就差不多和圆形 Sprite 大小相当了。 第一种方案算是完成了，运行游戏，结果出乎意料？圆球纹丝不动！什么原因呢？是不是没设置重力或者质量？哈哈，别急，卖个关子，看了第二种方案你就会理解了。 第二种方式 Godot 中的节点非常强大，而且又不失灵活性！既然 RigidBody2D 表示的就是刚体，而 Sprite 仅仅只是作为一个图片显示的载体，那我们是不是可以把 Sprite 作为 RigidBody2D 的子节点而提供图片显示作用，而 RigidBody2D 作为父节点提供真实的物理交互功能呢？按此理论，我们开启第二种方式。 在第一种方式的基础上，我相信大家对添加节点的操作应该比较熟悉了，直接 Ctrl+A 添加相关的节点，这里要注意的是： RigidBody2D 节点和刚才我们第一种方法中的 Sprite 节点都是场景 Game 根节点的直接子节点，平起平坐，添加的时候别弄错了。 添加设置完节点后，为了区分两种不同的方式，我分别移动了他们的位置，你也可以直接在属性面板里设置两个父节点 Sprite 和 RigidBody2D 的 Transform/Position 位置的值，记住一定是父节点，别弄错了！结果如图： 经过两种方案后，我想你应该已经知道第一种方案不可行的原因了吧！没错，正是由于 Sprite 并不会因为有一个 RigidBody2D 子节点而改变图片渲染位置，虽然子节点的位置受重力的影响会移动，而在第二个方案里， Sprite 作为 RigidBody2D 的子节点，父节点位置发生变化， Sprite 子节点相应跟随运动。如何证明？这里我们可以使用 Godot 强大又舒爽的 Debug 功能一探究竟：选择菜单栏的 Debug 菜单，勾选 Visible Collision Shape ，然后运行，效果一目了然！ 丰富场景这个 Demo 虽小，但是到此为止的话，那就有点无趣了，由于是自由落体运动，球体会永无禁止地运动下去！如何让它们落地呢？很简单，给我们的小游戏添加一个带碰撞体的地面就 OK 啦！ 这里要说明的是，地面（静态）和刚体都具有碰撞物理特性，但是他们关键点在于：地面的碰撞体是静态的！所以这里我们使用 StaticBody2D 作为父节点，然后添加一个 Sprite 图片作为显示渲染载体，制作一个简单的平铺地层。并没有什么难度，唯一要提醒的是怎么让我们的地面实现水平平铺（ Repeat-X ）以及使用 SegmentShape2D 作为静态碰撞体的交互形状，关于设置直接看图介绍吧： 完成后，最终的效果如下： 最后的最后，我在地面碰撞体背景中使用的是 SegmentShape2D 而非 LineShape2D ，原因可以引用官方文档的解释，并在此建议大家在单向直线碰撞体中优先使用 SegmentShape2D 吧： LineShape2D: Line shape for 2D collisions. It works like a 2D plane and will not allow any body to go to the negative side. Not recommended for rigid bodies, and usually not recommended for static bodies either because it forces checks against it on every frame.SegmentShape2D: Segment shape for 2D collisions. Consists of two points, a and b. 总结本篇讲解到的知识点： 几个基本的节点添加和使用 刚体碰撞体设置 静态碰撞体设置 材质背景平铺设置 可视化 Debug 功能 本篇没有使用任何代码，仅仅利用 Godot 丰富的节点系统就完成了这个小 Demo ，算是入门中的入门吧，在后续文章中我会详细说明使用 GDScript 代码来加强和丰富我们的游戏功能。嗯，估计新手朋友们早就想跃跃欲试了吧，你完全可以尝试给节点添加代码，实现一些基本的功能，其实 GDScript 非常简单，如 Python 兄弟般，嘿嘿。 三、其他嗯，这次就这些，我本意是希望阅读我的文章的朋友们（特别是初学者）能有不错的收获，我也会尽量做到吧，当然，第一次做这种系列的文章，难题和问题在所难免，还请大家多多包涵，多多提出意见和建议，非常感谢！附上 Demo 的 Github 地址： https://github.com/spkingr/Godot-Demos 。 好吧，下次继续，还是那句话：原创不易啊，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"Godot3游戏引擎入门之一：熟悉编辑器界面","url":"/2018/09/03/introduction-of-godot-3-part-1-the-editor/","text":"一、前言Godot 3.1 第一个 Alpha 预览版本已经发布，预览版所有的新特性都已敲定，激动人心，就等着稳定的正式版了！大家可以去官网一探究竟：DEV SNAPSHOT: GODOT 3.1 ALPHA 1 。 本篇内容： Godot 入门之编辑器相关介绍阅读时间： 5 分钟永久链接：http://liuqingwen.me/2018/09/03/introduction-of-godot-3-part-1-the-editor/系列主页： http://liuqingwen.me/introduction-of-godot-series/ 二、正文关于下载Godot 非常小，我下载的 64 位 Windows 版本总大小不到 40M ，官网下载页面直达： https://godotengine.org/download ，下载 zip 包后解压无需安装，直接使用，不过这里有三件小事情我要告诉大家： 下载对应的版本还有发布模板： Godot 支持多个操作系统，注意对应的系统以及架构（ 32 位或者 64 位操作系统），然后就是发布模板（ Export Templates ），这个在下载页面的下方可以找到，当然刚开始使用 Godot 玩玩的时候是没必要下载的，当你需要发布最终产品到 Windows/Mac/iOS/Android 等平台的时候你再下载也不迟，后面的文章我应该会提到模板使用。 配置文件夹位置：如果你直接打开 Godot.exe ，那么它的配置文件默认生成在 C 盘目录下（我使用的是 Win10 系统），但是你可以随时改回来，只需要在 Godot 软件文件夹下创建一个 _sc_ 的文件即可，后面我有截图说明。 分辨率设置：如果你和我一样使用的是 4K 高分显示屏幕，那么你在打开 Godot 编辑器后需要进一步设置，这个现在提出来，等会介绍编辑器的时候我有截图作具体介绍。 另外，在官网你会发现一个名为： MONO VERSION (C# SUPPORT) 的下载链接，这个是支持使用 C# 语言来进行游戏编程的，我没怎么使用，看官方介绍，我的建议是没必要下载这个版本，一方面它需要 MONO 的支持，而且 C# 支持现在还不是特别稳定（够用级别吧），另一方面，我觉得 Godot 的脚本语言 GDScript 非常简单，比 Python 还简单没压力，后续文章我会专门介绍。 OK ，双击 exe 文件，开始那愉快的 Godot 之旅吧，骚年！ 界面介绍首先是开场白 打开 Godot 第一眼是很普通的项目控制面板，这里可以设置编辑器的显示语言： 选择创建一个游戏，或者打开已存在的游戏，也可以下载官方的 Demo ，双击进入编辑器主界面： Godot 的主界面很普通，用过 Unity 或者类似工具软件的朋友都不会感觉到陌生。 Godot 默认打开的是 3D 场景，可以通过上方的菜单进行切换，我推荐使用快捷键： 2D场景 -&gt; F1 ， 3D 场景 -&gt; F2 ， Script 脚本窗口 -&gt; F3 ， Help 搜索帮助 -&gt; F4 。 开工前设置 如果你打开 Godot 窗口，发现字体很小，那很正常，因为我们没有设置过字体大小，可以在编辑器 -&gt; 编辑器设置菜单下进行设置： 另外，如果是 4K 高分辨率屏幕，当你迫不及待地添加一个 Node 节点，然后保存，运行，选择刚才保存的场景，游戏开始，你会发现你的窗口不会出现在屏幕的正中央位置，而是右下方，看起来很不舒服，这是因为你没有开启 HIDPI 设置，别急，只需要在项目 -&gt; 项目设置里设置就可以了： 勾选 HiDPI 然后运行你的游戏，就会显示在屏幕正中央了，如果不是 4K 高分屏这一步没必要。 节点和场景 在尝试运行游戏之前，你得创建一个入场场景，然后保存，接着设置为启动场景才能正常运行。添加节点非常简单，在节点窗口上方有个 + 号，点击它，或者直接快捷键更方便： CTRL + A ，会弹出很多预制节点供您选择： 注意， Node 是所有节点的父节点，你可以使用它来作为场景的根节点（ Root ），因为它既是 2D 节点的父节点，又是 3D 节点的父节点，所以你甚至可以使用 Node 来混合 2D 和 3D 游戏节点！当然，我更建议直接使用相对应的节点： Node2D 表示所有 2D 节点的父节点， Spatial 为所有 3D 节点父节点，而 Control 为所有控件的父节点。 除此之外，你会发现，他们都有一套自己的颜色，比如 2D 节点图标是淡蓝色， 3D 节点是粉红色，控件则为绿色，还有一个，深入一点你就会发现，很多 2D 节点名字都对应一个 3D 节点，下面列举几个： 3D 节点 2D 节点 节点名 Camera Camera2D 相机 Light Light2D 灯光 Particles Particles2D 粒子 Area Area2D 碰撞区域 KinematicBody KinematicBody2D 物理学物体 StaticBody StaticBody 静态物体 RigidBody RigidBody2D 刚体 CollisionShape CollisionShape2D 碰撞体形状 Path Path2D 路径 如上图，你还可以直接通过搜索，更加方便的添加你所需要的节点。在 Godot 中一切基于节点，甚至 Timer 都是一个节点，所以它必须添加到节点树中才能正常使用，这些后续会提到。 属性面板和子菜单 我添加了一个 Node2D 作为场景的根节点，单击命名为 Game ，然后在 Game 根节点下添加一个子节点，可以直接 CTRL + A 来添加，这里我是直接把资源窗口中的 Logo 图片直接拖拽到了场景中，选择 Sprite 创建一个精灵： 这个时候，右边场景中就会自动创建一个 Sprite 节点，选中这个节点，右下角就是这个节点对应的属性面板，你会发现， Sprite 的 Texture 属性已经自动设置为刚才拖拽的那张 logo 图片了。同时，你会发现在场景的下方多了一个菜单项： Texture Region 材质区域的编辑区，这就是对应该节点的底部栏操作面板，在后续的文章中，介绍动画的时候会经常用到这里的编辑区和菜单。 如图，注意场景上方，额外有些子菜单可以进行操作，这些子菜单非常重要，后续对很多节点都会使用到，我这里列举几个类型节点对应的子菜单，如图： 软件界面大概就这些了，常用的功能都应该差不多介绍到位了吧。 编程语言在本系列的第一篇文章中，我说过如果你曾经是 Adobe Flash 的开发者，那么你对 Godot 中一个节点绑定一个脚本的约定会感觉非常熟悉。选择一个节点，在上方的右上角，一个带 + 号的书本按钮，点击便可以给相应节点添加脚本： 注意：在打开的脚本编辑器里，也有对应的脚本菜单。另外， Godot 非常贴心的一点是，你随时可以按 F4 呼出帮助，然后搜索你想要了解的 API ，查看相关属性和方法，这对新手来说，简单不要太爽啊！ 关于脚本语言编程和使用，这个是一个很长的话题了，暂且到此吧，不过我觉得只要有点编程基础的朋友在 GDScript 脚本上是很容易上手的。后续我必须出个专门的文章，专门介绍一下 GDScript 脚本吧。 三、其他这次就说到这里，大家感觉这个游戏怎样？“什么？什么游戏？”哈哈，偷偷告诉你， Godot 编辑器本身也是由 Godot 引擎打造的一个游戏： Godot’s Engine is a Godot Game itself! ，惊不惊喜，意不意外？ 本章完结，下次继续，原创不易啊，希望大家喜欢！ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"【翻译】忘了RxJava吧——你需要的是拥抱Kotlin协程（Part 1/2）","url":"/2018/08/31/translation-of-forget-rxjava-kotlin-coroutines-are-all-you-need-part-1-of-2/","text":"一、前言我非常喜欢 Kotlin ，也非常喜欢 Kotlin Coroutines 协程，在看到了这篇文章后心里真是激动啊！于是乎——就有了这篇谷歌自动人工翻译，以飨观众！希望大家喜欢。哈哈。 作者：Vladimir Ivanov阅读时间： 4 分钟原文链接：https://proandroiddev.com/forget-rxjava-kotlin-coroutines-are-all-you-need-part-1-2-4f62ecc4f99b 二、正文嗨！ RxJava 确实是一项令人惊奇的技术，特别是对于 Android 应用程序开发人员来说，它在这几年里为我们提供了完全不同的开发体验，它省去了那些无穷无尽的 AsyncTasks ， Loaders 和其他工具的烦恼，代替的是简洁而又直白的函数式风格代码。 举个例子，使用 RxJava 来创建一个 GitHub API 的相关应用程序，里面的网络层接口一般如下所示： ApiClientRx.kt hosted with ❤ by GitHub1234567interface ApiClientRx &#123; fun login(auth: Authorization) : Single&lt;GithubUser&gt; fun getRepositories(reposUrl: String, auth: Authorization) : Single&lt;List&lt;GithubRepository&gt;&gt; fun searchRepositories(query: String) : Single&lt;List&lt;GithubRepository&gt;&gt;&#125; 虽然 RxJava 是一个功能非常强大的库，但这并不意味着它就一定要作为管理异步工作的工具。它只是一个事件处理库。 我们通常使用 Single 来表示网络层操作的结果，得到的结果要么是某个值或者获取失败。 在 activity/fragment 中使用上面那个接口的代码一般如下所示（稍后我会考虑对它进行单元测试）： Activity.kt hosted with ❤ by GitHub1234567891011121314151617181920private fun attemptLoginRx() &#123; val login = email.text.toString() val pass = password.text.toString() val auth = BasicAuthorization(login, pass) val apiClient = ApiClientRx.ApiClientRxImpl() showProgressVisible(true) compositeDisposable.add(apiClient.login(auth) .flatMap &#123; user -&gt; apiClient.getRepositories(user.reposUrl, auth) &#125; .map &#123; list -&gt; list.map &#123; it.fullName &#125; &#125; .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doAfterTerminate &#123; showProgressVisible(false) &#125; .subscribe( &#123; list -&gt; showRepositories(this@LoginActivity, list) &#125;, &#123; error -&gt; Log.e(\"TAG\", \"Failed to show repos\", error) &#125; ))&#125; 这段代码看起来或多或少还是可以理解的，但是这里有几个隐藏的缺陷： 性能开销问题 这段代码的每一行都会生成一个内部对象（或者好几个）来完成这项工作。当前代码下，它产生了 19 个对象。想象一下，在更复杂的情形下这个数字会变成多少。 堆栈信息可读性差 假设你在代码中犯了一个错误，或者疏忽了某些情形判断，然后这些问题在产品的质量检查期间并没有被发现，之后产品投入生产。现在，你的产品崩溃报告打印出了一堆堆栈跟踪信息： 12345678910111213141516at com.epam.talks.github.model.ApiClientRx$ApiClientRxImpl$login$1.call(ApiClientRx.kt:16)at io.reactivex.internal.operators.single.SingleFromCallable.subscribeActual(SingleFromCallable.java:44)at io.reactivex.Single.subscribe(Single.java:3096)at io.reactivex.internal.operators.single.SingleFlatMap.subscribeActual(SingleFlatMap.java:36)at io.reactivex.Single.subscribe(Single.java:3096)at io.reactivex.internal.operators.single.SingleMap.subscribeActual(SingleMap.java:34)at io.reactivex.Single.subscribe(Single.java:3096)at io.reactivex.internal.operators.single.SingleSubscribeOn$SubscribeOnObserver.run(SingleSubscribeOn.java:89)at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:463)at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)at java.util.concurrent.FutureTask.run(FutureTask.java:266)at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)at java.lang.Thread.run(Thread.java:764) 很酷啊，整个堆栈信息就来自你那代码里的一行！ 陡峭的学习曲线 你还记得花了多少时间来理解 map() 和 flatMap() 之间的区别吗？更别说其他成千上万的操作符了。时间开销是每个新手开发人员学习进入响应式编程世界所必需面对的。 可读性 代码可读性是可以的，但是我们还是传递了并不能代表我们普通思维模型的回调函数（我们是按顺序进行思考的）。 如果Kotlin Coroutines可以让我们的生活更美好，那会怎么样？首先让我们来看下我们是否可以替换 Single 这个对象。在协程的世界里，最合适的对象就是 Deferred 接口了。它看起来长这样子的： Deferred.kt hosted with ❤ by GitHub1234567891011public actual interface Deferred&lt;out T&gt; : Job &#123; public suspend fun await(): T&#125;interface Job : CoroutineContext.Element &#123; public val isActive: Boolean public val isCompleted: Boolean public val isCancelled: Boolean public fun getCancellationException(): CancellationException public fun start(): Boolean&#125; 这里，使用我们的 ApiClient 接口进行一个简单的重构，结果如下： ApiClient.kt hosted with ❤ by GitHub123456interface ApiClient &#123; fun login(auth: Authorization) : Deferred&lt;GithubUser&gt; fun getRepositories(reposUrl: String, auth: Authorization) : Deferred&lt;List&lt;GithubRepository&gt;&gt;&#125; 实现部分也会相应地做出改变：我们需要将 Single.fromCallable 替换为协程构建器。 async 在这里派上用场： ApiClientImpl.kt hosted with ❤ by GitHub123456789101112override fun login(auth: Authorization) : Deferred&lt;GithubUser?&gt; = async &#123; val response = get(\"https://api.github.com/user\", auth = auth) if (response.statusCode != 200) &#123; throw RuntimeException(\"Incorrect login or password\") &#125; val jsonObject = response.jsonObject with (jsonObject) &#123; return@async GithubUser(getString(\"login\"), getInt(\"id\"), getString(\"repos_url\"), getString(\"name\")) &#125;&#125; 您应该知道，使用 RxJava 需要您为异步代码的运行选择 Scheduler 调度，在协程代码中，类似的实体称为 Dispatcher 派发器。默认情况下， async 和 launch 协程构筑器是使用 CommonPool 这个派发器，当然您可以传递任何其他派发器。 OK ，让我们来看看修改后的客户端代码： Login.kt hosted with ❤ by GitHub123456789101112131415job = launch(UI) &#123; showProgressVisible(true) val auth = BasicAuthorization(login, pass) try &#123; val userInfo = login(auth).await() val repoUrl = userInfo.reposUrl val repos = getRepositories(repoUrl, auth).await() val pullRequests = getPullRequests(repos[0], auth).await() showRepositories(this, repos.map &#123; it -&gt; it.fullName &#125;) &#125; catch (e: RuntimeException) &#123; Toast.makeText(this, e.message, LENGTH_LONG).show() &#125; finally &#123; showProgressVisible(false) &#125;&#125; 哇塞！代码变得如此的清晰、符合直觉！这看上去根本没有产生异步嘛 :) ，顺便说一下，在 RxJava 版本中，我们把订阅器添加到 compositeDisposable 中以方便在 onStop() 中调用它的 dispose() 方法。在协程版本中，我们保存为 job ，然后在同一个地方调用 job.cancel() 方法。请继续关注我即将发表的文章中有关生命周期和协程的更多信息！ 那么关于我们在 RxJava 代码中找到的那些缺点去哪了呢？在协程中都解决了吗？ 性能开销问题 协程代码产生的对象数量下降到了 11 （下降了三分之一）。 堆栈信息可读性差 堆栈跟踪信息还是有些无关，但问题已经在解决当中了。 可读性 代码更易于阅读和编写了，这是由于异步代码是使用同步方式编写出来的。 我该如何重构单元测试？使用 RxJava ，我们使用以下代码做单元测试： ApiClientRxTest.kt hosted with ❤ by GitHub1234567891011121314151617@Testfun login() &#123; val apiClientImpl = ApiClientRx.ApiClientRxImpl() val genericResponse = mockLoginResponse() staticMockk(\"khttp.KHttp\").use &#123; every &#123; get(\"https://api.github.com/user\", auth = any()) &#125; returns genericResponse val githubUser = apiClientImpl.login(BasicAuthorization(\"login\", \"pass\")) githubUser.subscribe &#123; githubUser -&gt; Assert.assertNotNull(githubUser) Assert.assertEquals(\"name\", githubUser.name) Assert.assertEquals(\"url\", githubUser.reposUrl) &#125; &#125;&#125; 在这里我使用的是 KHttp 和 mockk 。 使用 Kotlin 协程，测试代码如下： ApiClientTest.kt hosted with ❤ by GitHub1234567891011121314151617@Testfun login() &#123; val apiClientImpl = ApiClient.ApiClientImpl() val genericResponse = mockLoginResponse() staticMockk(\"khttp.KHttp\").use &#123; every &#123; get(\"https://api.github.com/user\", auth = any()) &#125; returns genericResponse runBlocking &#123; val githubUser = apiClientImpl.login(BasicAuthorization(\"login\", \"pass\")).await() assertNotNull(githubUser) assertEquals(\"name\", githubUser.name) assertEquals(\"url\", githubUser.repos_url) &#125; &#125;&#125; 测试代码没有太大的改变——我们删除了订阅函数调用，添加了 runBlocking 协程构建器——这样我们的测试就不会在测试代码还没有完全运行完之前提前退出了。 是否有进一步的改进呢？当然有了。我们可以在我们的业务逻辑对象中抛弃任何包装器，不需要返回 Deferred 包装对象，假装没有任何实际的异步操作发生。在这里，我们使用 suspend 修饰符来替换 Deferred 对象： SuspendingApiClient.kt hosted with ❤ by GitHub1234567interface SuspendingApiClient &#123; suspend fun login(auth: Authorization) : GithubUser suspend fun getRepositories(reposUrl: String, auth: Authorization) : List&lt;GithubRepository&gt; suspend fun searchRepositories(searchQuery: String) : List&lt;GithubRepository&gt;&#125; 哇塞！你难道不喜欢变得如此干净利落的界面吗？我已经做了很多了。让我们来看看我们的客户端代码和测试变化后的样子： Login.kt hosted with ❤ by GitHub12345678910111213141516171819private fun attemptLoginSuspending() &#123; val login = email.text.toString() val pass = password.text.toString() val apiClient = SuspendingApiClient.SuspendingApiClientImpl() job = launch(UI) &#123; showProgressVisible(true) val auth = BasicAuthorization(login, pass) try &#123; val userInfo = async(parent = job) &#123; apiClient.login(auth) &#125;.await() val repoUrl = userInfo.repos_url val list = async(parent = job) &#123; apiClient.getRepositories(reposUrl, auth) &#125;.await() showRepositories(this, list.map &#123; it -&gt; it.fullName &#125;) &#125; catch (e: RuntimeException) &#123; Toast.makeText(this, e.message, LENGTH_LONG).show() &#125; finally &#123; showProgressVisible(false) &#125; &#125;&#125; 代码看起来好像只是添加了 async(parent = job) {} 的调用而已。其余的部分保持不变。 在这里传递父对象是必须的，这是为了能在 onStop() 中取消 job 的同时取消协程运行。 另外，我们可以用一种更奇幻的方式测试我们的 presenter ： SuspendingLoginPresenterTest.kt hosted with ❤ by GitHub123456789101112131415@Testfun testLogin() = runBlocking &#123; val apiClient = mockk&lt;SuspendingApiClient.SuspendingApiClientImpl&gt;() val githubUser = GithubUser(\"login\", 1, \"url\", \"name\") val repositories = GithubRepository(1, \"repos_name\", \"full_repos_name\") coEvery &#123; apiClient.login(any()) &#125; returns githubUser coEvery &#123; apiClient.getRepositories(any(), any()) &#125; returns repositories.asList() val loginPresenterImpl = SuspendingLoginPresenterImpl(apiClient, CommonPool) runBlocking &#123; val repos = loginPresenterImpl.doLogin(\"login\", \"password\") assertNotNull(repos) &#125;&#125; 在第 7 行，我们使用 suspend 修饰符 mock 我们的函数，以立即返回业务对象。 对于那些使用 Mockito 的朋友来说， mock 一个挂起函数的代码是这样的： 12345given &#123; runBlocking &#123; apiClient.login(any()) &#125;&#125;.willReturn (githubUser) 相比 mockk 还是有点丑陋的，不过效果一样。在这里使用 runBlocking 是作为一个协程构建器，它能阻塞协同程序运行的所在线程。在这里查看更多。 概要好吧，在这里我们设法重构一些使用了 Singles 的代码，替换为 Kotlin 协程并从中感受到一些好处。在此系列的下一章节中，我们将考虑使用协程来处理比 RxJava 更高级的一些主题。 如果您喜欢这篇文章，请在 推特 上和我打个招呼吧。关于 Kotlin/Android 的更多通知和一些其他想法都在那里了。 三、其他利用谷歌翻译总算翻译完了，不知道这个文章的代码你是否 get 到了呢？ 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"kotlin android 翻译"},{"title":"【翻译】MotionLayout实现折叠工具栏（Part 2）","url":"/2018/08/27/translation-of-motionlayout-collapsing-toolbar-part-2/","text":"一、前言本篇是续集，第一篇翻译直达链接：【翻译】MotionLayout实现折叠工具栏（Part 1） 本文特点：没有 Kotlin/Java 代码，讲解部分全为 XML 代码，阅读时间短，获取技能： MotionLayout 的入门和使用！发布时间： 8 月 17 号 ，作者： Mark Allison ，原文链接： https://blog.stylingandroid.com/motionlayout-collapsing-toolbar-part-2/ 二、正文谷歌 IO 2018 发布了 ConstraintLayout 2.0 版本，其中最重要的部分就是 MotionLayout 了，这玩意就是一个全新的、超牛的布局动画工具！ Nicolas Roard 哥们早已发布了一个关于 MotionLayout 的完美详情介绍，我强烈推荐大家去阅读一下，从中理解 MotionLayout 组件的基础架构。本系列教程中，我会讲解如何使用 MotionLayout 来创建一个我们已经非常熟悉的动画行为：一个折叠工具栏动画（ a Collapsing Toolbar ）。 通过上一篇文章我们了解了基本的折叠工具栏动画行为，使用的是 MotionLayout ，第一次尝试的效果与在 CoordinatorLayout 中使用 CollapsingToolbarLayout 的效果非常接近。不过有一个细微的小动画在 MotionLayout 中没有实现出来。移动和缩放动画在文字上表现确实已经非常接近，但是背景图片的渐变在最边缘上却没有完全相同。让我们先看下 CoordinatorLayout 版本的实现效果，注意图片在工具栏几乎快要完全折叠之前是不会开始渐变到主色彩动画的： 现在我们看看 MotionLayout 的实现，我们会发现图片渐变在整个过渡动画中是统一稳定的。也就是说：随着工具栏折叠动画的开始，图片便立刻发生渐变，一直持续到工具栏完全到达折叠状态： 这个问题实际上很容易解决，这要感谢 MotionLayout 的另一个非常重要的特性：关键帧。我们已经讨论过 MotionLayout 是如何在 ConstraintSets 中所定义的固定布局之间进行过渡动画了。而关键帧允许我们在两个固定布局之间定义一个中间点，并对此点的属性值进行操作控制。 我们之前在 ImageView 控件上定义的关于 imageAlpha 属性的过渡动画，设定的是从展开位置的值 255 到折叠位置的值 0 之间进行，同时 MotionLayout 在动画过程中会进行插值运算。因此我们得到的是一个非常平滑的过渡动画，从工具栏开始发生折叠一直到工具栏完全达到折合状态为止。这也很好的解释了我们所看到的在 MotionLayout 中对动画行为的实现。 利用关键帧特性我们甚至可以做到修改相关的行为动画，使得这些行为动画时间在整个过渡动画中往后延迟。为了实现这个目标，我们首先需要在展开状态 ConstraintSet 的定义中删除自定义属性 imageAlpha 字段： res/xml/collapsing_toolbar.xml1234567&lt;ConstraintSet android:id=\"@+id/expanded\"&gt; &lt;Constraint android:id=\"@id/toolbar_image\" android:layout_height=\"200dp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; 同时也需要在折叠状态 ConstraintSet 的定义中进行同样的操作： res/xml/collapsing_toolbar.xml1234567&lt;ConstraintSet android:id=\"@+id/collapsed\"&gt; &lt;Constraint android:id=\"@id/toolbar_image\" android:layout_height=\"?attr/actionBarSize\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; 这样同时把透明度的渐变动画一起删除了，不过接下来我们会使用一个 KeyFrameSet 来代替它，这个关键帧设置 KeyFrameSet 字段是作为过渡元素的一个子元素： res/xml/collapsing_toolbar.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;Transition app:constraintSetEnd=\"@id/collapsed\" app:constraintSetStart=\"@id/expanded\"&gt; &lt;OnSwipe app:dragDirection=\"dragUp\" app:touchAnchorId=\"@id/recyclerview\" app:touchAnchorSide=\"top\" /&gt; &lt;KeyFrameSet&gt; &lt;KeyAttribute app:framePosition=\"60\" app:target=\"@id/toolbar_image\"&gt; &lt;CustomAttribute app:attributeName=\"imageAlpha\" app:customIntegerValue=\"255\" /&gt; &lt;/KeyAttribute&gt; &lt;KeyAttribute app:framePosition=\"90\" app:target=\"@id/toolbar_image\"&gt; &lt;CustomAttribute app:attributeName=\"imageAlpha\" app:customIntegerValue=\"0\" /&gt; &lt;/KeyAttribute&gt; &lt;/KeyFrameSet&gt; &lt;/Transition&gt; ...&lt;/MotionScene&gt; 这里 KeyFrameSet 包含了两个 KeyAttribute 字段，每一个字段分别定义了指定位置下的一个状态，第一个位于第 60 帧，也就是说整个过渡动画过程中的 60% 的位置，而第二个在 90 的位置，同样的道理，这意味着位于过渡动画的 90% 的位置。这两个字段通过设置 ID 分别指定作用目标控件对象（在这里两个字段都是指定的 @id/toolbar_image ）。每一个字段还定义了一个 CustomAttribute 元素，它的意思和我们之前在开头、结尾状态中定义的意思是一样的。 目前来说，发生的情况是：图片的透明度在过渡动画还没有达到 60% 之前是不会发生变化的（也就是至少超过一半的折叠状态下不发生变化），接下来会慢慢开始淡出，直到工具栏达到 90% 折叠时完全透明。 现在已经更加接近我们所见到的 CoordinatorLayout 所实现的标准动画了。不过仍然并非完全一样，但是至少我们能看到，通过这种方式我们可以取得对动画过渡的更好的控制权，如果使用 CoordinatorLayout 来进行这样的调整那会非常的麻烦。 事实上关键帧是非常非常强大的， Nicolas Roard 已经对此作了一个深入介绍。我们在此不会重复 Nicolas Roard 所介绍的那样，相反我们来尝试一些其他的方式并投入使用。 首先我们并不局限于目前仅使用两个关键帧的限制，事实上我们可以创建更多精细动画。甚至使用关键帧我们都能够创建出自定义的渐进曲线来（对于安卓开发者来说也就是所谓的插值）。举个例子，假设我们设置 imageAlpha 的开始和结束值分别是 255 和 0 ，然后在 25% 的位置添加一个关键帧，设置值为 205 ，在 75% 的位置设置另一个关键帧值为 50 。结果会给我们实现一个和加速-减速插值器一样的效果。 更牛逼的是，我们可以在动画进行时对动画进行动态更改。标题文字的移动和缩放在整个过渡动画中是同时进行的，但是通过添加一个单独关键帧后我们可以做到在不更改 ConstraintSets 代码的前提下，也不用改变缩放速度就能让标题文本更快地到达动画最终位置： res/xml/collapsing_toolbar.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;Transition app:constraintSetEnd=\"@id/collapsed\" app:constraintSetStart=\"@id/expanded\"&gt; &lt;OnSwipe app:dragDirection=\"dragUp\" app:touchAnchorId=\"@id/recyclerview\" app:touchAnchorSide=\"top\" /&gt; &lt;KeyFrameSet&gt; &lt;KeyAttribute app:framePosition=\"60\" app:target=\"@id/toolbar_image\"&gt; &lt;CustomAttribute app:attributeName=\"imageAlpha\" app:customIntegerValue=\"255\" /&gt; &lt;/KeyAttribute&gt; &lt;KeyAttribute app:framePosition=\"90\" app:target=\"@id/toolbar_image\"&gt; &lt;CustomAttribute app:attributeName=\"imageAlpha\" app:customIntegerValue=\"0\" /&gt; &lt;/KeyAttribute&gt; &lt;KeyPosition app:type=\"pathRelative\" app:framePosition=\"50\" app:target=\"@id/title\" app:percentX=\"0.9\" /&gt; &lt;/KeyFrameSet&gt; &lt;/Transition&gt; 以上代码能实现在 50% 的过渡动画进程中完成 90% 的移动效果。最终标题文本会走在工具栏折叠动画之前，接着在折叠完全结束的时候直接回落到正确的位置上： 虽然这只是弃用 CoordinatorLayout 过渡动画的一个开始，但是恰恰通过这个例子告诉了我们，如何使用关键帧来帮助我们动态地进行过渡动画修改，实现在同样的过渡中产生不同的动画效果。 最后值得一提的是：有时候它还能帮我们实现过渡动画的可视化，我们可以通过开启布局中的 showPaths 属性来实现： res/layout/activity_main.xml123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.motion.widget.MotionLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layoutDescription=\"@xml/collapsing_toolbar\" tools:context=\".MainActivity\" tools:showPaths=\"true\" app:showPaths=\"true\"&gt; ...&lt;/androidx.constraintlayout.motion.widget.MotionLayout&gt; 这里的 tools:showPaths=&quot;true&quot; 设置如果在 Android Studio 编辑器里配合使用会更爽（这个功能应该会出现在 Android Studio 3.4 的 alpha 版本中）。但是在目前来说，添加 tools:showPaths=&quot;true&quot; 这段代码能够让 MotionLayout 计算并显示这三个被过渡动画所影响的视图控件的轨迹路线：标题文本控件（顶部，中心左侧），工具栏的海滩小排屋图片（顶部中心），以及列表 RecyclerView 控件（中心位置）： 值得注意的是，我们在文本控件上添加的关键帧就是位于左边路径顶部下方的那一个红点。如果你仔细查看标题文本的移动，你会清楚的看到这一行轨迹始终穿行在字母 n 和 g 之间，并且它到达关键点位置要相对快些。这种显示路径的方式有助于我们理解刚才创建的关键帧是如何影响到过渡动画的特定部分的。你只需要记得在最终发布版本中要关闭这个功能——我建议定义一个布尔值资源，在布局中使用，然后你就可以在发布版本时总能设置它为 false 就可以了。 好吧，这次就到这里。即使如此，我相信大多数人还是会认同 MotionLayout 不仅灵活、强大，而且还为设计用户交互控制的布局动画开辟了一个非常有趣的可能性哦。 三、总结本篇的源代码请移步这里。 © 2018 ， Mark Allison 。保留所有版权。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"android 翻译"},{"title":"Godot3游戏引擎入门之零一：【翻译】为什么要选择 Godot 引擎","url":"/2018/08/24/introduction-of-godot-3-part-1-why-we-choose-godot-engine/","text":"一、前言本文作为我的 Godot 系列文章的第二篇，是一篇翻译文作为 Godot 的优点说明吧，虽然文章发布于去年，但还是很有借鉴意义，翻译的不是很好请海涵！ 作者简介：Rock Milk来自 Brasil 的另一个游戏开发高手。在此体验 Reakt 游戏：https://play.google.com/store/apps/details?id=co.rockmilk.reakt发布时间：2017 年 9 月 27 日原文链接： https://medium.com/@rockmilkgames/why-godot-engine-e0d4736d6eb0 二、原文：我们为什么选择 Godot 引擎现在是开发游戏的最好时机。第一个理由就是：你还活着，你如果挂了那就不能再开发游戏了。第二个理由是：获取开发工具从没有这么民主过啊。（哭） 那段美好的回忆我仍然还记得在 2004 年，那是我的计算机毕业课程的第一堂课。一个长大了的男孩，非常激动的学习如何开发并开始尝试创建一个模糊地存在我头脑中的蹩脚小游戏。我并不是想说我有多老或者多怀旧（尽管两者都有），但是回溯到那个时代，既没有推特（ Twitter ），没有脸书（ Facebook ），更没有其他所谓你现在正在使用的“信息分享”工具。 在巴西我们所拥有最好的东西就是那些隐蔽的网络论坛，聚集了一大堆有着共同兴趣爱好的匿名伙伴们，互相分享着那点点滴滴游戏开发的经验和知识。我都不知道那个时候我是怎么开始使用谷歌搜索去学习游戏开发的。尽管 GameMaker 已经有 17 岁了，而且 RPG Maker 都已经 24 岁了（！），我还从未听说过他们或者使用过他们的某些产品。 我在大学里的第一堂课就是计算机编程基础，教的是 C 语言。那个时候我学会了一点基本的语法，兴奋而又傻逼的我就决定做一个 Zelda 游戏：类似过去的克隆 / 启发型游戏。确实，每一个初学者都有点傻傻的。 这门课程的期末考试是要求使用 Allegro 克隆一个 Pac-Man 吃豆游戏 ，但其实并不止于此！在我内心来说，贪婪的游戏开发者会觉得吃豆游戏又简单又单调，我想要做的是一个 Zelda 类型的大游戏！后来我发现，对于我这种才学会一个 for 循环的人来说（这都可以作为另一个文章主题来讨论了），吃豆子游戏竟然是一个非常耗时的任务。 像我这种情况，无知就是幸运，没有什么东西可以阻挡我下载 Zelda 游戏中的射击图片，在一个我自己创造的简单粗暴的地图里，用来做移动和碰撞实验（这已经让我感觉自己就像程序上帝了）。不必说，我的吃豆子游戏从未见过天日，开发一个 Zelda 游戏简直有趣多了。 游戏引擎……到处都是游戏引擎回到现在的日子，到处有着上亿数量的书籍、文章、开发日志，社交网络传播着相关的各种知识和各种引擎。一切都是免费或者类似免费的。按某种分类列举一些我头脑里所能想到的引擎： Unity / Unreal / CryEngine / Lumberyard Scirra’s Construct / Stencyl / GameMaker / RPG Maker Love2D / HaxeFlixel / Cocos2D / Phaser 我还能持续列举下去好几年……我没有开玩笑哦…… 因为太多的选择，我们内心通常是矛盾的，到底应该选择哪个呢？ 屌丝： Godot 引擎在自我拼搏的这些年里，我和 Matheus 在引擎和编程语言上积累了大量的经验，不得不说，我们必须提到 Unity 这个引擎，我敢说这是目前在小工作室和独立开发者中最流行的引擎了。 2013 年，在我们深爱的 Critical Studio 工作室，我们使用它开发了 Dungeonland 游戏，在当时来看，相对于其他引擎， Unity 是非常棒的选择。 现在来看它仍然是一个很棒的引擎，特别是在 3D 方面。但是在 Critical Studio 工作室关闭后，我需要一个更为简单的工具来做开发。 Unity 体积膨胀大了，加载速度变得缓慢，开发 2D 游戏要 hack 很多东西。 接着我发现了 HaxeFlixel （它更像一个框架而不是引擎），它非常适合快速高效地进行原型设计和小游戏开发，我也能够在多平台上重用同一个代码集，另外它还能够使用 Flash 快速地发布游戏，给我的朋友们进行玩赏尝试。 但是，我觉得还是有什么东西缺失了，或许是某个本地平台和游戏框架之间的桥梁？我想要一个简单地类似 HaxeFlixel 的工具，但是却又拥有更多的自定义控制，就像 WYSIWYG 编辑器或者像 Unity 编辑器那样。 接下来的事情，一个名不见经传的新屌丝出现在城里，它就是 Godot 引擎。 Godot 于 2007 年开始作为一个私有引擎被开发，一直到 2014 年开源。经过 10 年的沉淀，已经变得非常成熟。 当我们发现它的时候，我们的感觉是它很可能拥有我和 Rock Milk 所正在搜寻的一切。我们把 Reakt 打造成了 Godot 测试用的实验项目，并定义了一套全新的产品开发流程。最终我们喜欢上了它，因为我们发现在其他引擎上的缺点都在这里完美解决了。 声明 我并没有引发与其他编程语言、框架或者引擎口水战的意思，因此： 我们并没有表示 Godot 比其他引擎更好、更强；（即使如此，也是个人观点而已） 我们并没有表示其他引擎就很差 我们并没有表示对于他们的缺点并不是没有任何解决方案 我们并没有表示 Godot 的解决方案是完美无缺的 这里的关键点在于：说明我们为什么喜欢它，以及它为什么更适合我们的商业和程序风格。如果我有冒犯的地方，请谅解，真的。（但是请不要动怒，没必要，是吧） OK ，开始吧…… 开源和社区 Godot 开源并永久免费。通俗点说就是： 没有个税，也没有所谓的年度、季度收入上限要求 不强求使用它们的启动画面、他们的附加服务或者使用它们的云服务托管你的项目 在 2015 年， Godot 加入了软件自由保护协会 Software Freedom Conservancy ，可以看出 Godot 对此非常关注。 它的开发社区非常活跃，更别说它们的仓库提交量了，经常会有新的文章和进度报告。在 Discord 上能看到大家发挥出的热情互助，也有他们自己的一些游戏讨论。 跨平台编辑和发布 Godot 针对每一个操作系统都有一个对应版本的编辑器： Windows, Mac 和 Linux 。甚至还有一个由 cam12win 放出的树莓派实验版本。 其他一切如常： 桌面发布平台： Windowx, Mac, Linux 手机发布平台： Android, iOS, Windows Phone （实验阶段） 以及黑莓系统（我没有开玩笑哦） 网页版发布，使用 Emscripten （ WebGL 2.0 和 WebAssembly 正在开发中） 当然还有一些其他平台的构建计划，甚至 Shin-Nil 已经让他的 2D 平台展示游戏在他的 XBox One 中运行了： 并且 Deponia Playstation 4 也是使用的 Godot 制作。 轻量级 构建好的 Godot 只需要占用你的硬盘的 30M 空间，包含（几乎）了所有内容。如果你需要构建手机版本，你需要下载额外的 200M 的构建模板，仅此而已。 这里我并不是因为下载速度快或者因为其他引擎占用了 3 到 30GB 的大空间而提出这点，而是为了说明 Godot 团队对性能的关注程度。 Godot 打开只需要一眨眼的功夫，我那用了 4 年的旧笔记本打开或者加载时间甚至都没超过 5 秒钟。我所等待过的最长时间大约是 1 分钟，那是发生在点击一个按钮发布到安卓手平台的 Debug 版本之间的时间开销。 当然，最重要的是：它能反应出你的游戏的性能。当我发现 Godot 引擎本身就是一个 Godot 开发的游戏的时候，我被深深地震惊了！ 友好的版本控制 你是否曾经遇到过在使用 Unity 或者 Unreal 的时候发生了场景或者预制体或者其他的对象文件在仓库的版本冲突问题？如果有的话，难么你应该知道这是多么痛苦的一件事了，特别是在大型团队里。 在 Godot 中任何对象都是以文本文档的形式保存，对于合并冲突来说是绝对是一种非常友好而且可读性强的文件格式。因为我们能非常轻松地区别开多个场景中的多个对象（关于这个之后会谈论更多），使得每一个团队成员都能够专注于自己的工作。 动画系统 Godot 的动画系统是我见过的最强大而又简单易用的一个系统，我曾经使用过的所有动画工具具有的功能设置它都包含了。你可以对某个对象的任意属性进行动画设置，甚至包括函数的调用。除此之外，它还包含了一个非常简易的动画创建工具。 动手比解释更能体会它的工作原理，我推荐你访问 GDQuest 和 Heartbeast 的视频，两位大牛利用他们的业余时间讲授创建游戏相关经验的视频，大部分是免费的。他们俩各自做了一个关于 Godot 的动画系统的介绍视频： 动画工具介绍 使用剪切动画技巧打造一个蝙蝠动画 真实2D vs 假2D 经常会遇到 Rock Milk 的哲学理论问题。为了弄清楚这个东西，我们创建了一个小而简单的游戏，尝试突破未开发的那些区域和一些创新机制。由于我们是两个家庭的普通人，经常一天只能抽出个把小时来开发我们的游戏，所以我们只专注于 2D 游戏开发。 Godot 的 2D 引擎可圈可点，它不是假的 2D ，就像在 3D 空间把 Z 轴平放一样的假 2D 。对于 Godot 来说这意味着什么呢？ 像素作为坐标和单位使用，包括物理引擎中的使用 更加高效、更加易用地 API ，无需在第三个轴上处理逻辑或者数学问题 某些其他引擎上的典型解决方案在这里都变得没必要（例如：把 1 个像素设为一个单元，完美像素渲染， Z 轴分层和相机缩放问题等） 换句话说，我们能很好的控制每个游戏物体的尺寸、位置、速度和碰撞，包括皮肤（ HUD ），这经常是需要进行一个完整的 PITA 设置。（不过我们还是蛮喜欢 Unity 的新 GUI 系统的说） GDScript 脚本和 API GDScript 是 Godot 中代码处理的默认编程语言，能和引擎的相关特性非常吻合的结合在一起。 通常只需要编写一点点代码就能做出一大堆动作效果，这是由于它那丰富的 API 。我曾以为每个对象都需要从头开始创建，但是 Godot 已经帮我们做好了，包括每一个操作和我所需要的自定义功能。 另外，我觉得 GDScript 是让新用户拒而远之的最主要原因。我重点列举以下我所听见的抱怨中的几条： 我是不是必须要学习一门只能在 Godot 中使用的编程语言？ 是的，朋友，但是这并不会多花费你多于两天的时间。这门语言非常简单，就像 Python 的兄弟版。 最糟糕的情况是：至少你也将会学会另一门编程语言，而且学习新的语言能有助于你进行和别人不一样的思考方式（那是更好的方式）。 我讨厌编程语言 好吧，没有理由一定要尝试，我也没有什么可抱怨的。但是，如果你愿意的话，你可以完全使用 C++ 模块来编写代码然后轻松地导出为 GDScript 脚本。 或许，你可能更希望等待 Godot 3.0 版本的发布（其实它就在 Godot 的社区……开个玩笑），因为 3.0 版将会支持 C# 以及 GDNative 脚本，也就是说到时候你可以使用 Python ， Go ， D ， Rust 甚至 Nim （或者任意其他你想绑定的编程语言）等语言编写代码。 那么它的性能怎样呢？游戏代码如何？额 一般对于你所能想到的 95% 的游戏我相信性能都足够满足了。如果你还是持有怀疑态度，那么像我刚才提到的，你完全可以使用 C++ 模块编写然后获得 C++ 的性能。 如果在你的游戏里，某个部分算法有着极高的性能需求，那么你可以在此部分上单独使用 C++ 进行编程，在其他部分继续采用 GDScript 脚本。 你可以阅读更多 Shin-Nil 的关于性能测试之类的文章。 我的编程工具和软件并支持 GDScript 脚本 Godot 有一个集成的代码编辑器，而且除了基本的脚本编写之外它还具有漂亮的智能代码提示功能（也就是说代码自动完成功能），以及强大的 debug 功能，另外包括运行时编辑功能，你可以看看 Juan Linietsky （ 也叫 Reduzio ）的视频，他是 Godot 的主要开发者，视频地址在此： 到目前为止，对于外部代码编辑器，完全支持的只有 Visual Studio Code ，使用的是 Godot 工具，由 Geequlim 开发，但是其他软件包括 Sublime Text ， Atom 以及 GEdit 都能支持语法高亮功能。 我的建议是：在批评之前先尝试使用 GDScript 脚本吧。如果你在一周之后还是不能顺利上手，效率也不高，那我赔你一颗糖吧。哈哈。（？） 到这里还是不相信？那看一看 Juan 关于创造 GDScript 脚本的理由吧，或许它能让你改变主意： https://www.redditmedia.com/r/gamedev/comments/36u80q/godot_engine_11_out/crhjrw6/?embed=true&amp;context=0&amp;depth=1&amp;showedits=false&amp;created=null&amp;uuid=null&amp;showmore=false 节点和场景系统 节点是游戏中能够进行属性编辑的一个基本对象。它可以使一个 2D 精灵，一个 3D 模型，一些 GUI 控件元素或者仅声音的播放功能。 Godot 包含了大量节点可供使用和扩展，因此你可以完全创建属于你自己的节点类型。场景是由一组节点有层次的组织在一起构建而成，如同一棵大树。 这也是我们最喜欢的特性，关于节点这个图做出了最好的解释： Godot 中一切都是场景。每一个场景都能包含其他场景和节点。你可以轻松地提取子节点作为一个场景，提高它的复用性， fracteed 先生在管道上就聪明地利用了这个特性： Sceneception = a scene within a scene within a scene. Nested scenes are perfect for items such as pipes #GodotEngine #gamedev #indiedev #b3d pic.twitter.com/KkxC2kAUcK&mdash; fracteed (@fracteed) September 3, 2017 为了让你更好的理解，我这里拿 Unity 来作对比： 在 Unity 中一个游戏物体的行为是通过添加多个组件实现的。每一个组件都是一个脚本，所以一个对象可以有很多个脚本；（噢） 在 Godot 中，每个节点只能拥有一个脚本，当然它本身已经拥有了一些基本的功能。你可以在场景中定义一个游戏物体，它由多个节点和其他的场景组成。这也就意味着默认情况下你可以使用预制体嵌套（ prefabs ）。下面这个例子来自 Godot 的官方文档，表示的是一个 Player 游戏物体： 如果你想要阅读更多相关的内容，你可以读一下官方文档页面的：从 Unity 到 Godot &gt; 场景系统 小缺陷，但是解决方案已经在进行中在 Reakt 的开发过程中，我们使用 Godot 2.1.3 版本，发现了一些小的 Bug 和一些怪异的地方： 我有一台 13 寸的 Macbook Pro Retina 。鉴于我所使用的 Godot 软件工具，有些 GUI 面板显得非常紧凑，一些按钮出现在了其他的 GUI 元素的上层，但是没有任何东西可以阻止继续使用它们 当关闭动画工具的时候，它会把当前的编辑节点的默认状态设置为最后我所使用过的状态，我们不得不多次进行重置节点到原始的配置状态。最新的解决方案是，我们在关闭动画工具之前会先创建了一个默认状态并选中它。 除了这点，我们的开发瓶颈在于整合手机平台第三方库，主要有：分析工具、广告中间网络以及崩溃报告。在 Godot 中创建原生模块非常繁琐：你不得不下载引擎源码，在指定的文件夹中创建并包含原生模块，编译 Godot 引擎，接着编译测试版和发布版。如果没问题的话，这些操作会生成一个可以在你的游戏中使用的手机平台模板，如果有问题，那么你不得不使用 USB 接头继续连接到你的手机上重新 debug 测试你的代码模块。啊哈…… 所有程序设置好之后你就可以使用它了，重新生成所有模块还是非常快的。在我们的第一个游戏上我们仅仅使用了 Frog-Square 创建的 Godot-Firebase 模块（感谢帮助和支持！）。 我们想实现我们自己的中间网络层（鉴于 Firebase 只含有 AdMob ），但是投入-产出比暂时还是不值得我们这么去做，因为我之前已经提到过， Reakt 仅仅是一个实验项目，而且 GDNative 已经在 Godot 3 引擎中开始使用了，它也修复了一个我们遇到的一个问题，将来我们可以直接使用它，而不需要像我之前提到的那样从头到尾进行一次手动的编译过程。 OK ， Godot 3.0 即将到来……当然，目前还没有任何借口不去尝试一下它的！你可以使用它做些小 Demo ，这有助于你理解我所说的东西。 另外，看下这个视频，了解一下 3.0 版本中正在开发的所有新特性： 如果需要的话你可以下载一个 Alpha 版本 玩玩。还有，关注下这个引擎的开发路线，这真是游戏开发者的福音啊！ 除此之外， Godot 来到了它的第一个里程碑，它已经有了赞助商，这使得 Juan 可以全职全身心地投入到引擎的开发中来。 我真心希望我能劝服你加入到这个激情的社区，帮助提升 Godot 引擎的成长速度。我是否已经打动你了呢？如果是的话，那么开始学习吧： Godot 官方文档 GDQuest 发布的 30 天 30 个教程 以及 使用 Godot 制作专业 2D 游戏课程 （这个课程在 Kickstarter 已经筹到 32512 欧元！） 小孩能编程以及 Angega 工作室油管频道 Rock Milk 的目标是成为 Godot 提到的第一个推荐者，就像 P1X （自由坦克的创造者）和 Okam （ Godot 出生的地方，以及小狗 Mendonça 和 Pizzaboy 的互动历险记® 的创造者）。我真心希望在我们的旅程中能够遇到你，有任何疑问欢迎随时和我们来交流吧！ Diego Machado ，一位万事通牛人：@Rock Milk 三、其他太多的视频地址和链接，本文已经发布到微信公众号，如果需要查看相关链接和视频，请点击下方的阅读原文并开启翻墙模式吧。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot 翻译"},{"title":"Godot3游戏引擎入门之零零：简单的想法","url":"/2018/08/15/introduction-of-godot-3-part-0-my-view/","text":"一、缘由今年 7 月份，也就是上个月，惊奇的发现世界上存在着这么一个小巧灵动的游戏引擎： Godot Game Engine ，图标非常可爱另类，研究了一番，现在已经是 3.0 的版本（目前是 3.0.6 ），看官方新闻，最新版 3.1 正在紧张有序的开发中，据说会有重大突破，期待。 这个游戏引擎虽小，但是真的是五脏俱全：支持 Window/Mac/Linux 主流操作系统，支持普通的 2D 和 3D 游戏开发，支持 Android/iOS/Blackberry OS 等主流手机平台，以及 XBox/Steam/GameRoom 等其他游戏平台的发布，当然 WebGL 也不在话下。你可以到官方网站下载直接运行文件， Mac 也可以通过 brew cask install godot 安装，最大不超过 100M ，最低 20M ，但功能可谓是非常齐全啊。 令人惊喜的是，他是开源的！开源的，没错，你没有听错，早在四年前就已经开源了，哇哦~不过，不好意思，四年前我连如日中天的 Unity3D 是啥都不知道呢。去年底有机会接触并学习了一段时间的 Unity3D 游戏开发后，还是蛮喜欢这个游戏开发引擎的，但是现在我发现作为游戏开发爱好者菜鸟的我， Godot 更适合我，为啥？请听我慢慢道来： 小巧开源，社区驱动，下载后无需安装，开箱即用，官方插件也齐全 惊喜的 2D 游戏开发界面和 GUI 元素，适合新手，打开程序即可轻松上手游戏开发 一切基于 Node ，想添加任何元素都是极其 Easy ，甚至 2D 和 3D 以及 GUI 元素混用都没关系 每一个 Node 元素只能添加一个 Script 脚本进行控制，这太符合是我这类有一点点 Adobe Flash 开发经验的朋友了 如果深入点，它的流程设计，帮助文档，资源加载，一切可以基于场景进行设计，等等，都非常直接、非常贴切啊~~~ 当然，学习曲线平缓也是我喜欢这个游戏引擎的另一个重要原因。这就是我接触 Godot 没超过两周的感受吧，当然还有更多更多的优点等着去挖掘和探索的，官方对此也列举了 Godot 平台的几乎所有的特性及优点，大家可以在此查看： Godot Features 总之，就是这么一个五脏俱全、小巧玲珑的开源的游戏开发引擎让我爱不释手，我决定“冒天下之大不韪”对 Godot 进行个人方面的努力宣传尝试，为开源界也算是贡献我的一份渺小的力量吧。哈哈。 二、内容因为自己对游戏开发也几乎是完全从 0 开始，目前有没有入门都还处于不确定阶段，我肯定不能进行一些深入的探讨，但是基础的部分我会边学习边记录下来，作为小专题来和喜欢 Godot 的朋友们一起讨论研究。 关于内容的话，我初步给自己定了一个目标，找了些资料和书籍，主要基于 2D 游戏开发，参考了《 Godot Engine Game Development in 24 Hours, Sams Teach Yourself: The Official Guide to Godot 3.0 》这本书后，我把内容简单的列表如下： Godot 游戏引擎的介绍和安装、以及相关的资源 Godot 的场景系统介绍和使用 2D 图形相关元素和操作 GDScript 脚本介绍和使用 用户输入 Input 相关 游戏物理引擎 动画的使用 简单的开发流程探讨 文件系统和项目管理 声音和粒子系统 视口和 GUI 界面元素 网络相关 最后可能会探讨一下 Native 脚本吧 其他…… 好吧，这真是画了一个好大的饼啊……希望自己跪着也能吃完吧，哈哈。 三、其他啰嗦了一大堆，大家肯定会问：凭什么要上船呢？特别是很多朋友可能有其他游戏引擎的开发经验，比如国内如火如荼的 Unity 3D ，还有大名鼎鼎的老资格 Unreal Engine ，以及游戏画面闻名的 Cry Engine 等等，还有手机上著名的 SpriteKit 框架，以及开源跨平台的 LibGDX 或者 Cocos2d-x 游戏框架经验，等等，话说最近开源的 Xenko 又是个什么梗？我想说，凭我的软文还不够大家上船，那么先来两篇文章安利一下大家吧： 这里有一位国外大“屌”开发者，谈了他对 Godot 和自己多年 Unity3D 游戏开发经验的一些比较和看法，我觉得蛮有参照价值的，参考网址： Here is my personal opinion about Godot vs Unityhttps://news.ycombinator.com/item?id=16674933）： 还有一个位大神，在去年底 Medium 上发了一篇文章，也是关于为什么选择 Godot 的原因，原文太长了，参考网址： Why we choose Godot Enginehttps://medium.com/@rockmilkgames/why-godot-engine-e0d4736d6eb0 我感觉自己要翻译一下这两篇文章了，因为阅读这些英文有点浪费时间，我也并没有足够的说服力来让大家趟坑 Godot ，哈哈。那么，可能下篇见吧。 我的博客地址： http://liuqingwen.me ，欢迎关注我的微信公众号：","tags":"godot"},{"title":"【翻译】MotionLayout实现折叠工具栏（Part 1）","url":"/2018/08/13/translation-of-motionlayout-collapsing-toolbar-part-1/","text":"一、说明没有严格按照中英对照进行的翻译，但是我尽量把意思翻译到位，能看原文的朋友可以直接欣赏原文啦。 本文特点：没有 Kotlin/Java 代码，讲解部分全为 XML 代码，阅读时间短，获取技能： MotionLayout 的入门和使用！发布时间： 8 月 10 号 ，作者： Mark Allison ，原文链接： https://blog.stylingandroid.com/motionlayout-collapsing-toolbar-part-1/ 二、正文谷歌 IO 2018 发布了 ConstraintLayout 2.0 版本，其中最重要的部分就是 MotionLayout 了，这玩意就是一个全新的、超牛的布局动画工具！ Nicolas Roard 哥们早已发布了一个关于 MotionLayout 的完美详情介绍，我强烈推荐大家去阅读一下，从中理解 MotionLayout 组件的基础架构。本系列教程中，我会讲解如何使用 MotionLayout 来创建一个我们已经非常熟悉的动画行为：一个折叠工具栏动画（ a Collapsing Toolbar ）。 在我们开始之前，有必要在这里澄清一下：在 CoordinatorLayout 中使用 CollapsingToolbarLayout 来实现折叠工具栏是没任何问题的。当然了，如果你已经在自己的 App 中使用了，那么你在学会了这里的知识后也没什么必要做更改。也就是说， CoordinatorLayout 这个布局已经提供了一些非常有用的行为动画，如果你尝试去修改它，或者创建一些基于它的自定义动画，那都是相当困难的。相反， MotionLayout 提供了更多的灵活性，以我个人早期的经验来看，这是一个非常简单又易学的效果神器。而且， MotionLayout 让那些 CoordinatorLayout 望而却步的动画变得简单直接。学习来吧，骚年！ MotionLayout 和安卓上许多其他的动画框架的一个主要不同点在于：视图动画和属性动画运行的时长是给定的，比如指定动画的时长，取消某个动画都是可行的，但是不能做到用户控制一个正在进行中的动画。举个例子，一个折叠工具栏应该根据用户的滚动进行展开和折叠，所以实际动画的运行应该时刻跟随用户的拖拽进行。这也是那些框架办不到的地方。 废话不多说，让我们看下我们所要尝试模拟做到的行为动作。这里的代码展示了一个折叠工具栏，应用了 Material Components Library 库里的 CollapsingToolbarLayout 和 CoordinatorLayout 布局。 res/layout/activity_main_traditional.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=\"@+id/recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/appbar\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=\"@+id/appbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fitsSystemWindows=\"true\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;com.google.android.material.appbar.CollapsingToolbarLayout android:id=\"@+id/collapsing_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleGravity=\"bottom\" app:expandedTitleMarginEnd=\"@dimen/activity_horizontal_margin\" app:expandedTitleMarginStart=\"@dimen/activity_horizontal_margin\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\" app:title=\"@string/app_name\"&gt; &lt;ImageView android:id=\"@+id/toolbar_image\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:adjustViewBounds=\"true\" android:contentDescription=\"@null\" android:fitsSystemWindows=\"true\" android:scaleType=\"centerCrop\" android:src=\"@drawable/beach_huts\" /&gt; &lt;androidx.appcompat.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\" app:popupTheme=\"@style/ThemeOverlay.AppCompat\" /&gt; &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 运行这段代码所得到的动画行为是这样的： 使用 MotionLayout 做到接近上述动画效果非常简单。首先从我们的布局文件开始： res/layout/activity_main.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.motion.widget.MotionLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\" app:layoutDescription=\"@xml/collapsing_toolbar\" tools:showPaths=\"true\"&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=\"@+id/recyclerview\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/toolbar_image\" /&gt; &lt;ImageView android:id=\"@+id/toolbar_image\" android:layout_width=\"0dp\" android:layout_height=\"200dp\" android:adjustViewBounds=\"true\" android:contentDescription=\"@null\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" android:fitsSystemWindows=\"true\" android:scaleType=\"center\" android:src=\"@drawable/beach_huts\" android:background=\"@color/colorPrimary\" /&gt; &lt;ImageView android:id=\"@android:id/home\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingStart=\"16dp\" android:paddingEnd=\"16dp\" android:paddingTop=\"16dp\" android:paddingBottom=\"16dp\" android:src=\"@drawable/abc_ic_ab_back_material\" android:tint=\"?android:attr/textColorPrimaryInverse\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; &lt;TextView android:id=\"@+id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"8dp\" android:layout_marginBottom=\"24dp\" android:text=\"@string/app_name\" android:textColor=\"?android:attr/textColorPrimaryInverse\" android:textSize=\"32sp\" android:textStyle=\"bold\" app:layout_constraintBottom_toBottomOf=\"@id/toolbar_image\" app:layout_constraintStart_toStartOf=\"parent\" /&gt; &lt;/androidx.constraintlayout.motion.widget.MotionLayout&gt; 这基本上是使用标准的 ConstraintLayout 创建出来的一个布局，唯一区别在于父布局实际为一个 MotionLayout 布局（ MotionLayout 继承于 ConstraintLayout ，所以我们能够把它当做一个普通的 ConstraintLayout 来使用）。这个 MotionLayout 布局有一个属性名为： app:layoutDescription ，它也是奇迹所发生的地方。在这里我特意使用了最基本的 View 控件类型，用来说明视图本身并没有产生任何其他的行为动作。当然在实际 App 开发过程中我应该会使用 AppBarLayout 布局配合 Toolbar 控件吧。 如果在设计视图中查看这个布局，我们能看到布局所展示的工具栏处于展开的状态： 我刚刚提到奇迹发生的地方在于布局文件中的 app:layoutDescription 属性，那么现在我们来仔细瞧瞧它吧： res/xml/collapsing_toolbar.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;MotionScene xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;Transition app:constraintSetEnd=\"@id/collapsed\" app:constraintSetStart=\"@id/expanded\"&gt; &lt;OnSwipe app:dragDirection=\"dragUp\" app:touchAnchorId=\"@id/recyclerview\" app:touchAnchorSide=\"top\" /&gt; &lt;/Transition&gt; &lt;ConstraintSet android:id=\"@+id/expanded\"&gt; &lt;Constraint android:id=\"@id/toolbar_image\" android:layout_height=\"200dp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;CustomAttribute app:attributeName=\"imageAlpha\" app:customIntegerValue=\"255\" /&gt; &lt;/Constraint&gt; &lt;Constraint android:id=\"@id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"8dp\" android:layout_marginBottom=\"24dp\" android:scaleX=\"1.0\" android:scaleY=\"1.0\" app:layout_constraintBottom_toBottomOf=\"@id/toolbar_image\" app:layout_constraintStart_toStartOf=\"parent\"&gt; &lt;/Constraint&gt; &lt;/ConstraintSet&gt; &lt;ConstraintSet android:id=\"@+id/collapsed\"&gt; &lt;Constraint android:id=\"@id/toolbar_image\" android:layout_height=\"?attr/actionBarSize\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;CustomAttribute app:attributeName=\"imageAlpha\" app:customIntegerValue=\"0\" /&gt; &lt;/Constraint&gt; &lt;Constraint android:id=\"@id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"20dp\" android:layout_marginBottom=\"0dp\" android:scaleX=\"0.625\" android:scaleY=\"0.625\" app:layout_constraintBottom_toBottomOf=\"@id/toolbar_image\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@id/toolbar_image\"&gt; &lt;/Constraint&gt; &lt;/ConstraintSet&gt; &lt;/MotionScene&gt; 这就是一个崭新的 MotionLayout ，也许看起来会有点恐惧，让我们来把它分解成一块块很好理解的小件然后再进行细细剖析。这里父布局首先是一个 MotionScene ，它持有所有我们定义的过渡动画所需要的组件。它包含两个 ConstraintSet ，每个 ConstraintSet 又定义了一套相关约束，这套约束体现为布局的一个固定的状态，这个我们会在后面深入探讨，目前我们只需要知道：有一个 ConstraintSet 表示工具栏的完全展开状态，而另一个表示工具栏处于完全闭合状态就足以。 这里的 Transition 元素定义了过渡动画的开始和结束状态，以及过渡效果如何和用户进行交互： res/xml/collapsing_toolbar.xml12345678910&lt;Transition app:constraintSetEnd=\"@id/collapsed\" app:constraintSetStart=\"@id/expanded\"&gt; &lt;OnSwipe app:dragDirection=\"dragUp\" app:touchAnchorId=\"@id/recyclerview\" app:touchAnchorSide=\"top\" /&gt; &lt;/Transition&gt; 两个属性： app:constraintSetStart 和 app:constraintSetEnd 分别指 ConstrainSet 所定义的两种状态：展开状态和折叠状态。元素 OnSwipe 把过渡动画和用户在 RecyclerView 上的拖拽操作绑定到了一起，也就是之前我们查看到的主布局中的列表。在展开和折叠状态下， RecyclerView 列表的上边缘是处于不同位置的，因为它被约束到了 ID 为 toolbar_image 的 ImageView 图片下边缘，而这个过渡动画的实现正是由于控制着这个位置变量的值，这个值又源于用户拖拽 RecyclerView 来产生。别小看这里短短的 10 行 XML 代码，它背后可为我们做了大量的工作哦。这其中内部原理非常复杂，它由 RecyclerView 的滚动行为所驱动。 为了理解这两个 ConstrainSet 的定义，让我们先假设这里只有两件事情需要进行控制。第一件事情就是作为背景的 ImageView 图片（ ID 为 toolbar_image ）高度值的改变，以及图片透明度值的改变。通过改变图片的高度，这会导致 RecyclerView 的上边缘的移动，因为后者正是约束在图片的下边缘位置。第二个控件则是包含了标题（ ID 为 title ）的文本 TextView ，它需要移动的同时改变自身大小尺寸。 让我们首先看看这两个状态下图片 ImageView 的高度差。在展开状态下是这样的： res/xml/collapsing_toolbar.xml1234567891011&lt;ConstraintSet android:id=\"@+id/expanded\"&gt; &lt;Constraint android:id=\"@id/toolbar_image\" android:layout_height=\"200dp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;CustomAttribute app:attributeName=\"imageAlpha\" app:customIntegerValue=\"255\" /&gt; &lt;/Constraint&gt; 对于折叠状态下则为： res/xml/collapsing_toolbar.xml1234567891011&lt;ConstraintSet android:id=\"@+id/collapsed\"&gt; &lt;Constraint android:id=\"@id/toolbar_image\" android:layout_height=\"?attr/actionBarSize\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;CustomAttribute app:attributeName=\"imageAlpha\" app:customIntegerValue=\"0\" /&gt; &lt;/Constraint&gt; 这里只有两个小小的区别。第一个就是高度 layout_height ，第二个则为名为 imageAlpha 的 CustomAttribute 。以 CustomAttribute 为名暗示着我们正在使用一个自定义视图 View ，但实际上并不是这样。我们使用的是一个标准的 ImageView 控件，当其位于 ConstraintSet 下的 Constraint 元素中时，其主要的属性变成可以是 ConstraintLayout.LayoutParams 中的任何一个属性，也可以是 View 中的任何一个属性，但即使像 ImageView 这类作为 View 的子类控件，我们仍然需要使用一个 CustomAttribute 符号，这里实际上和 ObjectAnimator 的原理非常类似。在这里，我们需要调整 ImageView 的 imageAlpha 值。当然，你也可以使用自定义视图上的自定义属性来实现，就如同 ObjectAnimator 一样。 另外 TextView 实际上也非常类似。展开状态是： res/xml/collapsing_toolbar.xml12345678910&lt;Constraint android:id=\"@id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"8dp\" android:layout_marginBottom=\"24dp\" android:scaleX=\"1.0\" android:scaleY=\"1.0\" app:layout_constraintBottom_toBottomOf=\"@id/toolbar_image\" app:layout_constraintStart_toStartOf=\"parent\" /&gt; 还有，折叠状态则为： res/xml/collapsing_toolbar.xml1234567891011&lt;Constraint android:id=\"@id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"20dp\" android:layout_marginBottom=\"0dp\" android:scaleX=\"0.625\" android:scaleY=\"0.625\" app:layout_constraintBottom_toBottomOf=\"@id/toolbar_image\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@id/toolbar_image\"/&gt; 这里，我们通过使用视图的缩放来改变 TextView 的大小。如果你对为什么这里选择缩放而非直接通过一个 CustomAttribute 改变 textSize 来实现表示怀疑的话，那么你要知道，在这里的理由就是因为相比简单直接地在文本上应用一个形变，通过改变文本大小和重新渲染会非常耗计算资源，所以我们为了在过渡动画结束时尽量减少锯齿的产生需要使用这个技巧。 我们所做的另一件事情则是改变边距大小（ margins ），以及如何让 TextView 文本的位置相对于 ImageView 图片的位置而固定。在折叠状态下它会垂直居中，而在展开状态下它会对齐在底部，因此 TextView 会更多的相对于 ImageView 的大小尺寸来进行相关设定。 如果我们使用该布局来代替一开始我们就使用的 CoordinatorLayout 布局来实现，那么我们将会得到这样的行为： 这事实上效果已经非常接近，但是仔细看你会发现这里与刚开始我们使用的 CoordinatorLayout 方式有一个细微的区别：在 CoordinatorLayout 布局下图片的褪色渐变动画和 MotionLayout 版本中的行为有点不一致。这里卖个关子，在本系列文章的最后，我们将会介绍关于 MotionLayout 布局中更细粒度的一些控制。 三、总结本篇的源代码请移步这里。 © 2018 ， Mark Allison 。保留所有版权。","tags":"android 翻译"},{"title":"重新开始我的写作之旅","url":"/2018/08/11/continue-writing-blog-post-in-2018/","text":"一、说在前面差不多在告别写作一年后，重新拾起笔来继续写作。 为什么没坚持写作？ 懒，这是肯定的；主要懒在动手上，但是学习上还是没有懒过 上一份工作辞职后自己跟着朋友做了一些其他事情，时间没那么充裕 无成果，也就是自己学习速度不是很快，学习深度太浅，级别不够，没什么输出啊 为什么要继续写作？ 是不是收获了重大成果了呢？ Nope! 真不是，但是我想学习需要积累，简单的知识点也可以记录并分享出来 写作很能锻炼一个人的素质水平：沟通能力，言语组织能力，问题分析能力，打怪升级能力…… 学习总结真的很重要，能够有效的提高自己的开发水平 希望写作也能给我带来收入！真是异想天开， five 毛？哈哈…… 坚持是一种力量，我想超神！ 二、写作内容写作写作，有内容才能写作！我能写什么呢？我又会些什么呢？我精通哪些呢？ 精通 Windows/Mac/Linux 开关机？ 抑或 PS/AI/DW/FW/PR/AU/AN/AE 的安装和卸载？ 或者 Maya/Blender/Max/Houdini 的单词拼写？ 还是 iOS/Android/WindowsPhone 的流利操作？ 当然还是 IT ！ 一方面本身就是非科班出生，另一方面真正步入 IT 界大门是从 16 年底（或者 17 年初）开始的，中间又断断续续迷茫了一段时间，那么我能做出什么花样呢？这就是问题所在，还好我目前一直发愤图强，励精图治，不断学习、尝试各种新老技术，学习，练习，学习，再练习，终于 —— 入了门。 虽然，但是，我还是要给自己定些目标，这总没问题吧，贵在实际行动和以后的坚持： 图形方面我相信 Blender 能帮我我制作简单模型和三维动画 Unity3D 配合 C# 脚本开发简简单单的三维游戏 Godot 配合 GDScript 进行 2D 脚本游戏开发，“舒爽” Kotlin 是我的最爱，没有 Java 基础我也要闯一闯 Swift 和 Kotlin 一样可爱，我有一台黑色 Mac 可以运行 iOS 你能信？ Android 开发一直是我的最爱，毕竟买了好几本书入坑中 Google 粉丝对 Flutter 和 Dart 情有独钟，希望能好好学习它的精髓 打怪升级、坑人恶搞、吹牛上至刀山下至火海、政治经济军事生活杂事、如何活出个人样…… 三、总之嗯，新开始的第一篇，也是吹牛的第一篇。 总之，我的人参我自己煮宰，我喂自己袋盐，敬请期待！","tags":"随笔"},{"title":"【翻译】深入 Kotlin 协程","url":"/2017/10/26/translation-of-diving-deep-into-kotlin-coroutines/","text":"一、前言翻译好的文章也是一种学习方法！ 原文标题：Diving deep into Kotlin Coroutines原文地址：https://www.kotlindevelopment.com/deep-dive-coroutines/原文作者：Adrian Bukros 二、正文编写 Kotlin 协程相关的文章是当下比较流行的一个话题，这当然是有极好的理由支撑着的。JetBrains 公司的伙伴们创造了一门非常实用的计算机语言，赢得了成千上万开发者们的心，还介绍了一个稳定（目前仍在实验阶段）的特性，承诺在避免冗繁的前提下编写出优雅的异步代码。我将会指导你使用协程相关的基本示例，并观察背后到底发生了什么。 为什么像协程这种解决方案非常有必要？在现代应用程序开发中，处理多线程任务是不可避免的工作。一边在 UI 上显示花哨的加载动画一边等待网络请求就是一个简单的例子，这不得不使用异步代码来解决。在手机操作系统上，比如 Android 的 UI 线程用于处理用户交互，像那些点击按钮和手势操作，以及显示层的渲染工作等。这些都是最基本的，让我们来看一个例子吧！点击一个按钮之后，应用程序开始从网络上下载 JSON 数据，然后反序列化，最后把结果更新在显示层上。（反序列化和网络交互通常可以用一些聪明的类库来处理，以降低程序员的开发复杂度，但是为了展示例子的目的，还是让我们看这个例子吧。）那么你会如何写代码呢？ 123456789101112131415fun fetchUserString(userId: String): String &#123; // request user from network // return user String&#125;fun deserializeUser(userString: String): User &#123; // deserialize // return User&#125;button.setOnClickListener &#123; val userString = fetchUserString(\"1\") val user = deserializeUser(userString) showUserData(user)&#125; 我觉得这是最直接（也很幼稚）的一种方式，提供了解决上述问题的方案。但是这里面有很大的问题。 在 UI 线程上启动一个网络请求是不明智的做法（在安卓上这甚至不可能，因为你的应用程序会抛出一个丑陋的 NetworkOnMainThreadException 异常），由于网络请求经常会花费至少半秒的时长，而此期间 UI 更新将会被暂停。没有花哨的加载动画，也不能滚动，等等。 反序列化是一个很消耗 CPU 资源的操作，这会吃掉帧渲染所需的大量资源。本质上，这个结果和前面一点是一样的。 那么我们怎么解决这些问题呢？我们需要把网络请求和反序列化分派到一个后台进程中执行。听起来很简单，但是实现它的最好方式是什么呢？ 解决方案 1 ：Callbacks 回调假设现在重构我们的 fetchUserString 方法和 deserializeUser 方法来使它在后台的线程中工作。程序仍然需要等待后台任务完成后在 UI 上执行返回结果的显示。我们可以通过给运行函数提供回调来达到目的，就像这样： 1234567button.setOnClickListener &#123; fetchUserString(\"1\") &#123; userString -&gt; deserializeUser(userString) &#123; user -&gt; showUserData(user) &#125; &#125;&#125; 但这个解决方案导致的问题是随着回调函数调用次数的增加，代码开始变得不那么易读了。这种现象叫做：回调的地狱。我们必须避免这种情况发生。 解决方案 2 ： Reactive 反应链方法这种反应链的方法提供了一种更加有效的代码编写方式，它能组合方法的回调以避免函数方法的多重嵌套： 123456789button.setOnClickListener &#123; fetchUserString(\"1\") .flatMap &#123; userString -&gt; deserializeUser(userString) &#125; .subscribe &#123; user -&gt; showUserData(user) &#125;&#125; 大部分人对这种反应链解决方式感到非常满意（包括我自己），但是我们必须不得不承认的是，这个代码仍然离我们的刚开始的写法相差甚远 —— 对于使用者来说还是有那么一点复杂度的。那么还有其他的更加有效的方式来实现程序并行计算运行吗？有的。 解决方案 3 ： Coroutines 协程这是我们使用协程来实现的代码的模样： 1234567button.setOnClickListener &#123; launch(UI)&#123; val userString = fetchUserString(\"1\").await() val user = deserializeUser(userString).await() showUserData(user) &#125;&#125; 这个代码看起来基本上和我们一开始写的代码是一样的，并且效果和预期的一致（不会阻塞 UI 线程）。那么让我们来看看具体怎样使用命令式的风格写出类似的异步代码吧！ 如何使用协程？协程基于一种新的函数类型，叫做挂起函数。我们可以在函数名称前使用一种新的语言关键字 suspend 来标记。用这个关键字标记的函数能够暂停一个协程的执行，且不会阻塞当前线程。 123suspend fun fetchUserData(userId: String): String &#123; // return user String&#125; 一个挂起的函数只能被协程或者其他挂起的函数调用。通常我们会在协程库中 lambda 函数表达式的参数中看到他们，比如 async 函数： 123public fun &lt;T&gt; async( … , … , block: suspend CoroutineScope.() -&gt; T): Deferred&lt;T&gt; &#123;…&#125; launch{} 如果你不考虑返回值，那么 launch 函数是使用协程的最简单工具。 12345val job = launch &#123; val userString = fetchUserString(\"1\") val user = deserializeUser(userString) log(user.name)&#125; 被函数包裹的代码会分派到一个后台的线程中，而这个函数自己则返回一个 Job 实例，它可以在其他的协程中使用并被控制执行。调用 Job 类的 join() 方法将暂停它所包含的协程的运行。 async{} 通过使用 async 函数你可以达到和 launch 一样的效果，唯一一个非常重要的差别是：它有返回值。 12345val user = async &#123; val userString = fetchUserString(\"1\") val user = deserializeUser(userString) user&#125;.await() 这个异步方法返回一个 Defered&lt;T&gt; 实例，访问它的 await() 方法你能够得到最后计算的实际结果。 重构我们的代码，这个问题的解决方案如下： 123456789101112131415fun fetchUserString(userId: String) = async &#123; // request user from network // return user String&#125;fun deserializeUser(userString: String) = async &#123; // deserialize // return User&#125;launch(UI) &#123; val userString = fetchUserString(\"1\").await() val user = deserializeUser(userString).await() showUserData(user)&#125; 现在我们知道了如何获取协程执行后的返回值，但是如果我们需要多个返回值呢？那就是 Channel 要做的事情了 —— 你可以在这里阅读了解更多关于它的资料。 在深入协程之前，让我们来看看其他编程语言关于异步编程模式的不同实现方式！ 光天化日之下无新鲜感……或者还是有的？在 C# 5.0 中，追溯到 2012 年，关于异步函数微软提出了一个特性，非常类似 Kotlin 中的协程： 12345public async Task&lt;T&gt; doWork()&#123; // do some work&#125;var result = await doWork() 他们的实现方式在关于异步代码应该写成什么样的看法上拥有一致的基本理念，但是有几个主要的区别。 在 C# 中 async 和 await 都是关键字 在 C# 中 async 函数只能返回一个 Task 实例或者返回空 如果你仔细观察协程的这个例子，你会看到在 Kotlin 中， launch{} ， async{} ， 以及 await() 函数都是普普通通的的函数（它们有些采用 suspend 关键字标记了）。这在命名和返回值类型方面给开发者手头留了一个最灵活的工具。 线程 vs 协程唤醒一个线程需要巨大的资源开销。在一个现代化系统上，一个线程非常容易就能吃掉 1M 多的内存。在当前的上下文中，我们可以通过调用协程（根据文档）来作为“轻量级”的线程。通常，一个协程坐落在一个实际的线程池当中，专门用于后台任务的执行操作，这也就是协程为什么如此高效的原因。它只会在需要的时候才会使用系统资源。参考如下代码： 1234567val jobs = List(100_000) &#123; launch &#123; delay(1000) print(\".\") &#125;&#125;jobs.forEach &#123; it.join() &#125; 如果你不使用协程而是使用实际的线程，那么程序将会非常耗时，甚至有可能被系统终结运行。一个 OutOfMemoryException 内存溢出的异常在没有使用协程而是大量线程运行下很容易发生，这并不是什么新鲜事了。 原理是什么？让我们看一下 async{} 函数的签名是什么样子的！ 12345public fun &lt;T&gt; async( context: CoroutineContext = DefaultDispatcher, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; T): Deferred&lt;T&gt; 第一个参数是 CoroutineContext ，它定义了线程执行的位置。它有个默认值，最终指向一个定义好了的线程池。当然这完全可以使用其他实现方式。在上面那个例子中，我是在 UI 这个协程的上下文中使用 launch 函数，来自于 Anko 库。在那种特定上下文的情形下，调用一个协程可以保证与 UI 相关连的代码（比如设置标签的文本）都能在 UI 线程中被调用。 第二个参数 start 是指明协程何时应该开始执行。默认情况下，当运行到 async{} 或者 launch{} 函数的时候，协程内部任务就开始执行。通过使用 CoroutineStart.LAZY 这个值，可以让协程只在开发者显式调用返回的 Deferred&lt;T&gt; 实例或者 Job 实例的 await() 方法或者 join() 方法才开始运行。 神奇的状态机协程的内部实现机制涉及到一些关于编译器危险魔法的黑色艺术。作为简化描述，这里发生的事情包括： 每一个挂起的函数和 lambda 表达式都有一个隐藏的参数，它在函数唤醒的时候会被隐式地传入到函数中。这个参数就是一个 Continuation 实例，它代表着一段应该在某个协程挂起后才执行的代码块。 让我们看看这个 await 函数，就像下面的代码： 1suspend fun &lt;T&gt; Deferred&lt;T&gt;.await(): T 然而，实际上它更像这样： 1fun &lt;T&gt; Deferred&lt;T&gt;.await(continuation: Continuation&lt;T&gt;): Any? 这个 await 函数的返回值类型参数 T 现在是 continuation 里的类型参数了。结尾返回值的签名 Any 是用于控制协程运行的流程。如果它被挂起，那么这个 await 的结果将会是一个特殊的值： COROUTINE_SUSPENDED 。如果没有被挂起，它会返回这个函数的类型参数 T 的结果。 对应于每一个协程的 lambda 表达式，都将会在编译期间创建一个新的类。这个类本质上就是一个状态机。编译器会分析这些代码并查找那些挂起的函数 —— 这些函数的位置点就对应这个状态机的当前状态（因为这是程序能被挂起暂停的地方）。 根据我们的代码示例如下： 12345launch(UI)&#123; val userString = fetchUserString(\"1\").await() // suspension point #1 val user = deserializeUser(userString).await() // suspension point #2 showUserData(user)&#125; 在这个生成的类中，当运行代码所在的线程没有被阻塞时，程序的执行将从某个状态跳到另一个状态。在某个挂起的函数执行结束后，同时函数返回结果也处于可用状态，那么它的 Continuation 参数将会触发这个状态机，使其跳转到下一个状态中。 异常处理异常处理和平常没两样。想象一下之前所描述的状态机被嵌入到一个巨大的 try/catch 代码块中！如果某个地方抛出了一个异常，它将会被捕获并传播下去，意味着你不需要做任何的改变。工作照常进行。 123456789101112launch(UI) &#123; progressBar.visibility = View.VISIBLE try &#123; val userString = fetchUserString(\"1\").await() val user = deserializeUser(userString).await() showUserData(user) &#125; catch (ex: Exception) &#123; log(ex) &#125; finally &#123; progressBar.visibility = View.GONE &#125;&#125; 可取消作业取消一个协程是可行的，类似取消线程的运行： 1234val job = launch &#123; // do work&#125;job.cancel() 调用 Job 或者 Deferred&lt;T&gt; 实例的 cancel() 方法将会终止协程的内部运行，前提是处理 isActive 标志被正确实现。 12345val job = launch &#123; while (isActive)&#123; //do work &#125;&#125; 同时， isActive 的值在标准库中会在子协程的挂起点之间被检查，所以你仅仅只需检查你自己的处于长时间计算运行代码块中的 isActive 值就可以了。 总结协程依然还处在实验阶段，意味着 API 会发生变化，但是这些特性确实已经很稳定 —— 它会一直在这里的。 JetBrains 公司在开发者背后全力以赴地开发，我已经迫不及待地想看到并行编程的将来会是怎样了。值得一试，这是肯定的！ 资源Andrey Breslav - Kotlin CoroutinesMCE 2017: Svetlana Isakova, Coroutines in KotlinKotlinlang.org CoroutinesGithub.com Kotlin coroutines","tags":"kotlin 翻译"},{"title":"【学习笔记】Unity3D官方游戏教程：2D Roguelike","url":"/2017/10/12/learning-notes-of-2d-roguelike-tutorial-in-unity3d/","text":"一、前言继续上次的 3D 游戏： Survival Shooter 以及 Tanks tutorial 学习总结之后，这次是官方的另一个游戏教程： 2D Roguelike 这是官方的一个 2D 游戏，也是自己认真学习并制作的第一个 2D 游戏。相对于 3D 游戏， 2D 游戏制作和代码编写上感觉会简单点，但是不能小瞧 2D 游戏，毕竟手机上很多游戏都是 2D 画面。 最近很忙，写代码的时间大幅缩水，编写代码的效率也降低了不少，得加油了！总之，学而时习之不亦乐乎，学而不思则罔，思而不学则殆！没毛病，老铁！ 二、知识点1. DontDestroyOnLoad 的使用 我们知道，每次加载新的场景的时候，所有当前场景的物体都会被销毁，如果想要保存当前场景的一些数据，我自己的做法是保存数据到一个全局类中。不过，通过这次学习可以使用 DontDestroyOnLoad 来保证当前物体不会被销毁。 GameManager.cs1234567891011121314public static GameManager instance = null;private void Awake() &#123; //确保当前 GameManager 是单一实例 if (GameManager.instance == null) &#123; GameManager.instance = this; &#125;else if (GameManager.instance != this) &#123; Destroy(this.gameObject); return; &#125; //保证当前 GameManager 不会被销毁 DontDestroyOnLoad(this.gameObject);&#125; 这里新建了一个静态实例是为了能在其他地方引用到它，而且这个实例是唯一且数据不会被销毁的。 2. 关卡场景加载方法 在 Unity 当中加载场景非常简单，不过那是“简单的场景”，如果场景非常庞大，想象一下，加载新的场景是需要时间的，这时候我们恰好又要在场景加载完后做一些初始化，初始化代码怎么放呢？ 这里可以使用 Unity 中的 RuntimeInitializeOnLoadMethod 标签（我暂时这么叫吧，哈），结合 C# 中的 delegate 时间机制，非常简单就能实现，参考如下代码： 1234567891011121314//加载场景的代码，注意放到方法里SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex, LoadSceneMode.Single);//这个方法只家在一次，这个标签的参数指明了这个方法是在场景加载完后才会调用//（否则这个方法会在场景加载开始的时候就会调用，这不是我们想要的）[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]private static void CallbackInitialization() &#123; SceneManager.sceneLoaded += OnSceneLoaded;&#125;// C# 事件，调用这个方法！private static void OnSceneLoaded(Scene scene, LoadSceneMode mode) &#123; //After scene loaded, do something here...&#125; 这个对我来说是新知识点，有待加强学习啊！ 3. 几个关键字：abstract/protected/virtual/override/new 学过 Java 的同学对方法重写非常熟悉，但是 C# 中的一些机制却又有另一片天空，这个 2D 游戏中就让我重新认识了不少关键字： abstract 、 virtual 、 new 等 以游戏代码为例， Player 玩家和 Enemy 敌人都是继承于 MovingObject 基类的： 1234567891011121314151617181920212223public abstract class MovingObject : MonoBehaviour &#123; private int foodPoints; protected new Rigidbody2D rigidbody2D; protected virtual bool AttemptMove&lt;T&gt;(int xDir, int yDir) where T : Component &#123; //do something here... &#125; protected abstract void OnCantMove&lt;T&gt;(T component) where T : Component;&#125;public class Player : MovingObject &#123; protected override bool AttemptMove&lt;T&gt;(int xDir, int yDir) where T : Component &#123; //do something here... &#125; protected override void OnCantMove&lt;T&gt;(T component) &#123; //do something here... &#125;&#125;public class Enemy : MovingObject &#123; protected override void OnCantMove&lt;T&gt;(T component) &#123; //do something here... &#125;&#125; 简单的说一下代码中的关键字的含义： new 关键字用在属性面前用于区分（隐藏）基类同名的属性，比如基类 MonoBehaviour 就有一个属性是： rigidbody2D abstract 用来描述抽象类和抽象方法，抽象方法没有具体实现，但是子类必须实现 virtual 也是用来描述抽象方法的，但是这个方法并不抽象，可以有实际代码，子类可以不重写，它的作用就是告诉子类：你可以重新我 protected 和 override 就没什么好说的了，这和 Java 中差不多，表示子类属性方法可见性以及重写父类方法（ C# 父类中的 virtual 方法） 4. Unity 中各种平台代码的混写方式 这个好像和 C++ 中写法一样，不是很熟悉，不过也很简单，模板代码吧： 123456789#if UNITY_IOS || UNITY_ANDROID private Vector2 touchOrigin = -Vector2.one;#endif#if UNITY_IOS || UNITY_ANDROID //code here for MOBILE platform#elif UNITY_STANDALONE || UNITY_EDITOR || UNITY_WEBPLAYER //code here for other platform#endif 三、总结没什么好说的，继续学习！ 资料：2D Roguelike (Unity3D) ： https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial简单易懂的解释c#的abstract和virtual的用法和区别： http://blog.csdn.net/wzj0808/article/details/51388034","tags":"unity3d"},{"title":"【读书笔记】《Kotlin in Action》学习笔记（下）","url":"/2017/10/03/reading-notes-of-kotlin-in-action-part-2/","text":"一、前言 读书笔记的上部分请参考：【读书笔记】《Kotlin in Action》学习笔记（上） 另外，关于我在 mobilehub 微信留言中免费获赠中文版《 Kotlin 实战》书籍的留言我也贴上，当时我回答的时候一方面想着能意外收获一本书，另一方面还是非常想推荐这边书给读者朋友们！ 二、笔记 1、 操作符重载要注意的 a += b 与 a = a.plus(b) 或者 a.plusAssign(b) 两者都完全等同（ + - * / % 一样） 1234val list = arrayListOf(1, 2)list += 3 //list = [1, 2, 3]var newList = list + 4 //newList = [1, 2, 3, 4]newList = list + listOf(5, 6) //newList = [1, 2, 3, 5, 6] 如果 plus 和 plusAssign 两个都有定义，参数也一样，那么会出现编译模糊问题（ + - * / % 一样） 123456789101112data class Point(var x:Int = 0, var y:Int = 0) &#123; operator fun plus(otherPoint: Point):Point &#123; return Point(otherPoint.x + this.x, otherPoint.y + this.y) &#125;&#125;fun main(vararg parameters:String) &#123; var p_var = Point() val p_val = p_var + Point(1, 1) p_val += p_var //Error: val cannot be reassigned. p_var += p_val //OK!&#125; 上面的代码很显然是没问题的，注意 val 变量不能赋值。但是，如果添加下面的代码（ 通过扩展给 Point 类新增 plusAssign 方法）就是画蛇添足，会出现问题： 1234567891011operator fun Point.plusAssign(otherPoint:Point) &#123; this.x += otherPoint.x this.y += otherPoint.y&#125;fun main(vararg parameters:String) &#123; var p_var = Point() val p_val = p_var + Point(1, 1) p_val += p_var p_var += p_val //Error: Assignment operators ambiguity&#125; 把上面的 plusAssign 方法签名（参数类型）改一下可以使用，但意义已经改变 123456789operator fun Point.plusAssign(otherInt:Int) &#123; this.x += otherInt this.y += otherInt&#125;fun main(vararg parameters:String) &#123; var p_var = Point() p_val += 99&#125; 2、 型变和协变（ in 和 out ）参数在构造函数中不受约束 这又是一个特例！我们知道，使用 in 的参数是不能作为输出返回的，而使用 out 则作为输出而不能作为参数传入，下面两个接口就是这样，弄反了就出问题： 123456interface IOutParameter&lt;out T&gt; &#123; fun takeOut():T&#125;interface IInParameter&lt;T&gt; : IOutParameter&lt;T&gt; &#123; fun takeIn(`in`: T)&#125; 再看类的构造函数，这是不受形参限制的，注意参数的位置： 1234// Note that constructor parameters are in neither the [in] nor [out] position.// Even if a type parameter is declared as out, you can still use it in a constructor parameter declarationopen class Animalclass Herd&lt;out T: Animal&gt;(vararg animals: T) 3、 使用形参的一个正确姿势 这是一个非常简单的问题，对于大部分人来说，由于缺乏经验，我把这一条也作为书签记录下来，提醒自己可以如何优化（下面是官方例子）。首先看原始版本，拷贝一个列表到另一个： 12345fun &lt;T&gt; copyDataVersion1(source: MutableList&lt;T&gt;, destination: MutableList&lt;T&gt;) &#123; for (item in source) &#123; destination.add(item) &#125;&#125; 上面的代码其实不合理（后面有说明），难道一定要同类型才能复制吗？ T 的子类不能被复制过去吗？那么根据这个问题有了下面的改进： 12345fun &lt;T: R, R&gt; copyDataVersion2(source: MutableList&lt;T&gt;, destination: MutableList&lt;R&gt;) &#123; for (item in source) &#123; destination.add(item) &#125;&#125; 上面的代码搞定了子类的数据复制，到此结束！？当然没有， Kotlin 提供了一个更加优雅的解决方案，不信你看看下面的代码： 12345fun &lt;T&gt; copyDataVersion3(source: MutableList&lt;out T&gt;, destination: MutableList&lt;T&gt;) &#123; for (item in source) &#123; destination.add(item) &#125;&#125; 什么叫做优化？什么叫做改进？学习了！下面是测试代码： 1234567fun main(vararg parameters:String) &#123; val source = arrayListOf(1, 2, 3) val destination = arrayListOf&lt;Any&gt;() //copyDataVersion1(source, destination) //Error! Cannot compile! copyDataVersion2(source, destination) //Fine. copyDataVersion3(source, destination) //Nice!&#125; 4、 Kotlin 中 DSL 使用带有 object 参数的中缀函数 我只想说，“厉害了，我的 Kotlin 哥”！ Kotlin 中 DSL 真的很好用，像大名鼎鼎的 anko 库，使用 DSL 实现 Android Layout 非常给力啊，还有 SQL 数据库操作，另外用过一段时间的 TornadoFX ，用 DSL 写 GUI 程序也是给力极了！ 看下面一句话，还是来自教材： 1\"kotlin\" should start with \"kot\" Sorry ，说错了，不是一句话，是一段代码！对，这段代码没啥稀奇的了，不就是中缀函数拼凑起来吗？ 1\"kotlin\".should(start).with(\"kot\") 没错，但是他的精髓你发现了没？精髓在于 start 的妙用！它是一个 object 单例，那么既然是单例为啥不直接使用，还要去作为 should 函数的参数呢？这不是毫无意义吗？ No ！这是 DSL 哦，它并不是作为数据参数传递给函数，而是作为语法的一部分！！！因此你可以有很多 object ，作为不同的语法使用，这就是精髓之处啊！ 我相信，看了下面的代码你就能一目了然、豁然开朗了！ 12345object startinfix fun String.should(x: start): StartWrapper = StartWrapper(this)class StartWrapper(val value: String) &#123; infix fun with(prefix: String) = if (!value.startsWith(prefix)) throw AssertionError(\"String does not start with $prefix: $value\") else println(\"OK\")&#125; 激动的我赶紧写下了几行流利的英语： 123\"kotlin\" should start with \"kot\"\"kotlin\" should end with \"in\"\"kotlin\" should have substring \"otl\" 5、 Bonus： 使用 inline 属性 对，你没看错，这是额外加的一个新姿势，并不是从《 Kotlin in Action 》书中学到的，看到了我就马上记下来了，写到一起作为学习笔记吧。 参考以下代码，扩展一个属性非常简单： 12345678910111213inline var View.isVisible get() = visiblity = Visibleclass MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.layout_activity_main) val button = this.findViewById&lt;Button&gt;(R.id.button) if(button.isVisible) &#123; toast(\"I am visible!\") &#125; &#125;&#125; 毫无疑问代码是没有问题的，那么我们看下反编译 Kotlin 后的 Java 代码（无关省略）： 123if(GlobalKt.isVisible((View)button)) &#123; ToastsKt.toast(this, (CharSequence)\"I am visible!\");&#125; 很正常啊， Kotlin 的风格，使用静态方法完成扩展呀。但是，我就是没想到为啥不用 inline 呢？省去静态方法，不是更快更方便吗？ 12val View.isVisible inline get() = this.visibility == View.VISIBLE 反编译后： 1234View $receiver$iv = (View)button;if($receiver$iv.getVisibility() == 0) &#123; ToastsKt.toast(this, (CharSequence)\"I am visible!\");&#125; 是不是更加得体了呢？反正我是这么认为的，省去了没必要的静态类方法。另外， inline 也可以写得更加优雅，也有需要注意的地方哦： 123456789101112131415inline val View.isVisible get() = this.visibility == View.VISIBLEinline var View.someVarProperty:String get() = \"OK\" set(value) &#123; println(\"Value was set!\") &#125;//Error! Won't compile!var upperCaseString:String = \"\" inline get() = field.toUpperCase() inline set(value) &#123; println(\"Field set!\") &#125; 更多可以参考原文： Inlining Kotlin Properties 三、完","tags":"kotlin"},{"title":"【翻译】Realm ， ObjectBox ，还是 Room ，哪个适合你？","url":"/2017/09/30/translation-of-realm-objectbox-or-room-which-one-is-for-you/","text":"一、前言原文标题：Realm, ObjectBox or Room. Which one is for you?原文地址：https://notes.devlabs.bg/realm-objectbox-or-room-which-one-is-for-you-3a552234fd6e 二、正文选择，选择，还是选择。当面对数据存储的时候，安卓开发者有太多的类库可选。不论是处理少量对象，还是构建一个大型的数集，这些工具都能完成使命，等着我们去使用。其中有一些是我们经常打交道的，比如 shared preferences 和 纯 SQL 语句，其他的则需要额外的一些依赖。庆幸的是，我保证，在这里我并不会去讨论如何写一个很长的又合理的查询语句。相反，接下来我将会对这些大联盟玩家进行类比，包括：最新发布的 Room 持久化类库 ，年老健壮的 Realm ，以及鲜为人知的新秀 ObjectBox ，它最近才发布 beta 版本。至于最终的选择权，由你决定，当然到最后你也会非常（或多或少吧）清楚地知道应该选择哪一个。毫无例外，在我们开始进入泰坦大战之前，让我先来给它们作一下介绍。 Realm 自从它的理念发布（ 2011 年左右，原名 “ TightDB ”）以来 Realm 就自然而然地成为了许多开发者的开发首选。为什么呢？你会这么问。因为简单（几乎完全使用最标准的 Java 对象），速度快（大部分是采用 C++ 编写），并且由于 SQL （因为没有使用它）。无需深入太多细节，你就能轻松地创建一个 Realm 数据库并使用它——甚至还能做的更多。这个库无需太多配置，而且官方文档也能手把手地教会你如何一步一步的完成。 存储数据对象所需要做的第一件事就是建立一个数据模型： 12345open class Box( @PrimaryKey var size: Long = 0, var name: String = \"\", @Ignore var tempReference: Int = 0) : RealmObject() 这里如果你使用 Kotlin 的话，唯一值得注意的是，所有的变量必须都要有默认值。注解和继承于 RealmObject 的必要性，都能很好地解释这些代码（希望如此），那么我们继续下一步。 Realm 使用起来如下面的代码一样，非常简单： 1234567891011Realm.init(context)val realm = Realm.getDefaultInstance()val box = realm.where(Box::class.java).findFirst()realm.executeTransaction &#123; //modifying an existing object box.size = 20 box.name = \"John\" //creating a new object val secondBox = realm.createObject(Box::class.java) secondBox.size = 30&#125; 完整的例子在此 注意：基于以数据库为中心的原则，我把多线程的任务交给你了。 注意2：的确，这个 box 的名字就是 John 。 Room 持久化类库 进入房间（ Room ）！一个最新的，光环最闪耀的谷歌官方类库。 Room 在官方的架构指南中占据着一个中心位置，它提供在 SQLite 上的一个抽象层，允许在充分利用 SQLite 的强大基础上进行流畅地数据库访问开发。它完美地剥离开了 SQL 层，并向开发者展示出清晰、易懂的 Java 语法方法。所以，还记得我保证过没有查询语句吗？但是现在我要写一些查询语句了！不过不要担心， Room 包含的一些安全特性，能够提示你万一出现的那些令人讨厌的错误。 当然，至少在我写这篇文章的时候是这样（或许在很长一段时间之后也是这样）， Room 是城里最受欢迎的那个孩子，但是我将会尽量保持对他做一个简短的介绍。 在 Room 中有 3 个主要的组件，都是使用注解来展示说明： Database ：你可以使用这个组件来创建数据库的持有者。这个注解定义了一系列的实体，以及类的相关内容——数据中一系列的数据访问对象（ 一些 DAO ）。同时它也是底层数据连接访问的枢纽。这个注解标记的类必须是一个抽象类并且继承于 RoomDatabase 。你可以使用 Room.databaseBuilder() 或者 Room.inMemoryDatabaseBuilder()获取到它的一个实例。 Entity ：这个组件代表了数据库中一行数据的类。对于各个实体，数据库中的表的创建就是为了存储它们的实例。你必须通过数据库类中的实体数组来引用实体类。 DAO ：这个组件代表一个数据访问对象的类或者接口。 DAO 负责定义数据库访问的方法。用 @Database 注解的类必须包含一个抽象的方法，它含有 0 个参数，并返回一个使用 @Dao 注解的类。 下面是上面所提到过的组件的 3 个实现（羞愧地从这篇精彩的文章中复制了过来）： 1234567891011121314151617181920@Entity(tableName = “task”)data class Task(@ColumnInfo(name = “completed_flag”) var completed: Boolean = false,@ColumnInfo(name = “task_desciption”) var description: String) &#123; @ColumnInfo(name = “id”) @PrimaryKey(autoGenerate = true) var id: Long = 0&#125;@Dao interface TaskDao &#123; @Query(“select * from task”) fun getAllTasks(): List&lt;Task&gt; @Query(“select * from task where id = :p0”) fun findTaskById(id: Long): Task @Insert(onConflict = REPLACE) fun insertTask(task: Task) @Delete fun deleteTask(task: Task)&#125;@Database(entities = arrayOf(Task::class), version = 1, exportSchema = false)abstract class AppDatabase : RoomDatabase() &#123; abstract fun taskDao(): TaskDao&#125; 创建一个数据库并访问它的方法非常简单： 1234var database = Room.databaseBuilder(context, AppDatabase::class.java,”db”) .allowMainThreadQueries().build()database.taskDao().insertTask(Task(description = “simple!”)) ObjectBox 作为最新的成员， ObjectBox 给数据库带来了一大堆功能。但是在如此高的门槛面前，这个崭新的无 SQL 技术库能够和其他的大牌分庭对抗吗？毫无疑问，如果和 Realm 以及 Room 面对面肉搏的话，它必须重拳出击。结果的确如此，它不止一次重锤出击，而是出了一系列的重锤对抗。这里有这个新生库所突出的一些亮点： 速度：如同 Realm ， ObjectBox 一样，能够提供卓越的性能，甚至某些时候它能够完全碾压其竞争对手（稍后再谈这个）。 查询生成器：使用 ObjectBox 查询对象和编译时错误检查都非常简单。 数据关联：对象的引用/关联是内建的内部类型，它们都属于原生本地引用。 无需手动数据模式迁移：它能够自动处理新版本对象所新加的、删除的、重命名的属性。 等等，等等。 那么实际代码中它是怎样的呢？ 它必须有定义的模型，至少目前来说你应该很熟悉了： 12@Entitydata class Note(@Id var id: Long = 0, val text: String) ObjectBox 使用叫做 Boxes （猜一下）的对象来存储并操作数据。只需 2 行代码就能把数据库和操作分离： 确切地说，“数据存储盒子”对象，应该放置在你的 Application 类中： 1MyObjectBox.builder().androidContext(App.this).build() 每个“盒子”对应你的数据库中的数据模型。这些盒子作为一个交互点服务于你和你的数据库之间。 1var notesBox = boxStore.boxFor(Note::class.java) 一个很重要的细节是：这些盒子类型都是自动生成的，这意味着你所需要担心的事情变得更少。 一旦完成了这些，你就可以准备下一步行动了，这里有一些可用的方法提供给你使用： 123notesBox.put(note)notesBox.remove(note)notesBox.count() 完整的 Box 类方法列表可以查看它的 Java 文档。这里有一件事需要提醒注意的是名叫 DaoCompat 的兼容层，允许使用像 greenDAO 一样的 API 来操作 ObjectBox 。 比较 到目前为止，所有的类库都做到了差不多相同的事情，有些需要，有些则不需要 SQL 语句。然而，我们更感兴趣的是它们的区别。如下图，我通过 3 种不同的方式分别测试了它们的性能，测试过程使用的是这个开源的性能测试应用程序。 测试 100k/10k 个元素的性能，以毫秒为单位 非常漂亮而又很有意思的结果，你觉得呢？从这个测试中可以很清晰地看到，大多数情况下 ObjectBox 都能碾压所有其他竞争对手。并且，当然随着元素的数量级的增加，差距变得越来越大！对于一个新成员来说，表现得还行。可以说非常好。 查询同样看上去是 ObjectBox 的一个强项。测试中采用了字符串和索引，结果不言自明。 那么 apk 的大小又如何呢？这几个类库对我们项目的整体速度影响又有几何？好吧，我们可以使用最新发布的 apk 分析工具来精确地查看一下每一个类库其影响程度如何。 ObjectBox 和 Realm 分别占用空间高达 1-1.5MB 和 3-4MB （这个大小取决于手机的框架），而 Room ，作为一个 SQL 包装工具，仅仅占用了 50KB 的大小。但是为秉承安卓开发者一贯作风，我们还必须针对那烦人的方法数量限制进行一下统计。在这个方法层面上， Room 那谦虚的 300 个方法数 看起来又要再次领跑比赛了。接着是有着 1300 个方法的 ObjectBox 和 2000 个方法的 realm。 明智的是，这几个竞争者都各自提供了一些额外的特性。 Room 提供了 SQLite 所能做的一切，并附加了一些其他的功能。比如迁移机制，而且这完全是可以进行测试的。相反， ObjectBox 甚至都不需要这个，因为它会自动处理大部分情况下的迁移（尽管对于某些改变，它需要额外的信息来明确目标）。 Realm 则装备了最多的令人惊奇的武器，它的这些特性包括自定义配置，加密和更多其他功能（这也是它尺寸比较大的原因之一）。 结论 我们可以看到，不论你选择了哪条路，它都有着自己的长处和短处。如果你需要速度和效率，很明显 ObjectBox 是一个不错的选择。然而，如果你被应用的大小所限制，被那 64k 个方法所限制，同时你也愿意去使用 SQL 语句，那么 Room 是一个很好的解决方案。另一方面，针对 Realm ，可能不是最快的，也不是最小的，但是在它们背后，在经历了超过 7 年的问题反馈检测和改进之后，它给大家提供的是最稳定的、无 bug 的、理智的解决方案。 至于选择哪一个，这取决于你，但是请记住，一个应用程序只要你选择对了就足够了（当然也取决于你的代码，但是那又是另一个话题了）。 三、完 作者：Radoslav Yankov平台：Dev Labs标签： Android Objectbox Realm Room Comparison","tags":"kotlin android 翻译"},{"title":"【读书笔记】《Kotlin in Action》学习笔记（上）","url":"/2017/09/16/reading-notes-of-kotlin-in-action-part-1/","text":"一、前言写这篇文章的时候心里真的有一万个草泥马在我心中奔腾而过，简要说明三点： 最近太忙了，给学生补课占据了自己不少时间，已经有一个多月没有认真写文章，写代码了！ 我这次利用周末时间写的这个主题分两部分，其实太长的文章也不适合阅读，虽然偷了点懒但也是有道理的。 我第一次边看 PDF 电子书边做笔记，受益匪浅，我建议每一位同志都应该这样做。 另外，我的读书笔记是在一本网上下载的 PDF 书：《 Kotlin in Action 》上做的，质量不怎么好，不过后来通过 mobilehub 的微信赠书活动有幸免费获得了一本中文版 《 Kotlin 实战》，目前还没有时间看，我想自己看完后还会增加一些其他的基础知识点，作为自己随时查阅的资料和大家一起学习探讨的话题吧。 二、笔记1、 Kotlin中的“内部的类”默认为“非内部类” 也就是说，写在某个父类内部的子类是不能直接访问这个父类的属性和方法的，有别于 Java 中的内部类！在 Kotlin 中如果我们需要写内部类的话，一定要使用 inner 关键字！ 1234567891011121314//nested classes aren't inner by defaultclass OuterClass &#123; private val outerProperty = \"outer\" private val innerClass1 = OuterClass.InnerClass1() //ok //private val innerClass2 = OuterClass.InnerClass2() //compile error class InnerClass1 &#123; //fun reachToOuterClass() = outerProperty //compile error &#125; inner class InnerClass2 &#123; fun reachToOuterClass() = outerProperty //ok &#125;&#125; 2、 Kotlin中的数据类不会自动处理非首要构造函数中的属性 有时候我们在使用 data class 的时候也需要使用其他方法或者其他计算出来的属性（比如类似 swift 中的 computed property 之类），这个时候这个属性就没必要定义在 primary constructor 构造函数中，而是定义在类里面（ secondary constructor ），这时候 Kotlin 中的数据类只会自动计算定义在 primary constructor 中的属性的 hashCode() 、 equals() 方法，而其他的不会。 12345678910//properties that aren’t declared in the primary constructor //don’t take part in the equality checks and hashcode calculationdata class DataClass(val primaryProp:String = \"[primary_constructor_property]\") &#123; val secondaryProp:String = \"[secondary_constructor_property]\"&#125;fun main(vararg parameters:String) &#123; val data = DataClass() println(data) //print: DataClass(primaryProp=[primary_constructor_property])&#125; 这一点我在使用安卓 Room 数据库的时候遇到过，所以有时候我们还是有必要自己动手在 data class 中重写 toString() 这些方法的。 :joy 3、 Kotlin中的companion object可以实现接口 这点对我来说，真的非常怪异！我目前还从未使用过，在之后开发过程中引起注意，希望自己能够弄懂这一点！一直认为 companion object 就像 Java 中静态方法一样，没任何区别，但是它居然还能实现 interface 接口，有点不可思议啊！下面的代码来自官方例子的修改，大家可以研究一下： 12345678910111213141516//A companion object can implement interfacesinterface JSONFactory&lt;out T&gt; &#123; fun fromJSON(jsonText:String):T&#125;class Person(val name:String) &#123; companion object:JSONFactory&lt;Person&gt; &#123; override fun fromJSON(jsonText:String):Person = Person(\"Kotlin\") &#125;&#125;fun &lt;T&gt; loadFromJSON(factory:JSONFactory&lt;T&gt;, jsonText:String):T = factory.fromJSON(jsonText)fun main(vararg parameters:String) &#123; loadFromJSON(Person, \"\"\"&#123;name:\"kotlin\"&#125;\"\"\")&#125; 4、 传入lambda和传入object的一个区别 在 Koltlin 中 SAM(Single Abstract Method) 参数我们一般传入的是 lambda 表达式，简洁实用，而且 lambda 作为最后一个参数还可以放小括号后面，和 swift 一样方便。当然，我们也可以采用和 Java 一样的方式：使用 object 实现 SAM 接口，但是这样做的话，可能会在每次调用函数的时候都会创建一个新的 object 实例。参考下面的代码，来自官方的例子。 下面是 Java 中的代码，为了使用 Runnable 作为 lambda 参数： 12345public class TheJavaClass &#123; public static void postponeComputation(int delay, Runnable computation) throws InterruptedException &#123; System.out.println(computation); &#125;&#125; 下面是 Kotlin 中测试代码，注意，使用 object 可以通过设置为成员属性变量的方式避免每次实例化，而使用 lambda 时如果引用了成员属性那么会变成和 object 方式一样每次调用都会创建实例！（注释后面为输出的数据地址，结果每次都会不同）： 12345678910111213141516171819202122232425262728293031//When you explicitly declare an object, a new instance is created on each invocation//If the lambda captures variables from the surrounding scope, it’s no longer possible to//reuse the same instance for every invocationclass Test &#123; var localProperty = \"Local\" val runnableObj = object : Runnable &#123; override fun run() &#123; &#125; &#125; fun testObject() = TheJavaClass.postponeComputation(1000, object : Runnable &#123; override fun run() &#123; &#125; &#125;) fun testObjectWithNamed() = TheJavaClass.postponeComputation(1000, runnableObj) fun testLambda() = TheJavaClass.postponeComputation(1000) &#123; &#125; fun testLambdaWithRef() = TheJavaClass.postponeComputation(1000) &#123; localProperty = \"Local_m\" &#125;&#125;fun main(vararg parameters:String) &#123; val test = Test() test.testObject() //@2626b418 test.testObject() //@5a07e868 test.testLambda() //@76ed5528 test.testLambda() //@76ed5528 test.testObjectWithNamed() //@2c7b84de test.testObjectWithNamed() //@2c7b84de test.testLambdaWithRef() //@3fee733d test.testLambdaWithRef() //@5acf9800&#125; 5、 Kotlin中的类型参数(T)不加?标记也能为空 嗯，唯一一个 Kotlin 中的特例：不需要在类型参数（ Type Parameter ）后面加 ? 可空标记它就能用于 null 空值！这是使用 Kotlin 的时候需要注意的。下面是官方的例子，一眼就能看明白。 12345678910111213//A type parameter can be substituted for any type, including a nullable type//Note that type parameters are the [only] exception to the rulefun &lt;T&gt; printAnythingHashCode(t: T) &#123; println(t?.hashCode()) //\"T\" is inferred as \"Any?\"&#125;fun &lt;T&gt; printNullableHashCode(t: T?) &#123; println(t?.hashCode())&#125;fun main(vararg parameters:String) &#123; printNullableHashCode(null) //this is fine printAnythingHashCode(null) //it works fine too&#125; 三、未完待续……","tags":"kotlin"},{"title":"【翻译】30多个短小而又专业的最佳安卓开发者建议","url":"/2017/08/14/translation-of-30-bite-sized-pro-tips-to-become-a-better-android-developer/","text":"一、原文文章是我在自己的 Feedly 订阅上看到的，两个地方有原文的发布（新版和旧版）：30+ Bite-Sized Pro Tips to Become a Better Android Developerhttps://techbeacon.com/how-become-better-android-developer-30-bite-sized-pro-tips 小建议大用处！建议有能力的朋友优先阅读原版，翻译有不当之处请海涵哈！ 二、译文标题： 30 多个为成为一名更好的安卓开发者的短小而又专业的建议成为一名安卓开发者很容易，但是要成为一名成功的、突出的安卓开发者却不那么容易。这需要付出很多的努力，耐心，奉献和毅力才能做到。 我并没有什么捷径或者简单的方法来告诉你让你成为一名成功的开发者。但是如果你愿意身心投入且付出努力的话，你肯定会得到应得的成功的。 应大家的请求为成为一名更优秀的安卓开发者，这里有一些从我的经验中吸收的小巧而专业的小窍门来助你一臂之力。所以，如果你决定从事安卓开发或者已经是一名安卓开发者的话，那么你算是找对地方了。 好了，不需要再浪费口舌了，让我们开始吧。 1. 进一步熟悉安卓内部框架 我并不是告诉你怎样去熟悉文档，我指的是实实在在的安卓框架的源码。我见过很多开发者很害怕查看或者深入安卓框架的内部，探索其实际工作原理和不同的模块之间是如何正确地一起运作。 如果你需要提升你的安卓技能，那么请克服对安卓 SDK 内部工作机制的恐惧感，并开始和它成为好朋友吧。 2. 尝试克服对未知的害怕（ FoMo ） 安卓系统很大，非常大。你不可能在一两个月内完全掌握它。随着学习越深入，你会发现越多的内容需要学习。作为一名初学者，很容易也很正常地会出现这种对未知恐惧的害怕。 但是尝试去克服它把。学习那些你确实需要用到的东西，能够让你开始手头正在构建的应用，然后慢慢地开拓你的视野。 3. 开始阅读更多的代码 大部分的开发者不会抽时间阅读其他开发者所写的代码。他们大部分时间只是花在写他们已经知道了的事情上。 但是那并不利于你成长为一名优秀的开发者。也不会增长你的见识。你应该从现在开始看一些开源的应用和类库并开始学习它们。每天 30 分钟的代码阅读量是个非常好的开始。你将会惊讶的发现：还有如此多的东西是你没见过的。 小贴士：这里有一些最好的开源应用程序助你起航 20多个开源安卓程序大大提升你的开发技巧https://blog.aritraroy.in/20-awesome-open-source-android-apps-to-boost-your-development-skills-b62832cf0fa4 4. 考虑学习更多的语言 我并不是要你去学习西班牙语或者中文，而是学习新的编程语言。随着科技的发展，你需要保持自己的知识更新，而不是把自己固定死在安卓一个方面。 这能够开阔你的视野，并能够显著地提升你的安卓开发技巧。下定决心每年至少学习一门新的编程语言吧。但是，请不要在仅仅一周的尝试后就跳过这门语言而放弃学习。尝试着深入这门语言并弄懂它内部的工作原理。 小贴士：看看这篇神奇的文章，来帮助你做一个更好的选择。（剧透 —— 答案是 JavaScript ） 5. 是时候学习 Java 设计模式了 在长远看来，我并不能完全阐明这会对你的安卓开发生涯有多大的影响。任何时刻，你被卡在需要解决的某个严重的程序问题的时候，设计模式着实能帮助你构建一个优雅的解决方案。 你也需要保持和其他程序员一致的节奏，因此他们在谈论关于使用工厂模式或者装饰着模式或者外观模式的时候，你也能够立马懂得他们所指的含义。 给自己定下目标每周学习一个新的设计模式吧。 小贴士：这里有一个极好的资源可以作为你的开始。如果你钟情于书籍，那么你肯定会读一读这个。 6. 开始贡献开源库 如果你已经开发出了一些很有用的东西，并在你自己的应用开发中使用到了，那么考虑开源它吧。在这个过程中有许多的东西是需要你学习的，而且这有助于你成长为一名优秀的开发者。 如果你没有可以开源的项目，考虑浏览其它你所感兴趣的开源项目，并尝试修复一些 bug ，改进其文档注释或者写一些测试等。 即使是最小的贡献量，它仍然对项目维护者保持项目的运作有所帮助。 小贴士：这里有一些良好的指导能够让你开始贡献开源项目。 7. 让你的 IDE 更好地为你工作 准备花更多的时间来了解你所使用的 IDE —— Android Studio 。它所能做的事情比你想象的更多。许多的酷炫特性和快捷方式隐藏着而不为人知，以至于大部分开发者都不了解甚至从来没有尝试探索使用它们。 养成一个探索开发新的、更佳的方式的习惯，让你的工具更好地为你工作，这样能够有效提升你的工作流程和工作效率。 小贴士：这里有一篇很棒的文章能帮助你像专业人士一样掌握 Android Studio 。 8. 是时候正确地架构你的应用了 大部分时间里我们都以放置所有代码到一个活动或者碎片里而结束（你也可以因此怪罪我吧），最终让导致他们成了巨神对象而变得很难维护和测试。 让你的应用适配一个好的架构是非常重要的，像 MVP ， MVVM ， Redux 框架等等。考虑解耦你的应用程序的业务逻辑，交互界面，以及数据结构到不同的层级里，使得他们能够更容易的被管理和测试。 小贴士：看看这些有用的谷歌蓝图能够让你的安卓应用框架更加容易。 9. 学习安卓致简代码指南 你不能忽视了这个。和那些写不出整洁代码的开发者合作会变得很难，至少需要符合安卓开发代码指南。 这根本不是什么高深的技术，而且也不会花费你超过几个小时的时间来学习大部分的 Java 和安卓代码指南基础。这不应该是一次性的学习，而应该是作为开发者的一种习惯上的改变。 小贴士：这里有一篇精彩的资源作为你开始学习标准代码的指南 10. 花一些时间来学习安卓最佳实践 要使自己比其他开发者更加出众，并能构建出整洁美观而又功能完善的应用，你需要开始学习一些安卓开发最佳实践。 这里有一些该做和不该做的条例，能助你成为一名更优秀的开发者，并能让你的应用从其他应用程序中脱颖而出。 小贴士：这里有一个最佳实践文章可以让你做出更好的应用 11. 通过接听电台来充分地高效地利用你的业余时间 尝试高效合理地利用你的业余时间。这些时间属于你从家到办公室或者离开，在健身房锻炼，开车，烹饪的时间等等。而这个时候你那聪明的大脑却处于无事可做的状态。 你可以充分利用这些时间来听一些安卓广播资源。经常性地保持你的大脑尽可能高效地使用这些有用的信息，并努力做到大部分空闲时间的最大利用化。 小贴士：碎片广播和安卓开发者后台是两个让你开始行动的超酷资源广播电台。 12. 不要过于工程化，现实点。 这不仅仅发生在我自己身上，同时我也在一些和我工作的其他开发者伙伴身上也看到了。在开始进行之前就考虑周全是很不错（是非很好），但是过于考虑和过于分析事情会导致最终一事无成，就如同不必要的迷茫，延误和焦虑。 立刻开始行动做那些项目中正确的部分，这样你总是能够适应在之后需要做出改变的规则。 推荐阅读 两年的安卓开发教会我的那些困难和经验https://blog.aritraroy.in/what-my-2-years-of-android-development-have-taught-me-the-hard-way-52b495ba5c51 13. 尝试着学习平面设计 我能理解作为一名程序员，你所主要的重心点在于学习编写更好的代码，这是显而易见的。但是如果你要成为一名完完全全的开发者，你应该开始每天花一些时间来学习并理解关于 UI 和 UX 的设计。 这将会颠覆你对待你自己一直正在使用代码编写应用的看法。尝试着和你团队中的 UI 以及 UX 设计师做更多的沟通和交流的机会，你将会更加深入地了解应用设计。 小贴士：读一读这本书如果你对理解设计如何工作的原理感兴趣的话 14. 开始成为一名完美主义者 这是一个类似：我所谓的“完美主义”并非其他人的“完美主义”的话题。但是作为一个小的建议，始终尝试着帮你所需要发布的版本的产品做到尽可能最好。 不要妥协。不要为了单纯的做事而做事。要对你自己的工作有激情并尝试做得比他人更好。这会让你持续成长并在长远看来会让你成为一名更加成功的开发者。 15. 坚持是成功的关键 如果你想成为一名成功的安卓开发者（或者你生命中其他想要的），那么你需要坚持。 做事情坚持不了几天或者几周就放弃那并不会让你学到什么东西。尝试着描绘一下作为一名安卓开发者在未来几年里你所想要成为的人的模样，坚持并不断挑战自我，最终实现自己的目标。 开始一件事很容易，但是保持同样的激情和奉献精神，长时间坚持下去却很难（非常的难）。 16. 积少成多，逐步深入 作为一名开发者，你应该时常试着把你所遇到的任何复杂的问题或者特性，转化成小型的、简单的和独立的组件，这样做能够很容易地被理解并能快速地解决问题。 不要被一个项目的大小和复杂度所压倒。只要你使用正确的方式，任何问题都能够迎刃而解。从小的部分开始，慢慢积累并逐步扩张。 17. 保持手里有项目的另一个测试版本 经常有一个后台的测试版本项目能够完全改变你学习东西的方式。如果你在安卓开发界遇到什么新的事物，请养成一个立刻就开始新建一个后台测试项目的习惯。 假设你在某个地方发现了一个很有趣的安卓代码库，你应该立刻想到新建一个后台测试项目来使用这个库，而不是仅仅快速地浏览一下它的文档和 API 。这会让你更加熟悉、更加深入地了解这个类库。 18. 开始写一些测试 我没法再强调这个有多重要了。你并不能完全吃透某个特性，除非你用尽心思给它写测试。测试能帮助你的代码构建出一个信心彼岸。 不要犯那种忽略测试或者认为测试只是一个“可选项”的错误了，这会让你的生活更加痛苦并增加许多的问题。记住，一个没有测试的代码很容易立刻变成旧地遗留代码。 推荐阅读 50 多个有用的关于掌握安卓开发的资源https://blog.aritraroy.in/50-ultimate-resources-to-master-android-development-15165d6bc376 19. 考虑适配 TDD 当你在开发一个应用的时候，考虑选择一种机械地而又高效的方式，以便能够顺利地通过测试。 开始遵守 TDD 的“红-绿-重构”周期模式。首先，你所编写的测试可能会失败（红），然后写一些有效的代码让这个测试通过（绿），接着进一步优化并清理整洁这些代码（重构）。 测试驱动型开发是一种编程期间控制自我焦虑的方式。焦虑感会让你变得很具有试探性。焦虑感让你变得不容易沟通。焦虑感会让你害怕发出反馈。焦虑感让你变得心浮气躁。—— 来自 TDD 的案例 20. 设立一个合适的自动发布机制 作为一名开发者，尝试着让自己不要操心那些可以自动完成的东西，比如应用程序质量的测试和发布。 你应该使用那些自动检测程序质量的工具，像 CheckStyle ， PMD ， Lint ， FindBugs 。在合并主要的改变之前运行所有的单元测试和真机测试是必须要做到的。 当所有这些测试通过后，你就会得到一个允许 APK 发布到 Play 商店或者分发到其他你想要的地方的（比如 Crashlytics Beta ）的绿色信号。 小贴士：考虑 Play 商店自动发布机制以及使用这些工具。 21. 拥抱 Reactive 编程的到来 如果你作为安卓开发者想要提升自己的技能，你绝对应该考虑拥抱 reactive 的实现。这会迫使你在构建应用的时候采用完全不同的方式思考问题。 采取 reactive 的方式肯定能够有助于你更加快速地写出交互式应用，并且能够让你的开发更加容易且有趣。 小贴士：这里是一个非常好的学习 RxJava 在安卓应用开发的精彩系列。 22. 学会使用 Kotlin 进行安卓开发 Kotlin 是目前最受欢迎和热议的语言，自从它来到安卓开发界后。它现在也是开发安卓应用的官方支持的语言。这个简洁高效的语言给安卓开发界带来了一丝新鲜的空气。 对于那些被古老、繁琐以及易出错的 Java 所困扰的人们来说，这是发生在安卓开发者身上最大的一件幸事之一。尝试着使用它，你将会重新燃起对你的开发生活的热爱。 小贴士：了解更多关于更好的安卓应用开发你需要开始学习并使用 Kotlin 的原因 。 2017 年为什么你要开始使用 Kotlin 来掌控你的安卓开发https://blog.aritraroy.in/why-you-should-start-using-kotlin-to-supercharge-your-android-development-in-2017-61db1f11d666 23. 参加聚会并和更多的开发者建立社交关系 我们开发者趋向于内向，喜欢坐在一个角落里，和自己的电脑组成一个自我的世界。 但是请走出你自己的舒适区，和其他开发者发生更多的联系和沟通吧。当你参加开发者会议，社交活动以及和其他有着和你共同兴趣爱好的开发者一起谈论问题的时候，你会学习到很多很多的东西。 小贴士：这里是一个发现你所感兴趣会谈沙龙的好地方。 24. 熟悉使用键盘快捷键 试着养成一个尽可能不使用你的鼠标的习惯。在 Android Studio 上几乎所有的操作都可以由快捷方式完成。 这会显著地减少你的开发时间并提升你的工作流程。记住一些键盘快捷键可能会在初始阶段花上一些时间，但是从长远时间来看，它会有助于你进入一个真正无鼠标的工作流程状态。 小贴士：如果你用古老的方式不能记住快捷键，这里有一个超棒的 AS 插件来帮你搞定。 25. 尝试着至少每周学会一个安卓相关的知识 在安卓大千世界里，当你在一开始踏入的时候，有太多需要学习和了解的东西会让你感觉猝不及防。但是如果你给自己下定决心，每周学习一个安卓相关的知识点，那么事情会变得更加容易。 做一个列表记下所有你不会的东西，给他们标上先后顺序和重要性，在接下来每周里开始学习，并一步一步地完成它们。那么在几个月后，你会发现你已经远远不是那个刚开始的自己了。 26. 把所有浪费你时间的事情自动化 我们作为工程师，生来就喜欢偷懒，总是想着找到一种简便的方式来完成一份烦人的工作。 所以，如果你在一天里需要做一些重复且厌烦的事情的时候，尝试着考虑把它自动化吧。这会累计让你每周都节约不少时间，从而可以用来花在做其他高效率以及有用的事情上，并能够减少你的焦虑感。 小贴士：看一下这个神奇的工具，它能帮你连接并自动化你每天所使用的工具之间的沟通。 27. 考虑同时运行两个不同版本的 Android Studio 保持使用一个稳定版本的 Android Studio 用来做你每天需要做的那些很重要的事情。但是也同时考虑保持安装使用一个最新候选版本的 Android Studio 。 有时候早期版本中会有很多令人兴奋的新特性，那都是你很乐意去尽可能尝试使用的。 推荐阅读 30 多个像专业人士一样开发安卓应用的强大工具https://blog.aritraroy.in/30-kickass-tools-to-develop-android-apps-like-a-pro-191e52b9419b 28. 仔细审查所有你一次性添加的第三方类库 在我们需要的时候我们都喜欢使用添加类库，这当然没问题。但是，要养成一个习惯，审查你所一次性添加的所有的第三方类库，并且移除那些你不再需要的库。 如果你仅仅是使用一个类库的一小部分，那么考虑把它分解出来而不是使用整个库。有那么一个可能性的事件是：审查有时候也会帮你更新那些急需更新的旧类库。 29. 学习更好的方法用来重构遗留代码库 不要犯那种一次性重构一个完整的庞大代码库的错误。这样做会把你陷入到没有退路的困境之中。 考虑重构你现在就需要使用的部分代码库，然后慢慢地延伸扩展到你所需要的其他部分。同样，考虑在碰到其他代码之前为你所需要重构而又怀疑会破坏现有功能的那部分写一些测试。 小贴士：这本书完全改变了我使用旧代码的方式。你完全值得看一看。 30. 经常在低端设备上进行开发和测试 如果你想要像专业人士一样开发应用程序，那么不要犯那种总是在高端设备上开发并测试程序的错误。一般来说，我们开发者手头拥有高端的旗舰产品，并且使用它来做应用的开发和测试用。但是这完全正是你需要克制的地方。 尝试着在市场上买点便宜的、低端的设备，并养成在上面开发应用程序的习惯。你将会看到你的应用的一大堆缺陷，而你之前并不知道它们的存在。 31. 买你所能负担起的最好的设备 不要犯那种购买一个低端的工作用机器来做每天工作的错误，那会有损你的开发经验。 考虑使用一个 Mac （超越 Windows ）来做开发。你会爱上它那简介而又稳定的特性的。 从现在开始，如果你要买一台苹果笔记本，那么考虑买一个最合适你自己的版本。几百块（美元，编者按 ）的额外开销并不会伤害你，反而你会感谢自己做下了这个决定的。 希望这些小贴士能够帮助你成为一名更好的安卓开发者。你虽然已经看完并理解了这些条条例例，但是也正是时候把它们转化成实际行动了，只有这样你才能感受到他们的强大之处。 如果你发现这是一篇有用的文章，请考虑推荐它给你的朋友们、室友同学们、竞争对手或者你通过社交媒体认识的任何人。 这篇文章最初发布于： TechBeacon","tags":"android"},{"title":"浅谈学习正则表达式的重要性","url":"/2017/08/10/talk-about-the-importance-of-regexp-in-programming/","text":"一、问题使用 Hexo 搭建博客确实简单又强大，简单在于构建和发布过程，强大在于它的扩展性。关于 Hexo 博客插件功能有兴趣的朋友可以参考我之前的一篇文章：分享几个实用的 HEXO 博客功能插件 ，但是有时候这些功能比较官方，我们还是需要自己动手 DIY 一下才能更好的适应自己的网页。我现在使用的博客 RSS 订阅功能这个插件（ hexo-generator-feed ）就不太适合我自己的博客行情。 问题是这样的，因为我使用了图片懒加载的功能，导致生成的 RSS.xml 文件包含的图片部分是真实地址，部分是预加载图片的地址而不是真实源图片地址： 123&lt;p&gt;&lt;img src=\"http://url/to/imgloader.gif\" data-echo=\"real-image.jpg\"&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=\"real-image.jpg\"&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=\"http://url/to/real-image.jpg\"&gt;&lt;/p&gt; 这个时候就需要自己动手稍微 Hack 一下插件的源码了，对整篇的文字进行查找替换就需要正则表达式派上用场了。 二、解决方法对于 JavaScript 编程我是门外汉，不过好在正则表达式在不同语言之间是通用的，至少大部分场景是这样，那么对于会 Java 的我来说对源码简单修改一下足够了。关于正则表达式这里有一篇文章总结的比较好，刚好介绍了我需要使用的知识点：正则表达式中的不匹配，下面引用的是文章的正则表达式定义表格： 表达式 定义 表达式 定义 表达式 定义 表达式 定义 表达式 定义 [abc] a或b或c . 任意单个字符 a? 零个或一个a [^abc] 任意不是abc的字符 \\s 空格 a* 零个或多个a [a-z] a-z的任意字符 \\S 非空格 a+ 一个或多个a [a-zA-Z] a-z或A-Z \\d 任意数字 a{n} 正好出现n次a ^ 一行开头 \\D 任意非数字 a{n,} 至少出现n次a $ 一行末尾 \\w 任意字母数字或下划线 a{n,m} 出现n-m次a (…) 括号用于分组 \\W 任意非字母数字或下划线 a*? 零个或多个a(非贪婪) (a｜b) a或b (a)…\\1 引用分组 (?=a) 前面有a (?!a) 前面没有a 对于上面的代码我要做到三点： 图片 src 是真实地址的不能改，比如： src=&quot;http://url/to/real-image.jpg&quot; 图片 src 是相对地址的，需要添加绝对地址： src=&quot;real-image.jpg&quot; 改成 src=&quot;http://url/to/real-image.jpg&quot; 图片 src 是懒加载图片的，修改为 data-echo 表示的绝对地址： src=&quot;http://url/to/imgloader.gif&quot; data-echo=&quot;real-image.jpg&quot; 改成 src=&quot;http://url/to/real-image.jpg&quot; 第三种情况很好处理，正则表达式： /(http\\:\\/\\/url\\/to\\/imgloader.gif&quot; data-echo=&quot;)/g 来进行替换即可 ，这里很多符号需要使用 \\ 反斜杠来转义，另外 g 表示全局搜索替换。 第二种情况和第一种情况很相似，但是第一种情况是不需要做任何修改的，刚开始我简单的替换 src=&quot; 为绝对路径 src=http://url/to/ 是行不通的，这样会把第一种情况的图片地址也替换掉： src=&quot;http://url/to/http://url/to/real-image.jpg&quot; 这是我不想要的结果！ 所以，这里需要用到正则表达式中的不匹配原则了，如果路径中不包含 http:// 那么就是相对地址，需要修改！正则表达式是： /&lt;img src=&quot;(?!http:\\/\\/).+(.jpg|.png|.gif)&quot;/gi ，显然， (?!http:\\/\\/) 是表示匹配字符串不包含 http:// 的意思，这里注意 i 表示不区分大小写进行搜索， . 表示匹配任何换行符之外的单个字符，然后 + 代表不止一个， (.jpg|.png|.gif) 表示这三种图片格式中的任何一种即可。这样正则表达式就达到匹配搜素的目的了。 另外，正则表达中括号 () 非常有用（ (x) 和 (?:x) 含义相反，可以参考相关资料 ），初学者很容易忽略这一点！它的含义和用途是： (x)匹配 x 并且记住匹配项，就像下面的例子展示的那样。括号被称为捕获括号。模式 /(foo) (bar) \\1 \\2/ 中的 (foo) 和 (bar) 匹配并记住字符串 foo bar foo bar 中前两个单词。模式中的 \\1 和 \\2 匹配字符串的后两个单词。注意 \\1、\\2、\\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)。 所以最终我的代码如下，我加了两个括号用于记住匹配项并用 $1 和 $2 来使用，代码一目了然： hexo-generator-feed/lib/generator.js123456789101112if(feedConfig.replaceURL) &#123; var regLazy = /(http\\:\\/\\/liuqingwen.me\\/images\\/imgloader.gif\" data-echo=\")/g; var regSrc = /(&lt;img src=\")((?!http:\\/\\/).+(.jpg|.png|.gif)\")/gi; posts.forEach(function(post) &#123; var coverdiv = post.permalink + post.cover_index; var contenthead = '&lt;span class=\"image main\"&gt;&lt;img src=\"' + coverdiv + '\" alt=\"' + post.title + '\"&gt;&lt;/span&gt;'; var content = post.content.replace(regSrc, \"$1\" + post.permalink + \"$2\"); content = content.replace(regLazy, post.permalink); //element.content = contenthead + content; post.newContent = contenthead + content; &#125;);&#125; 注意上面代码中我所注释的那段代码，我发现我并不能直接修改 element.content 那样会导致我所有博客文章和 RSS 文件一同被莫名其妙地改掉，这是我没有预料到的，所以，鉴于 JavaScript 的动态语言特性，我给每篇文章 post 动态地添加了一个属性： post.newContent 用于 RSS 的生成。 最后还需要在模板代码中进行应用： atom.xml12345&#123;% if config.feed.content and post.content and post.newContent %&#125; &lt;content type=\"html\"&gt;&lt;![CDATA[&#123;&#123; post.newContent | safe &#125;&#125;]]&gt;&lt;/content&gt;&#123;% elif config.feed.content and post.content %&#125; &lt;content type=\"html\"&gt;&lt;![CDATA[&#123;&#123; post.content | safe &#125;&#125;]]&gt;&lt;/content&gt;&#123;% endif %&#125; 三、写在最后其实我们在进行字符串匹配、替换、修改的时候，我们不一定完全需要使用正则表达式，特别是那些不复杂的情况，简单使用字符串的一些标准方法就可以进行查找替换修改了。但是，我觉得能用正则表达式就尽量使用正则表达式，有时候性能也不会差，我给出三点简单的原因： 1 正则表达式有时候并不慢在对于长篇的文字匹配搜索的时候，正则表达式表达更加合理，速度也不慢，我觉得优先使用正则表达式。虽然我也没有理论支持，但是想想，正则表达式为啥存在于各种语言之中？是吧。 2 我所熟悉的 Java 中 replaceAll 函数这个函数表面上和 replace 一样，实际上它的第一个参数是一个正则表达式而非字符，所以 &quot;1.2.3&quot;.replaceAll(&quot;.&quot;, &quot;-&quot;) 的结果不是 1-2-3 而是 ----- ，因为 &quot;.&quot; 是正则表达式代表任何非空字符的匹配规则啊。 3 正则表达式在不同语言中基本通用不一定是 JavaScript ，对于 Java 或者其他语言都能通用正则表达式，看来学习它是很有必要的，你说呢？ 参考资料：正则表达式（MDN - Mozilla Developer Network）： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions正则表达式中的不匹配： http://www.isnowfy.com/regular-expression-negative/EJS (GitHub)： https://github.com/tj/ejsSWIG (GitHub)： https://github.com/paularmstrong/swigPUG (GitHub)： https://github.com/pugjs/pug","tags":"hexo web"},{"title":"【学习笔记】Unity3D官方游戏教程：Tanks Tutorial","url":"/2017/08/03/learning-notes-of-tanks-tutorial-in-unity3d/","text":"一、前言不总结就没有进步，不写代码就不能理解，不理解那么知识就不属于你啊！这是我以前学习的时候很容易出现的误区，为了克服这点，秉承认真学习天天向上的精神，我坚持花时间来整理自己学习所得，一供自己备忘查阅用，二给自己和大家一起相互交流学习的机会。 继续上次 Survival Shooter 游戏学习总结之后，这次是官方的另一个游戏教程： Tanks tutorial ，坦克大战，蛮有趣的一个多人游戏，看完教程后还是自己动手写代码，刚开始有很多地方不明白不理解，后面慢慢参悟出来了，一定程度上还是提高了自己一点点水平，于是，特作此文，以表总结！ 二、知识点 OnEnable 和 OnDisable 函数的使用 世界坐标下 UI Slider 的使用 音频混合效果输出 Audio Mixer 循环游戏机制 GameLoop 探索 局部坐标和世界坐标转换 摄像机宽高比 aspect 和屏幕宽高比 1. OnEnable 和 OnDisable 函数的使用 一般使用 GameObject 之前我是在 Awake() 或者 Start() 函数中做一些初始化，最后配合 Destroy() 函数进行销毁，这次学习了 OnEnable() 和 OnDisable() 函数的使用，在很多场合更加方便！有时候我们的物体并不需要销毁再生产，而是先“隐身”再初始化“现身”，这个时候调用 GameObject.SetActive(false) 后物体是不会显示的，相应的 Unity 会自动调 OnDisable() 函数，而启用游戏物体的时候相应的调用 OnEnable() 函数，你在函数里写初始化代码就可以了。 所以不需要销毁游戏物体就能达到这种效果，记得同时禁用 GameObject 上的其它组件，比如已经死亡的坦克不能：射击、运动等。这，只是一个简单的知识点。 2. 世界坐标下 UI Slider 的使用 同样，非常简单的知识点，只是作为新手从来没用过而已，只需要在 Canvas 的 Render Mode 中更改设置 Screen Space - Overlay 为 World Space 就可以把 UI 元素放到我们的游戏物体之下了，达到的目的是能让 UI 元素跟随游戏物体运动，应用场景比如：玩家的生命血条等。 So easy! 3. 音频混合效果输出 Audio Mixer 想象一下这种场景：一个游戏中充杂着各种各样的音频音效，比如同时有背景音乐、坦克行走声音、坦克引擎声响、炮弹炮炸声等等，这个时候是不是完全不能分辨哪个音效在发挥作用了？没有了主次之分？非常混乱。解决的办法就是采用 Audio Mixer 音频效果混合输出工具对混音进行配置。 如何设置 Audio Mixer ，听上去高大上，其实并不复杂。一篇简单的文章介绍你就能了解并使用上它： Unity 5 音效二 AudioMixer 大家可以尝试使用，参考一下我这张图，就一目了然了： 4. 循环游戏机制 GameLoop 的探索 这是我从这个游戏中学到的一个非常实用且经典的游戏循环控制方式，简单而又强大。 使用场景是这样的，大家可以参考拳皇的入场式：开始游戏，显示 Round 1 第一回合，静等 3 秒钟，然后玩家开始游戏，玩家 A 胜利，玩家全部失去焦点，游戏结束显示 Player A Wins ，静等 3 秒钟，接着进入下一场，如此循环…… 这是一个循环模式，如果采用普通代码写出来在逻辑上会比较麻烦，使用 C# 中的 yet return 配合 IEnumerator 能够完美实现相关逻辑和代码，伪代码如下，一看就知道怎么使用了： 123456789101112131415161718192021222324252627282930private void Awake() &#123; StartCoroutine(GameLoop()); //开始进入游戏循环模式&#125;private IEnumerator GameLoop() &#123; yield return RoundStarting(); //回合开始 yield return RoundPlaying(); //回合内游戏进行 yield return RoundEnding(); //回合结束 if (isGameOver) &#123; Replay(); //游戏已经结束可以重新加载场经 &#125; else &#123; StartCoroutine(GameLoop()); //游戏还未结束，继续游戏循环场景 &#125;&#125;private IEnumerator RoundStarting() &#123; //do something here... yield return new WaitForSeconds(3f);&#125;private IEnumerator RoundPlaying() &#123; //do something here... while(!isRoundOver) &#123; yield return null; //回合未结束就继续 while 循环，否则离开循环，进入下一个环节 &#125;&#125;private IEnumerator RoundEnding() &#123; //do something here... yield return new WaitForSeconds(3f);&#125; 5. 局部坐标系和摄像机宽高比、屏幕宽高比 这是我从 Tanks 这个游戏中学到的最有用的知识点之一！非常重要的知识点，也花费了我不少时间，我在上一篇博客中就关于 Unity 中的坐标体系做了一个小小的总结，大家有兴趣的可以去看看：理解Unity3D中的四种坐标体系。 有时候游戏中我们的摄像机并不是直接作为最上层的物体出现在场景中，想象一下这个场景，我们的摄像机在不旋转的情况下，把摄像机置于一个空物体 parentObject 中作为子物体，那么只要这个父物体旋转了，摄像机视野也就跟着旋转了，这样的话摄像机的本地局部坐标是没有任何旋转的，在局部坐标系下进行处理非常简单。 这样做有什么用呢？我可以说非常有用，比如：坦克大战中，这个摄像机需要同时把所有坦克玩家置于视野当中，那么就需要根据当前坦克的位置来移动并放大或者缩小相机的视野范围。那么如何在此摄像机的父物体局部坐标系下进行处理呢？第一步，移动摄像机到场景中所有需要显示的物体的中心位置处；第二步，根据我们摄像机的宽高比（ camera.aspect ）来计算场景的尺寸（ size ），关于宽高比在我上一篇文章中有介绍，大家可以参考参考；最后，把计算出来的尺寸设置为相机的视口尺寸（ camera.orthographicSize ），这样摄像机就能在场景中心位置看到所有游戏物体了，效果如下图： 伪代码如下： 1234567891011121314151617181920212223242526272829303132/* *假设场景中有两个正在移动的物体：物体 1 和 物体 2 *摄像机需要随时把这两个移动的物体都显示在屏幕上 *同时，摄像机 camera 为 parentObject 的子物体 *我们固定 camera 宽高比 aspect，通过增加或者减少 *摄像机的视野大小 orthographicSize 来显示全部场景 */var center = CalculateCenter();parentObject.transform.position = center; //移动父物体到中心店，摄像机也会跟随移动var cameraAspect = camera.aspect;camera.orthographicSize = CalculateSize(cameraAspect); //计算出来尺寸后赋值给摄像机的视口尺寸private Vector3 CalculateCenter() &#123; var worldPosition1 = screenObject1.transform.position; var worldPosition2 = screenObject2.transform.position; var center = (worldPosition1 + worldPosition2) / 2f; return center;&#125;private float CalculateSize(float cameraAspect) &#123; var worldPosition1 = screenObject1.transform.position; var relativePosition1 = parentObject.transform.InverseTransformPoint (worldPosition1); var worldPosition2 = screenObject2.transform.position; var relativePosition2 = parentObject.transform.InverseTransformPoint (worldPosition2); //下面的代码含义在图中已经显示出来了，大家可以参考图片 var sizeWidth = Mathf.Abs(relativePosition2.x - relativePosition1.x) / 2f; var sizeHeight = Mathf.Abs(relativePosition2.y - relativePosition1.y) / 2f; var size = Mathf.Max(sizeHeight, sizeWidth / aspect); return size;&#125; 最后推荐两个函数用于缓冲或者平滑过渡位置的变化：Vector3.SmoothDamp 和 Mathf.SmoothDamp ，大家可以查看文档看一下它的使用，非常简单实用。 三、总结通过官方的视频学习到的东西还真不少，路漫漫其修远兮，吾将上下而求索！学无止境啊。希望能和大家一同进步！有什么疑问给我留言吧，哈哈。 资料：理解Unity3D中的四种坐标体系： http://liuqingwen.me/2017/07/31/understanding-coordinate-system-in-unity3d/Unity 5 音效二 AudioMixer ： http://blog.csdn.net/LIQIANGEASTSUN/article/details/47702483Tanks tutorial (Unity3D) ： https://unity3d.com/learn/tutorials/projects/tanks-tutorial","tags":"unity3d"},{"title":"理解Unity3D中的四种坐标体系","url":"/2017/07/31/understanding-coordinate-system-in-unity3d/","text":"一、前言刚开始接触 Unity3D 的时候，经常会被 Unity 中各种坐标系搞得昏头转向不知所措，毕竟是一个 3D 兼 2D 游戏开发殷勤，还要把 3D 作品最终发布到 2D 的桌面或者手机系统中，所以熟悉掌握 Unity3D 中的坐标系是非产重要的。 其实如果仅仅只有 3D 坐标系还是很简单的，就目前来说我们所见过的三维建模软件或者游戏开发软件所用的坐标系分两种：左手坐标系和右手坐标系。怎么区别呢？大家看下图就知道了： 区分坐标系可以按上图方法，这里我也有个简单的判断方法：用手握住 z 轴，大拇指朝向 z 轴正方向，然后用手的四指从 x 轴正方向握拳头，如果是左手 90 度就能把四指握到 y 轴就是左手坐标系，如果是右手 90 度握紧后到了 y 轴就是右手坐标系。 除了 3D 世界中的坐标系，还有其他的几个坐标系也非常常用，比如我们经常要把世界三维坐标系转换成我们最终屏幕中的二维坐标系，或者把手机屏幕的二维坐标系转化成游戏世界中的三维坐标系等，各个坐标系各有特别，不能混用，为了更好的学习 Unity 游戏开发，自己在此总结一下 Unity 当中的坐标系和相关用法，以作备忘和学习。 二、坐标体系Unity3D 当中基本的坐标体系主要有下面这四种： 世界坐标系 (World Space) 屏幕坐标系 (Screen Space) 视口坐标系 (Viewport Space) GUI界面坐标系 (GUI System) 这四种坐标系可以说没有一个是完全相同的，各个坐标系所代表的意思也可以从字面含义中理解出来，它们之间都是可以相互转换的，不过 GUI 坐标体系除外，它比较特殊，也相对来说是最简单的，那么我们就从最简单的说起吧。 1. 绘制 GUI 界面的坐标体系 我们在做 Unity 游戏开发的时候，经常会使用内置的 GUI 来做一些测试，比如显示一个按钮控制游戏，画一个文本显示相关信息等。它的代码全部控制在 OnGUI() 函数中： 1234567private void OnGUI()&#123; if (GUI.Button(new Rect(0f, 0f, 160f, 40f), \"Click Me\")) &#123; //button clicked and do something here... &#125;&#125; 这个按钮 Button 所在的坐标系就是 GUI 绘制坐标系。大家稍微测试一下就知道了，它的原点 (0, 0) 在最左上角，因为屏幕宽度是 Screen.width ，高度是 Screen.height ，所以 GUI 体系右下角的坐标为： (Screen.width, Screen.height) , 这是一个二维的坐标体系，坐标 z 的值都为 0 。大家可以看下图加深理解： 2. 视口 Viewport 坐标体系 当我们使用多个相机，在同一个场景中显示多个视口的时候，我们就需要用上视口坐标系了。 视口坐标系对于场景的显示非常重要，对于新手来说我们经常使用一个相机就够了，但是当需要使用到多个视口的时候，我们就必须关注视口坐标体系了，大家可以在相机 Camera 的属性中看到 Viewport Rect 就是视口坐标系的设置： 一个相机对应一个视口，视口预览（ Camera Preview ）展示了相机所看到的所有物体，很显然，它默认大小是 (width = 1, height = 1) ，位置也是从 0 到 1 ，这个位置就是我们所讨论的坐标系：左下角为 (0, 0) ，右上角是 (1, 1) ，一般视口坐标系主要用在相机显示中，我们简单的进行 Viewport Rect 的设置就可以了。 另外，新手朋友们可以记住这么一个快捷键： Ctrl + Shift + F ，可以快速设置相机视口到当前场景窗口的视口位置。下图是视口坐标系和鼠标在屏幕上的坐标系的转换结果： 3. 屏幕 Screen 坐标体系 嗯，非常重要！不管怎样，最终我们所有的成果都会发布到各个平台（屏幕）上，所以，任何坐标系的坐标和屏幕坐标系的转换都是非常重要的。比如我们经常需要处理鼠标的相关事件（鼠标位置、单击、双击事件等），或者手机上的触摸反馈，这些原始数据都是屏幕坐标系相关的。 虽然重要，其实屏幕坐标系处理起来很简单直接， Input.mousePosition 获取的就是鼠标在屏幕中的位置坐标。大家可以测试一下，屏幕坐标系中原点 (0, 0) 位于左下角，那么右上角必然就是 (Screen.width, Screen.height) ，对了，还有一个 z 呢？都为 0 吗？答案是肯定的，既然是二维坐标系那么 z 肯定是 0 了，和 GUI 坐标系一样，但是话又说回来，屏幕坐标系转换成世界坐标系 z 还是 0 吗？其实不然，屏幕坐标转换成世界坐标后物体的 z 值是取决于相机的，因此： gameObject.z = camera.z ，其实在上面视口坐标系介绍中的图中我已经把 Mouse Point 鼠标位置转换成世界坐标（ World Point ）了，大家应该注意到了吧。 那么，除了坐标系的转换，还有什么值得注意的呢？这里我要告诉大家的是，我们在控制相机的时候，因为屏幕显示的就是相机所看到的内容，而屏幕的宽高比直接影响了相机的显示，也就是 Aspect Ratio 的值，大家可以在 Game 面板中轻松地设置 Aspect 宽高比，查看对游戏画面的影响： 如下图，相机的宽高比和屏幕宽高比一致，显示结果也一致： 如果相机的宽高比设置的和屏幕宽高比不一样的话，显示结果就有点不同了： 所以，在游戏开发中，我们要重视相机的宽高比 Camera.aspect 的值，一般我们会保持相机宽高比不变，然后通过改变相机的视口尺寸 Camera.orthographicSize 来显示场景中需要显示的物体，关于这个主题我会在我的下一篇文章中提到，大家可以关注我的博客。如何通过宽高比获取摄像机视口尺寸呢？首先可以从上图中知道宽高比的计算方法： aspect = width / height ，当你同时获取到 width 和 height 的时候，你通过 Mathf.Max(height, width / aspect) 来得出最终的尺寸大小（注意这个结果是 2 倍视口尺寸哦）。这个在游戏场景中应用的还是比较多的，比如你有这么个需求：两个玩家移动对战，你的相机要把两个移动的玩家随时放置在屏幕显示中。 4. 世界 World 三维坐标系 最后，世界坐标系！世界坐标系不是最简单的，但却是我们最常用的坐标系。记住一点，任何情况下： transform.position 都是返回物体的世界坐标值，及时你所使用的是子物体！另外，从上面所讲的屏幕坐标系转换成世界坐标系也是非常简单的，它以当前相机为参考： 12var position = Input.mousePosition;var worldPoint = Camera.main.ScreenToWorldPoint(position); 另一方面，我们在游戏开发过程中，经常要处理子物体的相对 transform 值，这个时候我们就需要稍微动点脑子了，当然如何转变 Unity 已经帮我们预制好相应的函数方法了，你只要把父物体当做世界，子物体当做世界中的物体，使用这些函数，换一下坐标就和处理绝对坐标一样了，不知道大家理解没有。我举个例子，我们在游戏开发中会遇到这种情况，你的相机如果直接放到世界中那么必然会需要调整它的旋转角度才能达到满意的视口位置，如何不让相机产生任何旋转就能把世界中的游戏物体放到合适的视口位置呢？ 办法就是：我们把相机放到一个产生了合适旋转角度的父物体当中！这样做的效果就是：相机就相当于子物体，父物体旋转了，子物体就不需要额外旋转了，这时候相机的局部旋转就为 0 。这在有些场景中使用起来很方便，相机已经是父物体世界中的子物体了。 怎么计算相对坐标呢？在 Unity 中都有相应的函数，使用比较简单： 123456789//获取的是世界坐标var childPosition = childObject.transform.position;//转化为父物体下的相对坐标，相当于位于父物体世界中var relativePosition = parentObject.transform.InverseTransformPoint(childPosition);//转化为世界坐标，注意：这里不能传入 childPosition ，因为 childPosition 就是世界坐标var worldPosition = parentObject.transform.InverseTransformPoint(relativePosition);//所以，下面结果是相等的！print(childPosition == worldPosition); 三、总结当然，在使用坐标系过程中我们还要关注其他方方面面，比如欧拉角的旋转，万向锁，平滑过渡视野等等，这些我想我会在后面的文章总结中写道吧。这次就总结介绍了这几个坐标系，看上去有点复杂，总体来说还是挺很好理解的，有什么不对的或者可以加强的请给我留言，谢谢！ 最后附上刚开始的总结一图： 资料：Unity3d数学基础之坐标系： http://www.jianshu.com/p/86decf1697b0Unity空间坐标相关知识： http://www.jianshu.com/p/9ed5f8d023ff","tags":"unity3d"},{"title":"IDEA上使用Kotlin插件出现的几个小问题","url":"/2017/07/04/solve-several-problems-of-kotlin-plugin-in-intellij-idea/","text":"一、前言之前使用2016版本的 IntelliJ IDEA 写 Kotlin 程序，遇到网络不给力的时候偶尔会莫名其妙地出现 Kotlin 不能正常使用的问题，特别是 Kotlin 有新版本更新的时候，正犹豫要不要下载新版本，问题又出来了，于是乎下载安装了 2017.1.4 版本的 IDEA 。下载后直接安装，中途它会提示卸载旧版本，不用删除老版本的配置文件，这样安装好后注册激活信息和主题配置以及工程项目列表都保持原样。 使用新版本打开之前的 Gradle Kotlin 项目仍然遇到了一些问题，刚开始也不能正常运行，不过也不是什么大问题，自己 Google 搜索也就慢慢解决了，特此记录一下，以备下次查看。 二、问题解决1. 新版本 Kotlin 插件安装 刚开始新版本是没有 Kotlin 插件配置的，但是很奇怪的是，打开 File-&gt;Settings-&gt;Plugins 搜索 Kotlin 显示 Kotlin 是安装好了的，就像下图： 这就是一个坑了，我知道 Kotlin 插件并没有安装，这是错误的显示，只要刷新或者重启，或者点击插件窗口下面的 Install JetBrains plugin... 按钮，可以看到可以继续搜索并正常安装 Kotlin 插件了。安装好重启一切正常！ 2. Kotlin not configured 错误 新版本我使用了 4.0 版的 Gradle 构建工具，但是刷新后构建项目出现 Kotlin not configured 的错误，也没有任何按钮提示可以操作。在 StackOverflow 上搜到了这个 Bug 的解决方法： “Gradle project sync failed” &amp; “Kotlin not configured” ： build.gradle12//implementation 'org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version'implementation 'org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version' 就是把 build.gradle 文件的依赖文件中 jre8 部分删除并替换。然后 Gradle 重新刷新编译，就可以了。 3. 关于版本冲突警告 如果用过之前的 Kotlin 旧版本依赖，在新项目很容易出现下面的警告信息： 12345678Warning:Kotlin: The '-d' option with a directory destination is ignored because '-module' is specifiedWarning:Kotlin: Runtime JAR files in the classpath should have the same version. These files were found in the classpath: C:/Users/Qingwen/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jre8/1.1.2/2a0816780d551a5426a606b4f0f8ff0946e99662/kotlin-stdlib-jre8-1.1.2.jar (version 1.1) C:/Users/Qingwen/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib-jre7/1.1.2/3e2709163c94bd7b8282ba5ea7530d446a985ad2/kotlin-stdlib-jre7-1.1.2.jar (version 1.1) C:/Users/Qingwen/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-reflect/1.0.6/3d499d3b7768f88c4796e5a1e357933e11a8936d/kotlin-reflect-1.0.6.jar (version 1.0) C:/Users/Qingwen/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.1.2/1177197713b6a249ecab40e5d153598bf7ccfd2b/kotlin-stdlib-1.1.2.jar (version 1.1)Warning:Kotlin: Consider providing an explicit dependency on kotlin-reflect 1.1 to prevent strange errorsWarning:Kotlin: Some runtime JAR files in the classpath have an incompatible version. Consider removing them from the classpath or use '-Xskip-runtime-version-check' to suppress this warning 这个警告信息不会影响程序的编译，如果要排除的话也很简单，按照警告提示直接删除 C:/Users/&lt;your name&gt;/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-reflect/1.0. 这些类似的低版本文件夹，全部删除都没事，没有影响，删除继续刷新编译。 4. 旧版本编译错误 java.lang.NoClassDefFoundError 这个是旧版本的错误，其实在出现这个问题之前也遇到过一次同样的问题，自己按照相关信息解决了，不过这次新版本没有安装前出现的这个问题一直没有解决，直到重新安装了新版本。一部分错误错误信息： 12345678910111213141516\"C:\\Program Files\\Java\\jdk1.8.0_112\\bin\\java\" -Didea.launcher.port=7533 \"-Didea.launcher.bin.path=D:\\Software\\Programme\\IntelliJ IDEA 2016.3.4\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_112\\jre\\lib\\rt.jar;D:\\Documents\\Workspace\\IntelliJ IDEA\\KotlinSamples\\build\\classes\\java\\main;D:\\Software\\Programme\\IntelliJ IDEA 2016.3.4\\lib\\idea_rt.jar\" com.intellij.rt.execution.application.AppMain version_all.RegTestKtException in thread \"main\" java.lang.NoClassDefFoundError: kotlin/jvm/internal/Intrinsics at version_all.RegTestKt.main(RegTest.kt) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)Caused by: java.lang.ClassNotFoundException: kotlin.jvm.internal.Intrinsics at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 6 moreProcess finished with exit code 1 之前的解决方案大概是这样，可以尝试，如图定位到 Project Structure 下，找到出问题的包： 然后删掉，或者替换成正确的包： 还不行就直接删掉对应文件夹下的文件： 以上方法不一定有效，不行再 Google 吧。 三、总结几个小坑，还算顺利。由于网络不是很稳定，用 Gradle 有时候真是一个痛苦。另外推荐 Kotlin 1.1.3 版本插件的最新几个小功能，比较酷： Semantic Highlighting Parameter Name Hints Type Hints 具体开启方法看官方文档： Kotlin 1.1.3 is out","tags":"kotlin"},{"title":"【翻译】Kotlin致简代码之路","url":"/2017/06/30/translation-of-clean-code-with-kotlin/","text":"一、前言挺适合新手的一篇建议性博文。原文链接：Clean Code with Kotlin 因本人水平有限，翻译不好之处还请多包涵，文章中 “ Clean Code ” 我喜欢翻译成“致简代码”，但是这个名字的书一般是被翻译成“整洁代码”，建议英文水平可以的朋友尽量看原版更可口。 二、正文Kotlin致简代码之道利用 Koltin 我们可以写出易懂、简短、安全而又富有表现力的代码。就像是致简代码，不是吗？在这篇文章里，我会通过讲解一些关于简洁代码方面的建议和原则，来求证 Kotlin 是否有助于达成这样的目的。另外，我也会指出一些我们应该谨慎注意的限制之处。在文章的最后，我会最终讨论 Kotlin 是走向 “一个黑暗之路还是光明之路”。 会议讲话这篇文章内容基于我在慕尼黑的 Clean Code Days 会议上的演讲主题： Kotlin 致简代码之路（德语），于 2017 年 6 月份。 重述：什么是致简代码？在我们开始之前，弄清楚什么是致简代码很重要。首先，致简代码是一种很容易理解的代码。代码必须直观且易读。我们可以通过让自己的代码更加简洁、简短、简单并富有表现力来达到这个目的。我们在处理最少形式主义和语法噪点的时候也会遇到致简代码。 致简代码和 Kotlin让我们考虑几个出自 Robert C. Martin 的著名书籍《 Clean Code 》里的建议和规则。我们将会发掘 Kotlin 在哪里可以帮我们写出致简代码而在哪里又不能。让我们从使用 Kotlin 能够明显提升的地方开始。之后，我将会聊一些限制和缺陷相关内容。 函数函数应该小巧 “规则 1 ：函数应该小巧！规则 2 ：函数要比那样还小！”“ Clean Code ” —— Robert C. Martin ，页码 34 根据致简代码定义，函数应该很小并且职责单一。我们应该分解子程序并给他们取一个可描述性的名称。这样的话，我们的代码就会变得像一个故事。而且，我们应该从主要逻辑中辨别出细节。 Kotlin 可以帮我们做到这点吗？不行，因为这些规则是无关于语言的。这仍然取决于开发者自己来创建小的函数。 然而，使用 Java 有时候很难写出小而富有表达力的函数。让我来举个例子。假设我们需要把 HTTP 响应的有效信息映射成一个对象并且能正确的处理各种错误分类。 1234567891011121314151617// Javapublic Product parseProduct(Response response)&#123; if (response == null)&#123; throw new ClientException(\"Response is null\"); &#125; int code = response.code(); if (code == 200 || code == 201)&#123; return mapToDTO(response.body()); &#125; if (code &gt;= 400 &amp;&amp; code &lt;= 499)&#123; throw new ClientException(\"Sent an invalid request\"); &#125; if (code &gt;= 500 &amp;&amp; code &lt;= 599)&#123; throw new ClientException(\"Server error\"); &#125; throw new ClientException(\"Error. Code \" + code);&#125; 事实上这段代码并没有做很多事情。它只是处理一些错误分类（ null 空指针响应和错误的 HTTP 状态码 ）。它甚至没有做实际的映射机制。尽管如此，这些代码很冗繁并且包含有语法噪点。作为比较，看一下在 Kotlin 中同样功能实现的代码。 12345678// Kotlinfun parseProduct(response: Response?) = when (response?.code())&#123; null -&gt; throw ClientException(\"Response is null\") 200, 201 -&gt; mapToDTO(response.body()) in 400..499 -&gt; throw ClientException(\"Sent an invalid request\") in 500..599 -&gt; throw ClientException(\"Server error\") else -&gt; throw ClientException(\"Error. Code $&#123;response.code()&#125;\")&#125; 我假设你并不知道这个例子里所包含的每个 Kotlin 的特性，但是这段代码确很容易看懂。这才是最神奇的地方！不需要了解每一个特性就能看懂代码，意味着这些代码非常符合直觉。那就是所谓的致简代码！使用 Kotlin ，我们可以用更少的代码（ 15 行对比 6 行）最少的形式主义前提下达到业务逻辑的实现。 我们可以在这里发掘 Kotlin 很多很酷的特性，这些细节我会在后面提到，但是我想告诉你的是 when 表达式。 Kotlin 中的 when 表达式就像 Java 中的 switch 语句，但是它更加强大。它不仅简洁而且你还能在分支里做一系列检测的事情（ null ，多种值，范围，类型检测等）。 通过介绍这个列子可以显示出 Kotlin 有助于减少语法噪点，并保持函数小且富有表达力。 无有副作用致简代码告诉我们应该减少副作用。我们不应该制造出那些一看到函数名称就感觉意图不明显，发生非期望中的隐藏的变化。但是副作用到底是什么问题呢？有副作用的代码容易产生错误，很难以理解，很难做测试，不容易并行化运行（非线程安全），不能被缓存并且不能做到延迟加载。我们可以通过函数式编程的概念来避免副作用的产生。这基本上就意味着编写纯函数（等于无副作用函数）。 Kotlin 在这里能派上用场是因为它有比 Java 更好的方式支持函数式编程： 表达式 不可变性 函数类型 简洁的 Lambda 表达式 Kotlin 丰富的集合 API 当然，值得注意的是， Kotlin 的函数功能并不能和 Haskel 甚至 Scala 相提并论。 表达式流程控制结构作为表达式在 Kotlin 中，流程控制结构体是表达式而不是语句。我们刚才已经看到 when 表达式实践了。其实 if-else 和 try-catch 在 Kotlin 中也同样是表达式。这真的很方便： 123456val json = \"\"\"&#123;\"message\": \"HELLO\"&#125;\"\"\"val message = try &#123; JSONObject(json).getString(\"message\")&#125; catch (ex: JSONException) &#123; json&#125; 在 Java 里，我们必须另起一行在 try 之前定义 message 变量。更加好的是，这个变量是不能被修改的（ final ）。使用 Kotlin 的 try 表达式，我们在减少一行的同时还能让变量做到不可变（ val ）。在 Java 中的一个解决方案就是把 try 分解成子程序。尽管我们可以给这个子程序一个具有很好描述性的名称，但有时候还是有点过头了。 单函数表达式另外一个很贴心的特性是单函数表达式。如果一个函数仅包含一个表达式，我们可以省略大括号 {} 以及返回值类型。 1234567891011121314fun getMessage(json: String): String &#123; val message = try &#123; JSONObject(json).getString(\"message\") &#125; catch (ex: JSONException) &#123; json &#125; return message&#125;// 变成这样：fun getMessage(json: String) = try &#123; JSONObject(json).getString(\"message\")&#125; catch (ex: JSONException) &#123; json&#125; 这个单表达式函数变得更加简洁：它的基本逻辑立马能展示出来，这得益于语法噪点的降低。就像我们所看到的， Kotlin 的表达式支持允许我们将一些控制结构与其他表达式一起，更加简洁高效地组合起来使用。 注意残缺把所有东西压缩到单个表达式确实很有诱惑力。就因为你能这样做，并不意味着那一定就是个好方法。在这一点上，开发者保持整洁代码与易读性的规则是至关重要的。 12345678910111213141516171819202122232425// 你没必要一行一行的阅读 :-) // 不要这样:fun map(dto: OrderDTO, authData: RequestAuthData) = OrderEntity( id = dto.id, shopId = try &#123; extractItemIds(dto.orderItems[0].element.href).shopId &#125; catch (e: BatchOrderProcessingException) &#123; restExc(\"Couldn't retrieve shop id from first order item: $&#123;e.msg&#125;\") &#125;, batchState = BatchState.RECEIVED, orderData = OrderDataEntity( orderItems = dto.orderItems.map &#123; dto -&gt; mapToEntity(dto) &#125;, shippingType = dto.shipping.shippingType.id, address = mapToEntity(dto.shipping.address), correlationOrderId = dto.correlation?.partner?.orderId, externalInvoiceData = dto.externalInvoiceData?.let &#123; ExternalInvoiceDataEntity( url = it.url, total = it.total, currencyId = it.currency.id )&#125; ), partnerUserId = authData.sessionOwnerId ?: restExc(\"No sessionId supplied\", 401), apiKey = authData.apiKey, dateCreated = if (dto.dateCreated != null) dto.dateCreated else Instant.now(),) 如果使用有问题请选择临时变量和子程序。我们的目标不应该是使用表达式，而应该是创建更加易读的代码。有时候，这种能够达到一致的目的但并非必须。 可读性打败把一切压缩到单行 不可变性在 Kotlin 中使用不可变性感觉非常自然且容易。实际上，这是 Kotlin 中一种惯用的写代码方式。在这个方面， Kotlin 鼓励使用不可变的变量、数据结构以及集合。因此，结果就是这会让你的代码更加健壮并且易于理解。 不可变引用在 Kotlin 中，我们应该一直使用 val 关键字来定义一个变量。这会创建一个不可变变量。在 Java 中，我们不得不额外添加 final 这个关键字（再次出现语法噪点！）。如果你的变量必须是可以修改的，你可以使用 var 。但是请你在使用 var 之前三思。 1234val id = 1id = 2 // 编译错误！var id2 = 1id2 = 2 只读集合在 Kolint 中创建一个列表的惯用方式是使用 listOf() 方法。这会创建一个只读列表，因此你不能向它添加任何元素。注意 Kotlin 的集合并不是不可变的因为它是基于 Java 的可变性集合，这是迫于互操作性的原因。不过在实践中，大部分情况下这已经足够好了。 12val list = listOf(1,2,3,4)list.add(1) //编译错误。这个方法在 Kotlin 的只读列表接口中并不存在。 Kotlin 的集合 API 同样返回一个新的只读列表。原始的列表不会被改变。 1val evenList = list.filter &#123; it % 2 == 0 &#125; 同样请注意这个简洁的 API 和 lambda 表达式。我们可以直接在这个列表上调用 filter() 方法（并不像 Java 8 中那样要求使用 stream() 方法）。并且 filter() 方法已经返回了一个新的列表（不需要再使用 collect(Collectors.toList()) 方法）。最终，我们可以看到一个非常简洁的 lambda 表示方式：我们可以省略括号 () 在只有一个参数并且这个参数是一个 lambda 表达式的情况下。此外，如果仅有一个参数的话，我们可以省略 lambda 中参数的定义。这种情况下，我们可以用 it 代替这个参数。也只有在这种情况下， it 所表示引用的含义很明显。其他情形下，最好是用一个具有表达力的名字来显式声明这些参数吧。总的来说，集合 API 避免了形式主义和模板。 不可变数据类在 Kotlin 中使用 data class 能够非常容易地创建不可变数据类。实际上，这是 Kotlin 中一个杀手级特性。在 Java 中，我们需要大量的模板和形式来正确地创建一个不可变类：我们需要定义由 final 修饰的字段、属性和构造函数（把参数赋值给对应的字段），定义 hashCode() ， equals() ， toString() 同时把类标记为 final 。在 Kotlin 中，我们可以这样使用数据类： 1234567data class DesignData( val id: Int, val fileName: String, val uploaderId: Int, val width: Int = 0, val height: Int = 0) 就是这么简单！这段代码由这些主要部分组成：类的名字和属性的定义，符合最少的形式主义原则。我们仅需要编写、阅读并维护最少量的代码！ 此外， Kotlin 支持默认参数（像这样 val width: Int = 0 这样）。这直接淘汰了那种使用冗长而又繁琐的构造函数链来模拟默认参数的古老方式。 更加可喜可贺的是，它还能够在构造函数里直接使用。 1val design = DesignData(id = 1, fileName = \"cat.jpg\", uploaderId = 2) 第一，我们不再需要毫无用处的 new 关键字了。第二， Kotlin 支持命名式参数，这明显提升了代码的可读性和健壮性。我们再也不会意外地混淆了具有相同类型的参数了。 而且，我们还能够通过使用属性缩写访问的语法来访问这些属性值。没必要再调用一个 getter 方法。 12val id = design.iddesign.id = 2 //编译错误。非可变属性。 这个 copy() 方法在函数编程中特别的实用。因为所有的数据结构都应保持不可变，所以我们需要这种方式来方便地创建一个对象的拷贝。而且， copy() 允许仅传递参数给那些需要改变的属性值。而其他的属性在复制过程中将会保持不变。 1val design2 = design.copy(fileName = \"dog.jpg\") 异常处理让我们分析一下，对应于致简代码建议条例中 Kotlin 在错误处理方面是否有利。 致简代码建议条例 Kotlin 是否支持？ 错误处理和逻辑分离 否 不要使用已检查异常 已检查异常不存在 使用策略避免 null （异常、空集合、空物体、特殊场合对象） 否 不要返回 null 。理由： 否 a) 分散的 null 检查代码 简洁的语法处理 null b) 很容易忘记 null 检查。空指针异常。 空类型。编译器强制处理。 如同我们所看到的，大部分建议都是和语言无关的。我只想指出最后的那三行。即使是 Kotlin ，避免返回 null 也是取决于开发者的。但是我们所面对的现实是： null 空值和 NullPointerExceptions 空异常还是一直在我们的代码中产生。这是个事实。因此我们必须处理好。辛运的是， Kotlin 有着强大的处理 null 空指针的能力。让我们一起来看看吧。 可空类型和非空类型这个 null 空安全体系也是 Kotlin 的另一个杀手级特性。 Kotlin 扩展了 Java 类型体系。首先，编译器知道变量的类型（ String ， Int ， Date ）因此我们可以在某个对象上调用某个方法。并且 Kotlin 的类型体系能够做的更多。其次，我们可以将一个类型标记为可空类型（ 可以取值 null ）或者非可空类型（不能为 null ）。一个可空类型相对于它所对应的非空类型提供了不同的方法，这都是编译器能检测到的。 1234567val value: String = \"Clean Code\"val value: String = null // 编译错误！不可以把 null 赋值给非空类型val nullableValue: String? = \"Clean Code\"val nullableValue: String? = nullval value: String = nullableValue // 编译错误！不可以把可空变量赋值给非空变量 要把一个可空变量值赋值给非空值变量我们必须做一个 null 检测： 1val value: String = if (nullableValue == null) \"default\" else nullableValue // nullableValue 变量智能转换 这能够成功编译。编译器进行空检查后把 nullableValue 值转换成非空类型。这种自动转换叫做“智能转换”，在某些场合下直接淘汰了显示手动转换（再一次，更少的形式主义！）。另外我们可以把上面的那行代码变得更简短，通过使用 elvis 操作符 ?: ： 1val value: String = nullableValue ?: \"default\" 如果 elvis 操作符左边（ nullableValue ）不是 null 的话，整个表达式会将 nullableValue 的值赋值给变量（ value ）。如果左边是 null 那么右边的部分（“ default ”字符串）会被赋值。 空安全实践让我们假定有一个嵌套域的层级结构：一个订单有一个客户属性，客户拥有一个地址，因此也就有了城市的信息。现在，我们想要深入这个层级获取相应城市信息。这是一个很常见的使用情形。然而，这个链条中每个元素都有可能是空值，因此都是可空类型。所以，下面的代码是不能通过编译的： 1val city = order.customer.address.city // 编译错误！订单、客户、地址都可以为空！ 编译器不允许我们在 order 订单属性上直接访问 customer 属性，因为我们并没有处理 order 属性值为 null 的情况。编译器在编译阶段给我们指出了这个可能会发生的错误。这显著地减少了错误的发生从而提高了安全性能。 那么我们该怎么做呢？有几个选择。选择 1 是使用非空断言申明符 !! 。 1val city = order!!.customer!!.address!!.city // 避免这种情况！ 这能够满足编译器的要求。但是当这个链条里有一个元素是空值得时候，就会抛出一个 NullPointerException 的异常。还是让我们力求另一个更好的方式吧。 选择 2 是 Java 风格的形式：使用几个 if-null 来作判断： 1234if (order == null || order.customer == null || order.customer.address == null)&#123; throw IllegalArgumentException(\"Invalid Order\")&#125;val city = order.customer.address.city // 智能转换 这能达到目的但是非常的繁琐。这很冗余又容易出错，因为我们很容易忘了某个变量的 null 检查。顺便说一下，在空检查之后编译器允许我们通过 . 符号来进行成员访问，这得益于编译器之前检测到的 null 空检查操作。 选择 3 ：我们能够做得更好。这里就是安全访问操作符 ?. 派上用场的时刻了。它只在目标对象非 null 的前提下才会派发调用。否则，整个表达式都为 null 。 1val city = order?.customer?.address?.city 因此，只要链条里的任何一个元素是 null 那么 city 就会变成 null 。非常的方便。尽管如此，我们还想在 null 发生的情况下抛出一个异常。那么这个时候 elvis 操作符就非常有用了： 1val city = order?.customer?.address?.city ?: throw IllegalArgumentException(\"Invalid Order\") 只要链条里任何一个元素是 null 那么都将会抛出一个异常。安全访问和 elvis 操作符强强组合是 Kotlin 中一个非常强大的惯用组合方式。它允许达到非常简洁地处理 null 空值目的。 总之， Kotlin 中的空值处理体系使得我们的代码既安全而又少出错。这仅仅只需要添加一些语法结构就能实现的（比方说在类型后面的 ? ）。对于我来说，这种安全类型方式非常好。这样的结果就是， Kotlin 为 null 空值处理提供了简洁而又富有表现力的方法。他们删除了一大堆语法噪点和形式主义，最终写出更易读的代码。 更少的形式主义减少语法噪点相对于 Java ， Kotlin 降低了语法噪点并且更加富有表现力。 访问构造函数不需要 new 关键字。 不需要写分号。 类型自动推断。没必要写出来。只需要写 val 即可。 大多数情况下，不需要显示转换（智能转换）。 三个引号字符串里无需转义 下面的表来自 Dmitry Jemerov 和 Svetlana Isakova 的书 “ Kotlin in Action ”（表格 11.1 ，283页）。 常规语法 简洁语法 特性使用 StringUtil.capitalize(s) s.capitalize() 扩展函数 1.to(&quot;one&quot;) 1 to &quot;one&quot; 中缀访问符 set.add(2) set += 2 操作符重载 map.get(&quot;key&quot;) map[&quot;key&quot;] get 方法转换 file.use({ f -&gt; f.read() }) file.use { it.read() } 扩后外使用 Lambda sb.append(&quot;yes&quot;) sb.append(&quot;no&quot;) with(sb) { append(&quot;yes&quot;) append(&quot;no&quot;) } 带接收器的 Lambda 特别是函数扩展功能能让我们的代码既富有表现力又更加整洁。但是要谨慎使用操作符重载。它虽然能够写出简洁的代码但是也能够导致写出很差的代码。只在操作符非常直观的前提下使用它（就像 + 用在数字、字符串和日期上）。而其他的场所，优先使用带有清晰描述和意图的名字所表示的函数方法。 流行的 Java 习惯和内建模式在 Java 中有很多惯用方式和模式都需要一大堆的模板代码。比方说，在 Java 中实现单列模式，观察者模式或者代理模式，代码都很冗余。大部分情况这只会暴露出 Java 语言的缺陷。辛运的是，这些惯用方法和模式都很好的集成在 Kotlin 中了。详细信息可以参考我博客里关于 Kotlin 习惯用法的文章。 局限良好的设计有益于致简代码到目前为止，我们只考虑到了 Kotlin 中的函数和错误处理功能。除了这些，我还能发现 Kotlin 在对象和数据结构（通过数据类）以及并行性（ Kotlin 1.1 中的协程 ）上的改进。但是 Martin 的书籍覆盖了更多的主题： 有含义的名称 函数 注释 格式 对象和数据结构 错误处理 下标边界 类 系统 访问权限暴露 并行性 关于命名如何处理？命名应该具有代表意义。当然与所使用的语言是无关的。同样也适用于注释、格式、边界、类结构设计等等。如我们所见，好的软件设计对于写出致简代码是很重要的，这和使用的语言无关。想想关于适当的数据抽象、小巧的类型、迪米特法则、边界包装、单一职责原则、信息隐藏等等。使用语言只是达到致简代码的一个方面。为了突出这一点，我查阅了 Martin 的书 “整洁代码” 的第 17 章 “味道和启发” ，并分析了 Kotlin 是否能够有助于避免每个味道。 在我看来‘整洁代码’一书中大部分的味道和启发都是与语言无关的 在我看来，大部分的规则都是独立于语言的。它们中很多都考虑到了这个（面向对象）设计。因此是否符合这些规则还取决于开发者以及他对致简代码的认识。 特性迷恋就因为有这么一个特性，并不意味着你就要到处使用它。特别要注意： 很难读的怪诞表达式（看上面的一节：注意残缺） 复杂的安全访问和 elvis 结构 关于后面那一点让我来给你举几个例子。我们假定需要在一个映射中放一个可空的字符串，这个字符串要满足不为 null 且非空白的条件。听起来很简单，对吗？看一下下面的实现方式： 12345// 不要这样做value?.emptyToNull()?.let &#123; map.put(\"bla\", it) &#125; // 额，“ it ” 是智能转换的。// 需要辅助方法：fun String.emptyToNull() = if (this.isEmpty()) null else this 痴迷于单表达式以及智能转换（避免非空断言）会导致写出极其难读的代码。另一种实现方式： 1234// 不要这样做if (value?.isNotEmpty() ?: false)&#123; map.put(\"key\", value!!)&#125; 更加糟糕了。特别是刚开始学习 Kotlin 的时候，很容易迷失在复杂的安全引用、 elvis 操作符以及表达式之中。在这种情况下，最好是想想那套陈旧且好用的“如果是空指针或空白”的陈述语句： 1234// 拥抱它！if (!value.isNullOrEmpty())&#123; map.put(\"key\", value!!)&#125; 是的，这里仅有一个非 null 的断言申明符 !! ，因为编译器在 isNullorEmpty() 中不能侦测到 null 的检查。但是这段代码非常具有可读性且简洁明了。 可读性和简单性才是（仍然是）王道！ 有时候是没必要特意使用某些特性的。任何时候可读性和简单性原则比起使用 Kotlin 那些有趣的特性来说更加重要。 总结我们可以使用 Kotlin 写出更加简洁的代码吗？是的，毫无疑问！理由如下： 提升可读性，得益于更少的模板和语法噪点 提升安全性能 Koltin 鼓励更好的设计方式 但是仍然有两件事我们需要牢记于心： 整洁代码和好的设计方式在 Kotlin 中并不是自动形成的。开发者的个人准则仍然很重要。 慎重使用某些特性。有时候这种“老的”方式可能是更好的选择。时常牢记表述清晰是王道。 结语：光明大道回溯到我刚开启自己专业软件开发职业生涯的时候， Bob 大叔的这本 “整洁代码” 一书给了我启发并改变了我写代码的方式。但是我不得不赞同他批判 Kotlin （以及 Swift ）的这篇“黑暗大道”文章。事实上，我很失望。这里我也要发表自己的意见： 类和方法默认为 final ：是的，这种设计意图是在社区引起了激烈的争议。但是对于我来说，这在日常工作中并不是什么大问题。 空指针安全：这是我个人最爱的 Kotlin 杀手级特性。我坦言：只要是人类都容易犯错。所以开发者也会时常犯错。这是不可避免的。也因此 Kotlin 能够帮助开发者指出可能存在的错误（空指针异常）是很好的。但是这并不意味着我们就能粗心大意且停止编写测试了。这只是一个额外的安全层次。我不认为这很差，特别是在遇到额外的少量的语法时候。 “让汽车更安全并不意味着你可以粗心驾驶。” sebaslogen 顺便提一下，在谷歌 I/O 2017 大会上安卓团队正式宣布了 Kotlin 为安卓开发的官方语言。因此有很多的人（不仅仅是在谷歌）欢迎拥抱 Kotlin 以及它的特性。 在这篇文章里，我努力指出 Kotlin 中提供的大量优秀的特性来让你们写出更加简洁的代码。所以，即使你不喜欢这两种设计方式，但你不得不承认 Kotlin 的代码基本上更具可读性，直观性，富有表现力和安全性。这不就是致简代码所要表达的目的吗？因此， Kotlin 毫无疑问是跨入“星光大道”的又一大步！","tags":"kotlin 翻译"},{"title":"【学习笔记】Unity3D官方游戏教程：Survival Shooter tutorial","url":"/2017/06/25/leanrning-notes-of-survival-shooter-tutorial-in-unity3d/","text":"一、前言刚开始学习 Unity3D 游戏开发，没什么资料，看了官方的视频教程，感觉还不错。不过，对于新手来说，莫过于实战能力的提高了。学习完还应该动手写写代码，熟悉一些旧的知识，掌握一些新东西。所以对于我这种刚入门的游戏开发者，还是非常有必要把自己的学习过程记录下来，加深自己对 Unity3D 游戏开发的理解和认识，提高实战能力。 对了，对于新手入门，官方的视频教程还是非常值得一看的！推荐到 YouTube 上把官方的视频教程下载下来，因为新手一遍可能不能完全看懂，多看几次，多写代码，多做总结，项目源代码也可以下载下来研究研究，能真正提高实战能力才是王道。 二、学习笔记话又说回来，我只是初学者，我自己是在官方下载了项目素材后一步一步按部就班地实现游戏的基本功能的，然后在此基础上自己再实现点小功能什么的，大家可以到官方网站教程地址下载相关源文件，以下是我简单的一些学习笔记记录： 1. GameObject上多个脚本开发 我想，对于 GameObject 上使用单个脚本还是多个脚本这是新手很容易进入的误区，刚开始我总是认为一个 GameObject 只能添加或者只需要添加一个自定义的 Script 脚本，这是很不符合游戏开发流程的。想想，如果一大堆逻辑写在一个脚本里，肯定不利于解耦、容易出错、也很难维护。 实际开发过程中一个 GameObject 可能会有多个脚本协作运行。每个脚本都作为一个独立的 Component 组件，这是单一职责原则，利于解耦和调试。比如一个游戏玩家 Player 上有控制移动的 PlayerMovement 脚本，也有控制射击的 PlayerShooting 脚本，还有生命值 PlayerHealth 脚本组件等，独立而又能相互调用，降低开发难度： 12345678GameObject player = GameObject.Find(\"Player\");PlayerHealth health = player.GetComponent&lt;PlayerHealth&gt;();PlayerShooting shooting = player.GetComponent&lt;PlayerShooting&gt;();if(health.isDead) &#123; shooting.enabled = false;&#125; 2. Component组件都是可以动态设置的 Unity3D 可以直接用编辑窗口就能做出很基础的功能，但是这并不意味之所有组件只能在编辑状态下设置，我们完全可以在脚本中动态获取相关组件，并设置其相关属性值。就像改变游戏对象的坐标值，操作刚体的各种属性，开启禁用游戏物体的碰撞体属性等等。 我们写的附加在游戏物体上的脚本同样是 Component ，都可以通过代码获取相对于的组件： T component = GameObject.GetComponent&lt;T&gt;() ，获取后可以动态禁用组件也可以动态更改属组件的各个属性值，很方便是吧？！ 3. GameObject在销毁后其相关属性也同时销毁 我在游戏开发最后添加了一个自定义的小小功能：给玩家治疗生命的游戏物体。设置很简单：在检测到玩家碰撞到治疗物体后，玩家生命值恢复，治疗物体消失，同时播放治疗效果的音频。功能虽小，但是加强了游戏的可玩性，不过我发现，运行我写的代码后虽然有治疗效果，但是并没有触发音频效果。 原来，在我调用了 Destroy(GameObject) 之后，附在 GameObject 上的 Audio Source 音频组件也就销毁了，治疗效果的音频播放自然也就停止了。针对这个问题，我想了一个折中的方案：让治疗物体在一小段时间后再销毁，这期间治疗物体关闭碰撞体属性，位置不断上升，同时就能播放完整的治疗音效了。 1234567891011121314151617private void OnTriggerEnter (Collider other) &#123; //检测碰撞体是否是游戏玩家 if ( other.CompareTag (\"Player\") ) &#123; var player = other.gameObject as GameObject; var health = player.GetComponent&lt;Health&gt; (); if ( ! health.isDead ) &#123; health.HealHealth (this.healPoint); //禁用停止相关组件 this.GetComponent&lt;BoxCollider&gt; ().enabled = false; this.GetComponent&lt;ParticleSystem&gt; ().Stop (); //播放治疗效果音频 this.healAudio.Play (); &#125; //一段时间后销毁治疗物体 Destroy (this.gameObject, this.destroyTime); &#125;&#125; 4. Time.deltaTime的使用 在开发过程中，我们经常需要设置游戏玩家的位置或者移动速度。我在看视频教程的时候，总是不明白为什么需要在速度后面再乘以 Time.deltaTime ，直接用速度不就可以了吗？后来我知道原因了，大概是这样的：我们不是能利用设置 Time.timeScale = 0 来暂停游戏吗？道理是一样的，乘以 Time.deltaTime 能够达到全局控制速度的作用。所以，对于这种按照帧率来渲染的动画，速度乘以帧率是有道理的，特别是在 FixedUpdata() 函数里，模拟更加真实。 123456Vector3 movement;private void Move(float x, float z) &#123; this.movement.Set(x, 0f, z); this.movement = this.movement.normalized * this.speed * Time.deltaTime; this.player.MovePosition (this.transform.position + this.movement);&#125; 5. 使用物理射线检测碰撞并用LineRender画线 射线检测碰撞是 Unity 中很重要的一个物理概念。射线也困扰了我很久，在学习了这个游戏教程之后，我总算明白了它的基本原理：射线就是一条从一个点到另一个点的不可见直线，它能检测到碰撞层中所碰撞到的物体，并算出相应的碰撞点。 在这个游戏开发中，射击后用射线来检测碰撞物体和碰撞点，接着就可以用 LineRenderer 从枪口画出一条到碰撞点的可见直线了，最后做一些让射击逼真的动画色彩效果，比如光照、音效等，这样就实现基本的射击动画了，可以看代码，并不难： 123456789101112131415161718192021222324252627282930313233343536373839//定义可以被射击碰撞到的层int shootLayer = LayerMask.GetMask (\"Shootable\");//射击线的起始位置（index）和最大长度int startIndex = 0;int endIndex = 1;float maxLength = 100f;//定义用于碰撞测试的射线（原点属性和方向属性）Ray ray;ray.origin = transform.position;ray.direction = transform.forward;//用LineRenderer画出射击线（需要起点位置和终点位置）LineRenderer shootLine = GetComponent&lt;LineRenderer&gt;();shootLine.SetPosition (startIndex, transform.position);//物理射线碰撞测试（shootHit是输出碰撞点，如果有的话）if ( Physics.Raycast (ray, out shootHit, maxLength, shootLayer) ) &#123; //如果射线能检测到前方有物体碰撞，那么判断是否是射击到怪物 var hitObject = shootHit.collider.gameObject; if ( hitObject.CompareTag (\"Enemy\") || hitObject.CompareTag(\"BOSS\") ) &#123; var health = hitObject.GetComponent&lt;Health&gt; (); if ( ! health.isDead ) &#123; //自定义的怪物生命值接受伤害的函数 health.TakeDamageAt (this.damagePerShoot, shootHit.point); &#125; &#125; //子弹射击线的终点定在碰撞物体的位置，完成绘画 gunLine.SetPosition (endIndex, shootHit.point);&#125;else&#123; //如果射线检测到前方最大距离内没有物体碰撞，直接画最长的一根线就可以 shootLine.SetPosition (endIndex, transform.forward * maxLength);&#125;//添加一些射击效果，比如音效，射击碰撞粒子效果等//other code here... 6. 其他小知识 当然，我也学到了一些其他的新的东西或者需要注意的地方： 相互引用的物体之间要注意游戏物体是否已经被销毁，否则容易抛出 NullPointerException 错误 动画控制 Animator Override Controller 是对 Animator Controller 的复用 Awake 和 Start 函数的区别： Awake 立刻运行，即使物体被禁用，但是 Start 必须在 Enabled 非禁用的前提下调用 基本的自动寻路应用，可以随时停止： GetComponent&lt;NavMeshAgent&gt;().enabled = false 疑问：获取 Player 对象有两种主要的方式： Find 和手动添加引用 public GameObject Player ，区别还不是很清楚？（以后学习过程中关注这点，如有朋友留言告知，非常感谢！） 三、总结以上就是我在《 Survival Shooter tutorial 》游戏教程中学到的一些入门的基础知识点。对于新手来说，要真正的具备独立开发游戏的能力还有很多很多要学的，这还是在我使用了官方素材的前提下，只需要写写代码实现就可以了，单独素材也是需要花时间制作或者搜寻的，真的，要学的东西还有很多啊！默默加油吧！ 资料：Survival Shooter tutorial: https://unity3d.com/learn/tutorials/projects/survival-shooter-tutorialUnity3D(www.youtube.com): https://www.youtube.com/user/Unity3D","tags":"unity3d"},{"title":"【学习笔记】区别Kotlin中的object和companion object关键字","url":"/2017/06/20/object-vs-companion-object-in-kotlin/","text":"一、前言我们经常能够在 Java 相关技术博客中看到类似这样的文章： Java 中 X 种单例模式的写法。的确，单例模式是一个简单但又很重要的设计模式，特别是在多线程编程中，它的实现方法各有不同，也是适应各种不同的场合。不过，现在有了 Kotlin ，那都不是事了，忘记那个 X 吧，一个 object 关键字轻松搞定！真的，相信我，生活就是要那么容易。 在 Kotlin 中，除了 object 关键字还有个 companion object 关键字，这个又是什么鬼？怎么使用？有啥区别？在没有仔细阅读相关文档资料之前还真有点傻傻分不清了。实践出真知，在经过简单的练习加上相关博客文章、源码阅读、谷歌搜索后，我心里所认识的 object 和 companion object 是这样的： object 可以定义在全局也可以在类的内部使用 object 就是单例模式的化身 object 可以实现 Java 中的匿名类 companion object 就是 Java 中的 static 变量 companion object 只能定义在对应的类中 但是，这些认识都是停留在表面上，在我继续阅读《 Kotlin in Action 》这本书相应章节后，我能发现它们的使用场景和功能点远不止这些！究其原因，主要是我并没有完全弄清楚它们的原理以及它们之间的差别，不论是 object 还是 companion object ，它们的共性和区别还有这些： object 可以作为变量的定义也可以是表达式 object 匿名类可以继承并超越 Java 中匿名类而实现多个接口 object 表达式当场实例化，但定义的 object 变量是延迟实例化的 object 和 companion object 都可以为其取名也可以隐姓埋名 object 匿名内部类甚至可以引用并更改局部变量 companion object 甚至还可以被扩展 Java 中需要结合 @JvmStatic 和 @JvmField 使用 …… 还有很多异同点等着你的开发 既然这俩兄弟有这么多异同点，那么我觉得非常有必要总结一下，以便将来能够更加得心应手地使用 Kotlin 吧。 二、正文1. object基本定义object 可以轻松实现 Kotlin 单例模式， 它可以定义在全局之中，也可以定义在类的内部。但是要注意几点： object 定义后即刻实例化 因此 object 不能有定义构造函数 定义在类内部的 object 并不能访问类的成员 1234567891011121314151617object OutObject &#123; val outParameter = \"out\" fun outFunction(parameter:String) &#123; println(\"Out object function result: $parameter.\") &#125;&#125;class MyClass &#123; val classParameter = \"class\" object InnerObject &#123; //val innerParameter = this.classParameter //error: 1,this refers to InnerObject 2,classParameter cannot be reached val innerParameter = \"inner\" fun innerFunction(parameter:String) &#123; println(\"Out object function result: $parameter.\") &#125; &#125;&#125; 2. object作为表达式在 Android 开发中，我们经常会设置一个接口匿名类作为点击事件的参数： setOnClickListener(View.OnClickListener) ，这个时候在 Kotlin 中就可以使用 object 来表达那些匿名内部类。同时 object 相比 Java 更加强大，在用其表达内部类的时候有这几个注意点： object 继承父类必须立刻传递父类构造参数 object 匿名类可以同时实现多个接口 object 匿名类作为参数并没有名字定义，但是可以为其定义一个变量名，如果实现多接口不能直接用类型推断，拗口吧，请看下面代码： 12345678910111213141516171819202122interface MyInterface1interface MyInterface2open class MySuperClass(parameter:String)//button.setOnClickListener( object:OnClickListener &#123; //... &#125; ) //no name specifiedclass MyClass &#123; object AnonymousSubClass:MySuperClass(\"something\"), MyInterface1, MyInterface2&#123; //do something... &#125; val anonymousClass = AnonymousClass object AnonymousClass:MyInterface1, MyInterface2 &#123; //do something... &#125; val anotherAnonymous = object:MyInterface1 &#123; //type inferred &#125; val againAnonymous:MyInterface1 = object:MyInterface1, MyInterface2 &#123; //type cannot be inferred &#125;&#125; 3. object可以访问非final局部变量我们知道在 Java 中，内部类是不可以访问外部的非 final 成员变量的，也就是说：它不允许更改变量值！但是， Kotlin 的 object 可以。看代码： 123456789101112131415interface MyInterface &#123; fun operateVariable() &#125;class MyClass &#123; fun operationWithInterface(anonymous:MyInterface) &#123; anonymous.operateVariable() &#125; init &#123; var localVariable = 1 this.operationWithInterface(object : MyInterface, MyInterface1 &#123; override fun operateVariable() &#123; localVariable += 1 &#125; &#125;) println(\"Local variable value: $localVariable\") //print: Local variable value: 2 &#125;&#125; 就是那么霸道！写了那么多 object ，我们再看看 companion object ，可谓是 object 的孪生兄弟，它可以说是为 Java 里的 static 而生的 object 。 4. companion object使用方法和 object 不同， companion object 的定义完全属于类的本身，所以 companion object 肯定是不能脱离类而定义在全局之中。它就像 Java 里的 static 变量，所以我们定义 companion object 变量的时候也一般会使用大写的命名方式。 同时，和 object 类似，可以给 companion object 命名，也可以不给名字，这个时候它会有个默认的名字： Companion ，而且，它只在类里面能定义一次： 12345678910111213141516class MyClass2 &#123; companion object CompanionName &#123; val INNER_PARAMETER = \"can only be inner\" fun newInstance() = MyClass2(\"name\") &#125;&#125;class MyClass3 &#123; companion object &#123; val INNER_PARAMETER = \"can only be inner\" &#125;&#125;fun main(vararg args:String) &#123; println(MyClass2.CompanionName.INNER_PARAMETER == MyClass2.INNER_PARAMETER) //print: true println(MyClass3.Companion.INNER_PARAMETER == MyClass3.INNER_PARAMETER) //print: true&#125; 5. 类名可作为接口参数传入和 object 还是一样， companion object 也可以实现接口，因为 companion object 寄生于类，甚至类还可以直接作为实现了相应得接口的参数形式传入，拗口，看代码： 123456789101112131415interface MyInterface &#123; fun operateVariable() &#125;fun operateClass(interfaceObject:MyInterface) = interfaceObject.operateVariable()class MyClass3 &#123; companion object:MyInterface &#123; override fun operateVariable() &#123; //do something... &#125; &#125;&#125;fun main(vararg args:String) &#123; operateClass(MyClass3) //MyClass3 is now as the instance of MyInterface&#125; 6. 扩展类的静态成员Kotlin 的扩展功能非常强大，是程序猿爱不释口且口口相传的实用特性之一。那么我们怎么扩展类的静态成员呢？这个时候当然是 companion object 派上用场的时刻了！ 12345678910111213class MyClass2 &#123; companion object &#123; val INNER_PARAMETER = \"can only be inner\" &#125;&#125;fun main(vararg args:String) &#123; fun MyClass2.Companion.operateVariable() &#123; println(this.INNER_PARAMETER) &#125; MyClass2.operateVariable() //print: can only be inner&#125; 怎么样？ Kolint 就是那么强大！不得不服！ 三、总结以上就是我自己总结的一些基本点，总之， Kolint 真不愧是一个门好语言啊！另外官方并不建议我们到处滥用 object关键字，因为它不易控制也不利于测试，毕竟定义即实例化嘛，当然除了很容易实现单例模式，工厂模式也很简单，不信你可以试试。 话又说回来，我建议大家有时间还是有必要再把 Kotlin 代码转换成 Java 源码再分析一遍，这个时候 @JvmStatic 和 @JvmField 标志就发挥作用了。我写这篇文章的时候我并没有下功夫继续深究，有机会还会再去看看转化 Java 部分源码，那样会更加加深对 object 和 companion object 甚至整个 Kotlin 语言的认识吧！好吧，我就菜鸟一枚，那接下来就交给你总结一下并发表给我学习学习吧！谢谢！ 最后，引用官方文档说明，比较它们的实例化过程： object expressions are executed (and initialized) immediately, where they are used object declarations are initialized lazily, when accessed for the first time a companion object is initialized when the corresponding class is loaded (resolved), matching the semantics of a Java static initializer 资料：Kotlin笔记 Object表达式和声明： http://www.jianshu.com/p/f316ff2f4306Object Expressions and Declarations: https://kotlinlang.org/docs/reference/object-declarations.html","tags":"kotlin"},{"title":"【转载】加锁还是不加锁，这是一个问题","url":"/2017/06/14/talking-about-Java-concurrency-with-lock-or-unlock/","text":"非常浅显易懂又寓意深刻的一篇文章，转载自微信公众号【码农翻身】的文章，好文分享：加锁还是不加锁，这是一个问题，原文链接： http://mp.weixin.qq.com/s/qJNQeuDWjRCxkSG2nSK5Uw 一、前言上次我说过，我们这个线程的世界是个弱肉强食的地方，大家为了争抢资源大打出手，时不时闹出些内存数据互相被覆盖的事故，给人类带了无穷的烦恼。 后来线程元老院强势出手，发明了一种锁的机制，这才制止了内乱。从此以后我们要访问共享的资源（共享变量，文件…）都得想办法先申请到一把锁才可以。 （码农君注：关于锁的故事在《编程世界中的那把锁》有讲述） 二、互斥锁虽说锁是个好东西，但是我们线程日常使用的都是互斥锁，所谓互斥，就是同一时刻只有获得锁的那个线程才有资格去操作共享资源，别的线程都阻塞住了，被放到了一个叫锁池（ Lock pool ）的地方，什么事情都干不了。 比如说这个简单的 Sequence 类吧，有 100 个线程拼命地挤破头去进入 next() 方法，但由于 synchronized 的存在，大家必须得获得一把锁才可以，隔壁的小明运气不错，获得了操作系统的垂青，喜滋滋地得到了宝贵的锁，进入了 next() 方法去做事了。 而我们剩下的 99 个线程大眼瞪小眼，除了叹口气，感慨下人生之不如意十之八九，还能干嘛？ 老老实实地进入锁池里待着去吧！ 等到隔壁小明做完了事情，美滋滋地拿着最新的 value 值出来以后，我们这 99 个在锁池里吹牛的线程一跃而起，去竞争那个刚刚被释放的锁。 但是下一个幸运儿是谁呢？不知道？ 有时候人类为了公平，会搞个队列让我们排好队，先进先出。但是我已经活了 4.998 秒，人生快走到了尽头，在这么长的人生里，我体会到的真理是：公平实在是个稀缺货，不公平才是常态！ 所以年轻人不要老是抱怨这个社会，没用的，还是老老实实的奋斗吧。 三、不要加锁？平淡的日子就这么过着，有一天线程世界来了一个年轻人，自称为小李，他看着我们这么努力地奋斗着去争抢那把锁，不由地嘲笑道：你们真傻啊，难道不知道不加锁也能做事吗？ 我们愣了一下，人群中立刻发出一阵爆笑：哈哈哈，这小子疯了，没有锁岂不又回到互相覆盖数据的日子了！ 小李不甘示弱：你们这帮土老帽，把元老院的那帮老家伙的话当做圣旨，岂不知天外有天，人外有人，这世界大得很呐！ 这句话把我们镇住了，我小心翼翼地问：那你说说，不加锁怎么才能保证正确性呢？ 就拿你们的那个 Sequence 类来说吧，不就是并发的更新内存中的一个值吗，可以这么分为三步来做： 从内存中读取 value 值，假设为 10 ，我们把这个值称为 A B = A + 1 得到 B = 11 用 A 和内存的值相比，如果相等（就是说在过去的一段时间，没人修改内存的值），那就把B的值（ 11 ）写入内存，如果不相等（就是说过去的一段时间，有人修改了内存 value 的值），意味着 A 已经不是最新值了，那就放弃这次修改，跳回第 1 步去 我们面面相觑，就这么简单？真的没有加锁啊。 隔壁的小明反应最快：小李子，你这第三步有问题啊，你看需要读内存吧，需要比较吧，还得写入内存吧，这不是一个原子操作，在我们多线程并发执行的时候，肯定会出问题！ 小李说： “唉，说你们老土吧，你们还不服气，听说过 comare and swap 这个硬件指令没有？那个第三步其实就是一条硬件指令，保证原子执行。在单个CPU上就不用说了，如果是有多个CPU，这个指令甚至会锁住总线，确保同一时刻只有一个CPU能访问内存！ 这样吧，干脆写成个指令： compareAndSwap(内存的值，A ，B) ，这下子明白了吧？还不明白？估计是人类的语言你们听起来不太明白，来吧，给你们来点熟悉的代码：” 看到了我们熟悉的代码，我的脑海飞速盘算： 假定我和小明都同时进入了这段代码，都读到了内存的值 A = 10 ，然后小明的时间片到了，只好退出CPU，我则愉快的继续执行。 对于我来说 A = 10 ， B = 11 ，然后我运行 compareAndSwap ，我发现我的 A 值和内存值是相等的，于是就把新的值 B 写入内存，并且返回，退出 next 函数，收工回家。 等到小明再次被运行的时候，由于他的初始值 A 也是 10 ，他也得到 B = 11 ，当他运行 compareAndSwap 就发现 A 的值和内存不相等了（因为我改成了 11 ），那小明只好再次循环，获得 A = 11，B = 12 ，再次调用 compareAndSwap ，如果还是被别人抢了先，小明只好再次循环，从内存获得 A = 12 ，B =13 …. 直到成功为止。 想到小明一直循环下去，累得要死的样子，我“邪恶”地笑了。 我抬起头，正好和小明的目光相遇，看到他不怀好意的样子，估计也是把我置于无限循环的想象中了。 四、Java中的CAS小李说： “ Compare And Swap 这个词太长了，以后简称 CAS ，希望你们听得懂。” 小明问道：“我们是 Java 语言，你那个读取内存的值该怎么办，还有那个 compareAndSwap 函数，我们实现不了啊？” 小李说：“你们 Java 不是有 JNI(Java native interface) 吗？可以用 C 语言来实现，然后在 Java 中封装一下不就得了？” “看看这个 AtomicInteger ，他就代表了那个内存的值，那个 count.compareAndSet 方法只有两个参数，实际上内存的值隐藏在了 AtomicInteger 当中，你们 Java 不是喜欢面向对象嘛！” 我们仔细地审视这段代码，它根本没有加锁，每个人都可以进入 next() 方法，读取数据，操作数据，最后使用 CAS 来决定这次操作是否有效，如果内存值被别人改过，那就再次循环尝试。 小李总结到：“你们之前的 synchronized 叫做悲观锁，元老院太悲观了，总是怕你们把事情搞砸，你看现在乐观一点儿，不也玩的挺好嘛！每个线程都不用阻塞，不用在那个无聊的锁池里待着。要知道，阻塞，激活是一笔不小的开销啊。” 五、CAS的扩展使用非阻塞算法的线程越来越多，小李趁热打铁，提供了一系列所谓 Atomic 的类： AtomicBoolean AtomicInteger AtomicLong AtomicIntegerArray AtomicLongArray 这些工具类都很好用，大家非常喜欢，只是我们发现小李的这些工具类只支持简单的类型，对于一些复杂的数据结构，就不好使用 CAS 了，因为使用 CAS 需要频繁的读写内存数据，并且做数据的比较，如果数据结构很复杂，那读写内存是不可承受之重，还不如最早的悲观锁呢！ 小李胸有成竹，马上给出了改进：不要比较数据啊，只比较引用不就得了，这里有一个 AtomicReference ，拿去用吧。 我们向元老院做了推荐，那些老家伙们可真是有两把刷子，立刻提出了一个我做梦都没有想到的问题： 假设有两个线程，线程 1 读到内存的数值为 A ，然后时间片到期，撤出 CPU 。线程 2 运行，线程 2 也读到了 A ，把它改成了 B ，然后又把 B 改成原来的值 A ，简单点说，修改的次序是 A -&gt; B -&gt; A 。然后线程 1 开始运行，它发现内存的值还是 A ，完全不知道内存中已经被操作过。 （码农君注： 这就是著名的 ABA 问题） 我想了一下，好像没什么啊，不就是把数字改成了原来的值吗？也没什么影响。 可是小李却陷入了沉思，看来这是一个挺难的问题，他口中念念有词：如果只是简单的数字，那没什么，可是如果使用 AtomicReference ，并且操作的是复杂的数据结构，就可能会出问题了。对了，我可以用一个版本号来处理啊，给每个放入 AtomicReference 的对象都加入一个 version ，这样以来尽管值相同，也能区分开了！嗯，我就叫他 AtomicStampedReference 吧。 元老院很满意，但是还是发了一个公告： 鉴于最近使用 AtomicXXXX 的线程越来越多，元老院有责任提醒各位，用这些类实现非阻塞算法是非常容易出错的，在你自己实现之前，看看元老院有没有提供现成的类，例如： ConcurrentLinkedQueue 。如果非要自己写，也得提交给元老院审查通过才可以使用。 六、后记： Doug Lea如果说要从 Java 世界中找一个并发编程的大牛，我想这个人非 Doug Lea 莫属，从 JDK 1.5 开始， Java 引入了一个非常著名的线程并发库 java.util.concurrent ，由于其良好的抽象，这个库极大的降低了并发编程的难度，其作者就是并发编程的权威 Doug Lea ，他是纽约州立大学 Oswego 分校计算机科学系教授， JCP （ Java Community Process ）执行委员会成员， JSR166 （并发编程）的主席，文中的小李就是向 Doug Lea 致敬。 你看到的只是冰山一角，更多精彩文章，请移步《码农翻身文章精华》有心得想和大家分享？ 欢迎投稿 ！ 我的联系方式：微信：liuxinlehan QQ: 3340792577码农翻身用故事给技术加点料","tags":"随笔 java"},{"title":"MAC上使用Android Studio 3.0的Gradle问题小解","url":"/2017/06/11/solve-several-problems-of-gradle-in-android-studio-3-0-on-mac/","text":"一、问题Google I/O 大会后发布了最新的 Android Studio 3.0 预览版，其中新版本的新特性中直接支持我很想使用的 Kotlin 语言。今天开始认真学习安卓开发（ ），我就打算直接使用 Kotlin 语言在 AS 3.0 中写代码，简洁又高效。 下载了 Mac 版本的 Android Studio 3.0 Canary 3 后，发现新建项目后出现一些构建上的问题，主要是 AS 3.0 预览版构建工具使用的是 4.0 新版本的 Gradle ，在工程项目文件： gradle/wrapper/gradle-wrapper.properties 中可以看到这一行： gradle-wrapper.properties1distributionUrl=https\\://services.gradle.org/distributions/gradle-4.0-milestone-1-all.zip 然后出现几个问题的错误信息包括： 12345678Unable to load class 'org.gradle.internal.event.ListenerBroadcast'Possible causes for this unexpected error includes: Gradle's dependency cache may be corrupt (this sometimes occurs after a network connection timeout.) Re-download dependencies and sync project (requires network) The state of a Gradle build process (daemon) may be corrupt. Stopping all Gradle daemons may solve this problem. Stop Gradle build processes (requires restart) Your project may be using a third-party plugin which is not compatible with the other plugins in the project or the version of Gradle requested by the project.In the case of corrupt Gradle processes, you can also try closing the IDE and then killing all Java processes. 还有： 1234Failed to open zip file.Gradle's dependency cache may be corrupt (this sometimes occurs after a network connection timeout). Re-download dependencies and sync project (requires network) Re-download dependencies and sync project (requires network) 这些问题在网上随处可见，一般按照提示都能解决，但是我的不行！另外，在我后来 Windows 10 上使用 AS 3.0 时并没有出现这些 Gradle 相关的问题，构建一切正常！（除了长达一个小时的后台任务外 ），所以这些都是和系统上有相关的小问题，在网上 Google 和 Stackoverflow 搜索后陆续解决。 二、解决方法不仅仅是上面的构建问题，还有后面陆续出现的 Build 速度慢、 support 包不能用、 Genymotion 模拟器不会连接等等，都需要自己尝试解决，毕竟新手啊！ 安装设置 Gradle Home 首先最基本的思路是查看本地 Gradle 是否安装。用过 Linux 系统的朋友很清楚，一个命令行就可以知道： gradle -v 这个命令能查看 Gradle 的版本，我的 Mac 显示 no such command ，所以先安装 Gradle ，参考官网安装指导，我用的 Homebrew ： 1$ brew install gradle 这样安装好之后，一般 Gradle Home 也设置好了，我写此文的时候 Gradle 在我机器上的版本是 3.5 。 手动下载并手动设置 如果按照上面步骤安装好本地 Gradle 后在 Android Studio 中出现这种错误信息： 1Error:(1, 0) Minimum supported Gradle version is 4.0-milestone-1. Current version is 3.5. 说明版本不适配 AS 3.0 中要求的 Gradle 版本，那么可以直接手动安装并解压到 /usr/local/Cellar/gradle/&lt;your-version&gt;/ 下以备用，下载地址直接使用 gradle-wrapper.properties 中描述地地址，记得去掉 \\ 符号。 手动设置 Gradle 工作路径 按理来说，下载了相应版本后只要设置 Gradle Home 到新版本的路径就可以了，不过我没有，你可以尝试一下。 我采用的是直接在 Android Studio 3.0 预览版中单独设置 Gradle 的工作路径。在设置中： Android Studio-&gt;Preferences...-&gt;Build, Execution, Deployment-&gt;Gradle 选择 Use local gradle distribution 然后指定 Gradle home 为你下载解压路径。 OK 了，开始写代码吧！不过我还是碰到了一些不爽的问题，就像我上面描述的：Build 速度超慢、 support 包不能正确编译、 Genymotion 模拟器连接不上等。实际上这些都是小问题，但是这会难倒新手。 Build 速度、 support 包、 Genymotion 模拟器 解决办法很简单： 1. 改进 Build 速度 根目录 build.gradle 中设置本地仓库和阿里云仓库： 12345mavenLocal()maven &#123; url 'http://maven.aliyun.com/nexus/content/groups/public' &#125;maven &#123; url 'https://maven.google.com' &#125;jcenter()mavenCentral() 2. 解决 support 包问题 感觉 4.0 的 Gradle 还是变化挺大的，以前的 compile 变成了 implementation ，如果遇到编译期间出现的这个问题： 1Error:Failed to resolve: Could not resolve com.android.support:recyclerview-v7:25.4.0. Required by: ...... 那么直接在 app 目录下 build.gradle 中相应库引用位置添加注释： //noinspection GradleCompatible 12//noinspection GradleCompatibleimplementation 'com.android.support:recyclerview-v7:25.4.0' 感觉这是个 Bug ，有时候又能用，奇怪。 另外我还遇到了一个问题： implementation &#39;com.android.support:appcompat-v7:25.4.0&#39; 还是不能用，不知道为什么，有朋友知道恳请留言指导，谢谢！ 3. 模拟器 Genymotion 连接调试 这是个小问题，新手的话有必要提醒一下。如果不能正常连接 Genymotion 的模拟器，需要在模拟器中设置 SDK 为 Android SDK 。 在 Settings-&gt;ADB 下，选中设置 Use custom Android SDK tools 就可以了。 好了，一切就绪，愉快的 code 吧！ 三、总结Gradle 还是很神奇的，目前它使用的 Groovy 语言，同时 Kotlin 语言版的 Gradle 也在进行中： gradle-script-kotlin ，现在也有预览版可以尝鲜，我也正在尝试使用 Kotlin 版本的 Gradle ，可以参考这篇文章：Using Gradle Script Kotlin for Android ，遗憾的是，还没有成功啊，暂时不折腾了，新手能力有限，慢慢来吧！ 好吧，就这些小问题，也是对新手的一个考验，留下纪念。 参考资料：Install a Preview Version of Android Studio: https://developer.android.com/studio/preview/install-preview.htmlGradle service version distributions: http://services.gradle.org/distributions/Gradle Installation: https://gradle.org/installUsing Gradle Script Kotlin for Android: https://medium.com/@arturogdg/using-gradle-script-kotlin-for-android-d6cd58c80d60Android Studio - Error: Failed to resolve: com.android.support.constraint:constraint-layout:1.0.0-alpha1: https://stackoverflow.com/questions/40160968/android-studio-error-failed-to-resolve-com-android-support-constraintconstrAndroid Studio doesn’t see genymotion: https://stackoverflow.com/questions/27261474/android-studio-doesnt-see-genymotionGradle 使用 maven 镜像仓库的方法: https://my.oschina.net/abcfy2/783743 PS (2017-08-25) ： 更新 Android Studio 从 Alpha 到 Beta 版本出问题： Gradle project refresh failed.解决办法是 AS 中： Build &gt; Clean ProjectKnown issue: If you have an existing Android Studio project that’s using an alpha version of Android plugin 3.0.0 (such as 3.0.0-alpha9), you may get the following error when you migrate to Android plugin 3.0.0-beta1 and sync your project: Gradle project refresh failed.Resolve this issue selecting Build &gt; Clean Project from the menu bar—you need to perform this action only once for each project. You can then sync your project files with Gradle by clicking Sync Project from the toolbar.https://androidstudio.googleblog.com/2017/08/android-studio-30-beta-1.html","tags":"android gradle"},{"title":"【翻译】17位谷歌专家称号大牛如何看待Kotlin","url":"/2017/06/03/what-do-17-GDEs-for-Android-think-about-Kotlin/","text":"一、译前说明貌似 Kotlin 是不是已经过了最火爆的那段时期了？其实不管怎样，我都要把这篇文章尽我最大努力翻译出来给大家看看，尽管 Kotlin 已经被招安，尽管文章的观点因为谷歌 IO 大会而过时，尽管本人翻译水平是那么的不靠谱，但是至少我还是不会曲解人意的，至少他是大牛们的观点，我能做的是尽量把翻译做更好吧。 这篇文章由 Kotlin 布道者： Antonio Leiva 在谷歌 IO 大会（ 5 月 17 日）开展之前发布的（ 发布时间是 5 月 15 日），相信有一部分同学熟悉这位大神：我姑且认为他是最早出版安卓 Kotlin 相关书籍的大牛，而且毫无疑问他的书是最早关于 Kotlin 方面的安卓书籍被翻译成中文版的。但是，我这里还是要说但是，你可以从文章内容看出来，他认为谷歌接受并支持 Kotlin 为官方开发语言是没有什么可能性的，这也许是他采访 17 位谷歌大牛并发表他们对 Kotlin 看法文章的动机吧。 二、译文谷歌已经多次表态申明他们并无反对 Kotlin 的使用，而编译器能够正确地编译识别 Kotlin 代码表明谷歌并没有阻止任何人对 Kotlin 的使用。 但是，很多人还是一直在等待谷歌官方的正式支持，但这几乎是不可能的事情。 尽管我们在等待这个时刻的到来，但是我认为了解谷歌安卓开发专家们对它的看法还是很有必要的。 你是听说过，谷歌开发专家 （ GDEs ）是谷歌赋予那些在特定领域有着独特贡献的专业人士的荣誉称号。 我只联系上了其中一些专家们（谷歌开发专家人员列表非常的长！），并得到了他们当中 17 位的回答。非常感谢他们的友好真诚的心以及能够抽出时间来为我解答。 我只是问了他们一点点关于 Kotlin 的信息，以及他们是怎样看待 Kotlin 的。毫无疑问，我并没有对他们的看法做过任何修改，因此在文章中你能同时看到有支持和反对（或许并非如此）两种声音。 我由衷希望这些观点能有助于你了解 Kotlin 是如何改变游戏规则的，并且，如果你是一名安卓开发者的话，至少能让你开始考虑使用 Kotlin 吧。 马上进入正题，以下就是我们这些谷歌大牛们的观点，排名不分先后： 1. Annyce Davis Annyce 是一名谷歌安卓开发专家，她在过去 6 年里一直致力于多种多样的安卓生态系统相关应用开发。同时她也是一名国际会议演讲专家、作者，同他人分享在安卓开发中的经验。 我曾经开发过 Grails 应用，使用的是 Groovy 这门开发语言。 Groovy 相对于 Java 有相当巨大的改进。它非常简洁且避免了很多当时在 Java 6 中出现的代码重复模板工作。当 Kotlin 出现在我的视野时，我立刻被那些我记忆中 Groovy 类似的语法所吸引。它同样的清晰而简洁。 我是一名狂热的学习份子，我如饥似渴的学习 Kotlin 并开始玩转 Kotlin Koans 。我也预定了早期版本的 Kotlin in Action 这本书。最终让我转变的是 Hadi 的 Kotlin 广播。最终我决定认真地对待 Kotlin 并在它的 1.1 版本发布之后开始把它应用到我的产品开发当中。 对于安卓开发者来说它有很多优势。最重要的一点是它的类型系统和空指针异常处理特性。这会强制你明确哪个变量可空，并作相对应的处理。编译器接着跟进并保证赋值总是有效的。空指针异常是我在安卓应用开发中遇到的最常见的一种异常。 Kotlin 在这个方面创造了一个良好的平台。 在我看来，另一个巨大的制胜点就是它的函数扩展功能。它能够为 Context ， Activity 添加扩展方法，同时它的数据类也使得我的代码更加简洁，可读性也有增强。 使用 Kotlin ，我的代码变得简洁而又健壮！ 观点：Kotlin 对于安卓开发者有很多优势。采用 Kotlin 开发，我的代码变得简洁而又健壮！ 2. Sebastiano Poggi 在意大利北部雾都平原做智能手表开发后他开始崭露头角，Sebastiano 带着他那缕卷发来到了伦敦准备大干一场。作为会议演讲嘉宾以及网络思维传教士的他在 2014 年获得谷歌程序开发专家的称号。最近他沉迷于 UI 和 UX 设计，目前在 Novoda 公司写一些很酷的软件。 我非常、非常的喜欢这门语言！我个人感觉是它让写代码成为了一种乐趣，相反这些在 Java 中确是非常痛苦和厌烦的事情。我算不上一名专家，因为我还没有在我的日常工作中着重使用它，但是我在自己边缘项目中使用过。你听说过传说中的 10 倍效率开发者吗？ Kotlin 有时候让我有种自己就是传说中的 10 倍效率开发者的感觉（我一直不相信有谁能够成为 10 倍效率的开发者，但是现在是个很好转变思维的开始）。 这门语言除了明显简洁语法特性之外，我非常喜欢那些额外的 API 和它所打造的整个生态系统。例如，不可变集合，有时候我认为他是非常有必要的，如果在软件开发中没有使用（部分没有使用？） Guava 的话，你根本不可能在 Java 中使用到它；然而这在 Kotlin 中是第一步就被实现了的。而且这意味着很多东西。噢，我有没有提到我非常兴奋地看到了他们在发布了对 LLVM 的支持后还将会发生的一些事情？ 就像我刚提到的，我的日常工作并没有包含 Kotlin 的使用。有很多理由可以解释这个项目能够从中受益，但是我们的项目如要采用 Kotlin 地话也非易事，如此大的团队规模是这个产生这个困难的主要原因。我也能观察到 Kotlin 存在的问题：缺乏静态分析工具，也没有现成的设计模式。 后者相对来说不是一个大问题，如果你的项目没有那么复杂的话。但是如果有 10 个开发者同时工作在一个代码模块上，而且还拥有将近 10 年的迭代历程，那么有一个较好的现成的模式将会极大地稳定你的军心。当然，你可以使用 Java 的模式，但是并不是所有那些模式都适合 Kotlin 的，因为有不少模式的设计局限在 Java 之上。这是一个很长的话题，我就此打断以让我继续完成我的整个看法。 前面提到的那个问题，对于我来说，是非常关键的一个问题，而且确实是一个致命的问题。原因在于实际开发中你不能使用 PMD ， Checkstyle ， Findbugs 和其他一些工具（我没有尝试过 Errorprone ）这将会形成一种非常危险的状况。比如，你有 3 到 4 个以上的开发者，你不能总是期望一直对代码编写风格上进行严格的监督。更重要的是，你所使用的工具中缺少很多深层次的 BUG 检查机制。我请你举起手来，如果你从来没有使用过静态分析工具（正确使用）的话，我根本不相信！目前，我知道有一些 IDE 带有基本的检查机制，但是那些还远远不够强大（暂时）；也有一些项目给 Kotlin 带来了静态分析功能，但是这些项目暂时还不能成为你所能依赖的对象。我很期待看到它们变得越来越成熟，最终能让我们自信地采用他们！ 话说回来，我现在正在我自己的小项目中使用 Kotlin ，我非常喜欢它。 观点：你听说过传说中的 10 倍效率开发者吗？ Kotlin 有时候让我有种自己就是 10 倍效率开发者的感觉。 3. Jorge Barroso Jorge Barroso 是 Karumi 公司的安卓开发者也是公司合伙人。一个独特的小型软件开发工作室，总部坐落在 Madrid ，专注于开发简洁而又稳定的原生程序，同时和团队一起致力于技术提升。Jorge 有着长达 10 年的软件工程经验，他把自己定义为一个实用主义码农，专注于提升安卓项目的架构，是一名坚定的语义性代码概念和软件开发测试的倡导者。他持续不断的学习并研磨安卓代码技巧，努力了解并适应内部框架的演变。 Kotlin 是安卓开发界的一大进步。安卓缺少一些东西，相比较其他的 Java 平台它是有点落后了，即使是 Java 8 的推出也不能阻止它成为一门我们所喜欢的现代语言。 我觉得目前最大的问题在于移植，很难说服一个公司转型到 Kotlin 并告诉他们价值所在。对于科技型公司这会相对轻松些，因为这是对公司开发者的一种激励和挑战，但是对于小型企业却很难。另外，很多企业担心 Kotlin 得不到谷歌公司的支持，这会导致移植结果半途而废。 我喜欢这门语言以及它所构建的生态系统，我希望能够在我的日常开发中更多地去使用它，但是，很显然我的工作项目并不允许我这么做。我鼓励大家去尝试一下，不仅仅是 Kotlin 这门语言，还有其他的一些语言，因为这会开拓大家的视野并且在软件编写过程中学到很多东西。 观点：Kotlin 是安卓开发界的一大进步，我喜欢这门语言以及它所构建的生态系统。 4. Donn Felker Donn Felker 是 Caster.IO 的创始人和首席执教官， Fragmented Pdocast 的合伙人，谷歌安卓开发专家，同时也是手机类畅销书的作者。 它很有趣，我很喜欢。它给安卓开发界带来了一缕新鲜的空气。 观点：我喜欢 Kotlin 。他给安卓开发界带来了一缕新鲜的空气。 5. Mark Allison Mark Allison 是自由职业安卓开发者，也是 stylingandroid.com 网站博客作者。 虽然 Kotlin 有很多让我喜欢的地方，但是我认为它在投入项目实际生产中还不够成熟。 Kotlin 中缺乏现有的模式以及最佳实践，这会导致代码很难维护。 这反映在 Kotlin 缺乏静态代码分析工具上。他并不能完美地利用 Java 的静态代码分析工具，这会是技术债务的一个明显的信号灯。 Java 工具不能用在 Kotlin 上是因为这些工具只是专门分析 Java 源码。 观点：我认为 Kotlin 在项目成品中应用还不够成熟 6. Huyen Tue Dao Huyen Tue Dao 就职于 Atlassian 的 Trello 平台。一半的工作是处理安卓对话框。 我完全地、疯狂地迷恋上了 Kotlin （那个词是“ C ”还是“ K ”？）。在工作上我们已 100% 使用 Kotlin ，而且，当然包括实际产品代码！实际上，只要我能做到的地方我都用 Kotlin 编写代码，这得益于和 Java 的完全互操作性。在享受和利用 Kotlin 的强大的现代语言特性的同时，我仍然可以随意访问平台的 API 以及其他已经编写好的代码集和类库。 因为 Kotlin 是新出的，所以我们现在全部都在探索和定义最佳的实践方式，我不得不仔细审查每一行代码在不同层次带来的作用。这很有趣，也强迫我对一些决定做出更多的深思熟虑和责任担当。 这门语言超乎想象的简洁。我喜欢安卓，但是我们做了大量重复的模板工作， Kotlin 能帮我们减少很多重复的工作。当然过于简洁会导致可读性方面的问题，但是我认为大部分时间里 Kotlin 实际上提升了代码可读性，我们也不至于太过于疯狂地在意我们所需要的最佳实践效果。 观点：在工作上我们 100% 采用 Kotlin ，而且，当然包括产品代码！ 7. Dmytro Danylyk Dmytro Danylyk 是一名开发者，作者和讲师。对安卓开发和平面设计充满激情。目前在 Atlassian 的悉尼工作室工作，对于他来说，这是澳大利亚提供的最好的工作环境了。 Kotlin 打破了那些争执于安卓开发界的游戏规则。它有很多我喜欢的特性比如：空指针安全，数据类，属性，懒加载属性，函数扩展性，协程，不可变性等等。 我很享受使用 Kotlin 编程，因为我完全就不需要使用其他的第三方类库了， Kotlin 已经提供了大部分现成的功能。 感谢 JetBrains 公司给我们提供了强大的 IDE 支持以及众多的学习材料，甚至包括在线 REPL 编程。 观点：我很享受使用 Kotlin 编程，因为这样我完全不需要使用其他的第三方类库。 8. Anup Cowkur Anup Cowkur 是一名谷歌安卓技术专家，是 GO-JEK 公司安卓骑行航海产品的技术研发组长。他在印度 Droidcon , Stockholm 等地演讲过。多篇安卓论文的作者， Bangalore 安卓用户群组的组织者。 我曾经使用过像 Haskell 和 Elixir 这样的语言进行编程，我当时就在想，“为什么我们在安卓上没有那些好东西呢？” 但是，现在有了，我们有了 Kotlin 。 可选类型自动由系统处理，函数成为一等公民，正则匹配（部分）以及不可变类型，这些特性让我能够在安卓上做真正的函数式编程。 观点：Kotlin 让我能够在安卓上做真正的函数式编程。 9. David Vávra David Vávra 是安卓和 Firebase 谷歌技术专家。他带领他的初创公司进行安卓架构的开发工作。他是 Prague 地区 GDG 的组织者，非常热爱开源，小程序和实况角色扮演。 我已经在产品开发中使用 Kotlin 进行主程序开发（ Settle Up ）。它已经足够成熟，相比 Java （任何版本） 有很多优势。它完全兼容现有的 Java 工具集和类库，在 Android Studio 中完美工作。 如果我启动一个新的 APP ，我会毫不犹豫地从 Kotlin 开始。一种很常见的反对观点是：“如果我的队友不会的话，那将会产生抱怨以致影响生产效率”。我不同意这种观点，从 Java 转变过来是不费吹灰之力的。而且，那些优势也会在早期的进度中就能显现出来。比方说，使用 RxJava 库极其麻烦。 对于现有的 APP 移植——这就要看情况了。打个比方你可以只用 Kotlin 写一部分代码，如果你想充分利用这门语言的优势的话，你最好做到 100% 的转变。这很难说服项目的持有者。 唯一 Kotlin 需要的是一个谷歌官方的“批准盖章”。谷歌目前没有任何动作，除了或许可能会在文档中添加 Kotlin 版本的代码（就像 Swift / ObjectiveC 那样）。如果成为现实的话，我们将会看到 Kotlin 成为主要生产力。为今年的 I/O 大会祈祷吧！ 观点：我在产品开发中使用 Kotlin 开发主程序。它已经足够成熟而且有很多优势。 10. César Valiente César Valiente 是微软公司的一名安卓工程师，前 Wunderlist 公司核心安卓开发人员。 FLOSS （免费开源软件）的布道者。谷歌安卓开发专家。演讲家。他是一个非常好相处的人。 我认为 Kotlin 是一门神奇的现代语言。 它的学习曲线非常平滑，你可以在某一天上午研究一下，然后当天结束后你也许就能用它写一些代码了。用它写代码很享受，使用起来也很有趣，它非常简洁，拥有其他现代语言所拥有的特性，它由 JetBrains 公司的牛逼技术团队持续不断地开发，也得到了社区的大力支持，而且， Kotlin 是开源的哦！ 我不会花很多时间来解释 Kotlin 的那些让程序员生活得更美好的特性，对于这些特性，你可以看一下那描述地相当好的文档，对于练习的话，你可以直接在我们的 IDE 中使用 Koans 或者到网上找那些不断由社区发布的不可思议的新东西。 在安卓方面， Kotlin 给我们安卓开发者带来了一缕新鲜的空气，给了我们重新享受软件开发的新理由，并且在每天的工作之中很重要的一点是使用 Kotlin 你会写少编写很多的代码，避免了大量重复模板，代码的可读性也变得更好，得益于你写代码所花的时间越来越少，你的效率也变得更高，而且就像我之前说的， Kotlin 会给你带来享受乐趣！ 问题也摆在那里，至少对于安卓社区来说，那就是：现在 Kotlin 可以投入生产了吗？我的答案是……当然可以啦， JetBrains 去年就发布了 1.0 的稳定版本。 你会认为 JetBrains 公司的那些天才们在还不能投入生产前就发布 Kotlin 吗？当然不会。他们自己就使用了 Kotlin 做项目，并且其他的一些被认可的大公司也在使用 Kotlin 投入生产了。 好吧，好吧，貌似一切都是那么美好，也应该会有那么一点不好的地方，是吧？当然是的，这其中一个问题是社区急切渴望的静态分析工具。静态分析工具对于开发团队来说非常重要。我们在 Kotlin 上仍然缺少这样的工具，当然你可以做构建，测试等实质性的重要事情，但是目前 Kotlin 仍然不能使用那些在 Java 中极其重要的工具比如 Checkstyle， PMD ，findbugs 等。（好吧，我们在 IntelliJ 中有内部代码分析功能但是这还不够强大）。 因此，如果你在一个大团队里工作，那么静态分析工具在你的日常基本工作中是非常重要的（理应如此），那么你也需要更深入地去关注这一点。如果你是在一个小团队工作，或者你能掌控一切的话，那么就不要犹豫了吧！ 总而言之，我想说的是 Kotlin 真的很强大，你会更加觉得有乐趣而且你也会更加高效（至少对于 Java-Android 组合来说），尽管静态分析工具还是大家需要考虑的问题，但如果你不需要这个工具也能进行的话，那么请勇往直前，尝试一下吧，你也会爱上它的！ 观点：在安卓方面， Kotlin 给我们安卓开发者一缕新鲜的空气，给了我们享受软件开发的新理由。 11. Nelson Glauber Nelson Glauber 是 Mokriya 的一位高级安卓开发工程师，也是巴西东北部继续教育扩展课程手机开发方向的教授。 2014 年谷歌第一次提名他为拉丁美洲的安卓开发专家。 2015 年他加入了英特尔创新者计划。他在多个国家和区域的活动中做过演讲，为自己的个人博客和一些专业杂志撰写过关于手机开发方面的文章。他也是《精通安卓：从入门到高级》这本书的作者（葡萄牙语），出版于 2015 年 1 月份。 Kotlin 是一门令人印象深刻的语言。这门语言有着令人惊奇的特性，相比 Java 语言它去掉了一大堆模板代码。更不用提它能兼容市面上大部分的类库了（包括 Java 代码编写的）。另外这门语言很容易被使用的一个理由是：它和 Android Studio 能完美而稳定地兼容。 对于 Java / 安卓开发者来说它的学习曲线非常低（可能对新手不会）。我从去年开始学习 Kotlin ，通过阅读 Antonio 的书（顺便提一下这本书真的很棒），从那时候起，我就已经在我的个人项目和课程中采用这门语言了。 不幸的是，我目前并不能在我的产品开发中采用它，但是我丝毫不怀疑这门语言已经足够成熟并已准备好在大型产品开发中高效率地使用。 在我看来，你还未曾使用这门语言的唯一理由是：一旦你开始用 Kotlin 编程，你就根本不会再用 Java 了。 观点：一旦你开始用 Kotlin 编程，你就根本不会再用 Java 了。 12. Ryan Harter Ryan Harter 是 Pixite 公司的安卓开发组组长，这是一个开发创意软件的小公司。他做了大量图形设计方面的工作，同时也很享受实现一些人们所喜爱的流畅、愉快的互动的相关开发工作。 大概在一年之前我就开始使用 Kotlin 编写代码了。有了一些经验后，我发现它很稳定，并且这门语言的一些特性所提供的便利为迁移和转变提供了足够的理由。得益于与 Java 的互操作性，一旦遇到任何 Kotlin 中我不能解决的问题，我都能回滚到 Java 中解决。 这门语言最强大的，说来也是简单的一个特性是函数扩展功能，它确实简化了我的工作流程。在我的图形工作中，我最终需要做很多算法和矩阵相关的内容，这意味着需要很多的工具类。函数扩展功能极大地简化了这一点并且让我的代码变得更加简洁。混合着函数编程功能让我的工作流程变得更加享受。 我给那些需要考虑迁移的开发者们一个最大建议是： Kotlin 并不意味一切也非完全不是。它能很好地和现有的 Java 代码一起工作，因此你可以浅尝辄止然后在适当时机到来之时再深入。 观点：Kotlin 最强大的特性是函数扩展功能，的确简化了我的图形工作流程。 13. Ubiratan Soares Ubiratan Soares 是一名软件工程师，经验丰富的安卓开发者。 从目前开发者体验的角度来讲， Kotlin 是安卓的未来。 Kotlin 目前正在做的就如同 Gradle 三年前对安卓开发者所做的一样；作为安卓开发者社区的一员，我们应该拥抱 Kotlin ，广泛传播 Kotlin ，让 Kotlin 更加强大并吸引大量开发者，因为用更好的方式开发安卓软件能让我们的客户满意，也让我们的工作更美好这些都是我们应得的。 观点：作为安卓开发者，我们应该拥抱 Kotlin ，广泛传播 Kotlin ，让 Kotlin 更加强大并吸引大量的开发者。 14. Philippe Breault Philippe Breault 是居住在 Montréal 地区的一名法裔加拿大开发者。他是一名谷歌安卓开发专家，喜欢尝试去说服每一个人转移到 Kotlin 上。你可以经常在推特上看到他。 Kotlin 带来了一缕新鲜的气息，对于安卓开发者来说。 我喜欢用 lambda 表达式所完成的工作。让 Kotlin 编译器支持内联函数，这是很有意义的，对于我们安卓开发者来说，使用内联函数能够在多级循环中避免不断地实例化新物体。 它同样也很简洁：没有冒号，同一行对变量的赋值不需要重复写出类型，属性代替 getters/setters 等等。它让代码更加易于理解。 唯一一件我希望看到的事情是能够提升安卓 Gradle 插件和 Kotlin 插件之间的交互性。目前为止，如果你试图停留在两方交锋边缘的话，它可能每过一会儿就会崩溃。 言下之意，每个安卓开发者都应该关注一下这门语言或者，最好是尝试一下吧！ 观点：每个安卓开发者都应该关注一下这门语言，甚至最好是尝试一下吧！ 15. Iñaki Villar Iñaki Villar 在 5 年前就是一名安卓开发者，他曾今在西班牙开发银行软件有三年之久。之后他搬到爱尔兰为航空公司和 GSM 运营商开发软件。现在他定居泰国为 Agoda 工作。他是一名谷歌开发专家，活跃于安卓社区。 Kotlin 给安卓平台带来了新的酷点子。这不仅仅只是意味着使用其他语言来编写一些类或者 Activities 。 目前我们正在把自动化框架部署到 Kotlin ，我们非常享受用声明的方式定义我们自己的 DSL 的过程，这让开发人员和质量评估员能够写出更加流利的测试代码。 观点：Kotlin 给安卓平台带来了新的酷点子。这不仅是意味着用其他语言编写类。 16. Dan Lew Dan Lew 是 Trello 的一名安卓开发者，一名极客玩家。 Kotlin 能够在不牺牲安全和性能的前提下写出比 Java 更加简洁和易读的代码。 Kotlin 是编译成二进制代码的，所以它能保持和 Java 一样的效率。它和 Java 一样能够在编译时进行代码检查（还有更多，比如内置空指针检查等）。更重要的是， Kotlin 的语言特性和标准函数库能写出更加简洁、有效的代码。 此外， Kotlin 的生态系统很强盛。很自然的， JetBrians 的工具支持也非常好。除此之外，这门语言一直在维护和提升之中。 JetBrains 在每次更新时也都没有打破 Kotlin 的兼容性。而且， Kotlin 能友好地和 Java 互动，这使得从 Java 迁移到 Kotlin 变得很容易。 最后，作为一名安卓开发者，对于我的选择来说还有一个很重要的理由是： Kotlin 能独立于操作系统进行更新。由于 Java 的功能是绑定在安卓对应系统上的，所以你经常会错过一些新的语言特性和标准的 API 库。恰恰相反，你立刻就能采用所有 Kotlin 新版本刚发布时的新特性。 观点：Kotlin 能够在不牺牲安全和性能的前提下写出比 Java 更加简洁和易读的代码。 17. Enrique López Mañas Enrique López Mañas 是一名谷歌开发专家，独立 IT 顾问。他从 2007 年就开始学习并从事手机技术开发工作。他是一名狂热的开源社区和免费开源软件贡献者，在德国跻身于 Java 开源贡献者中的前十名。他是谷歌 LaunchPad 加速器的成员，他积极参与其中，影响了来自全球各地的数百家最好的创业公司。他也是大数据和机器学习的爱好者。 我自从成为一名 Java 成员后就自然而然的开始了安卓软件开发。 Kotlin 这门语言出现后，我就决定做一些尝试。在那个时刻确实是一个充满意义的选择。对于我个人而言，要从 2009 年那个时间开始。 Java 诞生于 1995 年。从那个时候开始陆陆续续发布了一些版本更新，扩大和提升了一些基础的特性，一直到现在的 Java 8 版本。 Java 是在 22 年前设计的，并考虑了整个技术发展的演进，一直到现在都还有一些难以忽略的问题。作为一个开发者，我经常会尝试其他的语言。其中最值得一提的解决 Java 这些问题的一门语言是 Scala 。而另一个转折点是我看到了 Swift 这门语言。我也在 iOS 上编写代码，我注意到了 Swift 是如何克服像空异常这类很明显的问题的方式，这让我关注到了在 Java 中经常被忽略的一些问题。 基于它的特性，安卓天生支持所有 Java 7 版本的功能，但是只支持一部分 Java 8 所展示的特性。这意味着减速了安卓生态系统平台的发展。好在 Kotlin 现在可以帮助填补这个空白了。 Kotlin 是一门现代语言（版本 1.0 发布于 2016 年 2 月份）。它的最初目标就是解决 Java 中的不足，就如同 Scala 做的，不过它只解决了一部分现有的问题（比如编译时长）。 JetBrains 在 Kotlin 中做了一些了不起的事情，而且上个版本中在编译时长这点上有很大的进步。作为 Kotlin 新手，我当初所担心的问题现在在我心里都已经有了解答： —— 和 Java 的互操作性： Kotlin 能够直接和 Java 的类进行交互。这是一个基本出发点：我的确需要重用我的代码库并应用到 Koltin 当中。 —— 转换工具：尽管不能盲目的相信 Java 自动转成 Kotlin ，但是它确实做的非常好了。当我在转化 Java 类库的时候，我想到的结果是能够让我很轻松地重用 60%-70% 的代码。我的目标并不是想一夜之间把整个 Java 代码库转换成 Kotlin 的代码，但是只要一步一步的照做，那么在应用了自动转化之后，进行代码修改的时间是最少的。 对于 Kotlin 自身来说，在使用 Java 多年后，能够尝试一些新鲜的事物会是一种非常美好的体验。如果你是一名 Java 程序员，那么 Kotlin 的语法会让你感到非常熟悉自然的。又或者你是一个 Swift 程序者，你也会有同样的感受，而且你会有一个优势就是更加容易理解其中的一些概念，比如可选空等。那些吸引我的 Kotlin 特性有以下这些： —— 可选空值：这能够让你的产品开发避免三分之二的异常，非常具有吸引力。而且在你使用 Kotlin 之前你根本不会意识到 Java 是那么的一团糟。 —— 函数式编程：对的， Kotlin 是支持函数式编程的，和 Scala 一样。 —— 默认值和命名参数：这又是那些你如果不去尝试，你就根本不知道你会错过的东西。在 Kotlin 中你可以为函数的参数设置默认值，同时给每个参数一个命名。这让代码的易读性和可读性呈指数级地提升。 —— 智能转换：是不是对先用 instanceof 然后再做转换的做法累觉不爱了？这些看上去是非常冗余的，但是按道理也应该很容易被避免。现在 Kotlin 自动为您做到了。 还有很多 Kotlin 值得讨论的特性，继续深入的话都能够分条别类地写成长编大论了。概括地说： Kotlin 是一门提升和完善 Java 缺陷的一门语言。他的学习曲线对于 Java 开发者来说非常缓和。这不是一个 要么/或 的问题，因为你完全可以在你的 Java 基础上同时使用它们俩。 Kotlin 将大大提高你的效率，从中长期来看这会让你成为一名更加优秀的程序员。 观点：Kotlin 将大大提成你的效率，从中长期来看这会让你成为一名更优秀的程序员。 00. 某某大神级人物 某某大神级人物是谷哥一名技术探索专家，精通 AE 、 PS 、 AI 、 PR 等的安装和卸载，熟练 Java 、 Ruby 、 Swift 、 Python 、 Objective-C 等的单词拼写，掌握 Windows 、 Linux 、 MacOS 等系统的开关机，并同时掌握 VA 、 VC 、 VD 以及 VE– 、 B# 、 SBython 和 JB 语言的大神级人物，目前正在 Psychiatric Syndrome 公司开发自己独特的产品，使用的是 Cobol-R 和 Lisp-C 语言混合开发。 哦，啊，你好，我有说过吗？我很喜欢 Kotlin ，对，是的，但是还是不能撼动 PHP 的地位，确定。它真的，噢，对，他真的算是一门好语言！我同意，我同意。 但是，我却不赞同你过早的使用它或者你可以采用一种观望的态度，你可以让其他人先踏入坑，你再踩着他们进场，难道不是更好吗？ 当然，这样做你也就不至于浪费很多时间，人生苦短，都用 Python ，是吗？至少，因为我觉得 Kotlin 还不够强大，还不够成熟，而且，对的，很重要的一点，我想说的是，噢，对，你难道不知道吗？它是，是这样的，它居然没有一个靠谱的静态代码分析工具。这让我这种在上千人面前工作的人很懊恼！ 这是不可以接受的，谷歌也不会接受这种语言，这让安卓开发者们很难堪，是的，对的，你没猜错， Kotlin 不会成为主流语言。 我第一次看到 Kotlin 的时候，我就觉得这门语言有能力成为热门讨论的话题语言，但是，请相信我，这会让你很囧，真的，它那函数表达式写起来非常像 Callback Hell ，噢，知道 Callback Hell 吗？我不想在这里解释很多，你可以谷歌或者百度搜索，这是一种地狱，你会在写代码的时候感觉自己陷入了地狱之中，真是，真是很不好，很不好的一种体验，难道不是吗？ 有人说他是空安全的，我不认为，你会认为加了一个 ？ 就是空安全了吗？至少我不这么认为，这种看法太过于草率，是的，太草率了，如果真的加了一个问好或者叹号就能达到空安全的目的，那么你是不是说价格破折号就能达到 DEBUG 的目的？显然这太滑稽了。 我承认，这门语言有点现代化，比如我就喜欢他和 Forthron 友好的交互性，它能转化成 VB 语言，是世界上除了 PHP 和 Python 之外最好的语言，他还能生成 Object-B 语言，对的，你没听错，它能生成在电视机、电冰箱、空调上使用的 Object-B 语言（对，他们都是 Object ），他不需要打分号，我不得不说这是一种突破，我曾经写的代码里有三分之一的代码量是分号，这是让我唯一感到高兴的一个新特性。难道我错了吗？噢，好吧。 够了，够了，我不掩饰我喜欢 Kotlin 语言的扩展功能，它甚至能把 Int 扩展成接口，把数字扩展成 38 进制，还能把异常扩展成工具类。这是现代语言应该有的特性，就像 SQL 一样能够写 GUI 也能够写服务器。总而言之，它很像一门现代语言，我不得不承认。 即使如此，我并不推崇它，世界上还有更好的语言，你说不是吗？像 PHP 这种世界级流行语言，它能做所有的事情，能写类、能扩展接口、能写出优雅的函数、能够不断更新、可以写界面也可以写后面，能泡妞，能下饭，还能够带你上天堂。所以，我们可以观望，有时间我们可以更多的学习 AutoCAD 、 AutoDraw 这种高级自动化语言，这不是更美好吗？你说是吗？ 噢，对了，我也许忘了，对对，但是我不能忘，你知道 Swift 吗？他是 MAC 公司的现代化语言，我想你应该知道，现在已经在开发版本 4.0 了，我很欣赏 MAC 公司的这门语言以及他们的员工所做的一切，但是，对，但是， Kotlin 才发布 1.0 版本， Kotlin 明显有抄袭 Swift 的可能，你可能已经想到我要说什么了，对的，如果你继续使用 Kotlin 可能会面临被 MAC 公司起诉的危险哦，嗯，那很不值得，我的天啦。 总之，对，我是不是说太多了？噢，没关系，我还好，你是不是很累了？你是不是随机采访了 17 位码农对 Kotlin 的看法？噢，我的天！他们对你说了什么？他们都做了什么？噢，该死，他们之中居然连一个戴眼镜的近视眼都没有看到，他们肯定没认真面对过显示器吧？他们怎么能对你发表意见呢？好吧，你还好吗？噢，我很好，对，没关系，真的没关系，什么？我的主治医生来了吗？噢，那不好意思，抱歉，我想说我很抱歉，再见，我的朋友！希望今天的话能对你有益！再会！ 观点：无观点…… 三、写在最后我已经在圈子里看到有朋友翻译过这篇文章了，我也提到了，他的翻译虽好但是每位谷歌大牛的简历确是贴图，如果你对谷歌专家称号的大牛怀有敬仰之情的话，我觉得就算我翻译的一般，你也会有限考虑我的文章的，哈哈。 作者： Antonio Leiva我很喜欢 Kotlin ，我已经学习 Kotlin 好几年，在安卓开发中采用并理解所有这些知识，那样你可以不费吹灰之力地掌握它。Twitter | Google+ | Linkedin | Github原文地址： https://antonioleiva.com/google-kotlin/","tags":"kotlin 翻译"},{"title":"C4D中四种基本的曲线运动控制方式","url":"/2017/05/31/the-4-ways-control-spline-movement-in-C4D/","text":"一、前言最近刚开始学习 Cinema 4D 这款强大的建模软件的运动相关知识，暂时学习的东西不多，看的时候也能当场理解掌握，但是发现回过头来学过的东西早已经抛之脑后了，看来学习方法还是不对，必须学习之后要做总结吧，特别是一些很容易混淆的概念和方法，不总结真的是云里雾里啊。 今天总结一下最近学习的 C4D 中几种最基本的控制曲线运动的方法，为什么要说曲线控制呢？我们知道，骨骼是不能直接绑定在曲线上的，骨骼只对 Mesh 多边形物体绑定有效，所以控制曲线的运动需要一些特殊的方法实现，目前我知道的有以下 4 种方式，仅供总结参考： 曲线追踪的方式 XPRESSO控制曲线 IKSpline的骨骼控制 IK骨骼结合XPRESSO控制 下面一一作简单介绍，只介绍他们的大概实现原理，具体的比较和优缺点暂时只能从表面现象观察吧，在实际应用中还需要更多的学习和探索。 二、四种基本方式1. 曲线追踪的方式 这是最简单也很有效的方法，甚至连曲线 Spline 都不用建立。 如图建立 5 个空物体（ Null ），设置好空物体的显示，用来控制曲线的操纵杆。然后在运动图形菜单中添加曲线追踪器。 在曲线追踪器中设置追踪对象为 5 个空物体，设置追踪模式： Connect All Objects ，设置曲线类型为： Akima ，这样保证曲线比较平滑。 添加 Sweep 扫描这样能更加直白地看到曲线的运动形态，接着就可以用空物体代表的控制杆来操控曲线了。是不是很方便？ 2. XPRESSO控制曲线 Cinema 4D 中的 XPRESSO 标签功能很强大，才刚刚接触就被它的易用性震撼到了，真的恨强，对于不喜欢编程的朋友来说确实是一剂良方。用 XPRESSO 控制曲线的思路也很简单： Spline 由点控制，点又由操控点通过 XPRESSO 控制，达到最终操控点控制曲线的目的。 和上面第一种方法类似，建立 5 个空白对象作为操控点，然后还需要建立一个 4 分段（ Segment ）的 Spline （添加 Sweep 扫描这样更加清晰直白），如下图： 记住，和上面方法一样，为了让曲线更加平滑过渡，需要设置曲线的形态： Akima ，设置点插值方式为： Uniform ，数量多一点： 添加 XPRESSO 标签，设置他们之间的连接，这里需要用到层级（ Hierarchy ），层级能够迭代输出某一层或者某一序列的物体，通过层级把 5 个控制点分别输出并控制 Spline 上的对应点的 Global Position ，那样曲线上的点的位置就会跟随相对应的控制点了： 关于 XPRESSO 大家可以参考官方文档，也可以看我推荐的数字人博客的相关文章，我这里对层级（ Hierarchy ）的参数设置是采用的绝对路劲（ Absolute Reference ）和开始路劲向下（ D ）、迭代路劲往后（ N ），具体参数定义我在文章之后参考资料中会写到，具体设置如下： 这样 XPRESSO 就起作用了， Spline 上的每个点都受到相应控制点的控制而跟随运动： 3. IKSpline的骨骼控制 除了以上方法后，还有就是大家很容易想到的是通过骨骼绑定控制曲线运动的方法，骨骼运动系统非常强大，但是，骨骼并不能直接绑定曲线，他只能绑定 MESH 多边形物体，那么如果利用骨骼的话可以怎么做呢？——答案是 IKSpline 骨骼标签。 如下图建立 Spline 曲线并设置相应参数，在工具栏中选 Spline to Joints 命令转化曲线为关节，转化后在根关节添加 IKSpline 标签。 设置 IKSpline 参数，把曲线和末关节分别拖入对应参数位置，同时，我们并不能直接通过控制骨骼来控制曲线，那样会很不方便，包括移动旋转等，我们需要创建操纵杆来达到控制骨骼关节和曲线的目的，所以我们需要添加手柄（ Handles ），并创建其形态（ Add -&gt; Create ），依次创建出现 5 个操纵杆： 这样我们就达到目的了，通过操纵杆控制 IKSpline 骨骼然后间接达到控制曲线的目的： 4. IK骨骼结合XPRESSO控制 上面的方法中使用了 IKSpline 关节控制曲线的方式，除此之外，我们其实还可以利用关节运动加上 XPRESSO 控制功能也能同样达到控制曲线的目的。 思路大致是这样的：我们通过创建骨骼关节并利用 XPRESSO 把相应关节绑定到曲线的对应点上，再利用 IK 标签控制骨骼运动从而实现间接控制曲线运动的目的。 IK 标签是骨骼绑定中最常用的角色命令，它和 IKSpline 不同，利用 IK 标签可以绑定到多边形上来创建达到更加复杂的形体运动。 同上一步骤，创建曲线，分段，设置参数，转化成关节，因为我们需要添加 XPRESSO 标签，最好是再创建一个空物体作为所有关节的根物体（ Root ），在根物体上添加 XPresso 标签，同时给关节添加 IK 标签，设置 IK 尾关节和添加目标手柄： 同上面的第二种 XPresso 方法一样，设置其节点和参数如下： 是不是动起来了？而且和骨骼绑定是相一致的。 三、总结控制曲线的用途还是有很多的，毕竟建模后很多管子之类的物体都是用曲线方式生成更方便，当然直接用模型也可以，如果用曲线的话，那么就可以用以上方法结合其他的途径达到各种运动控制的目的了。上面的几种方法中，其实只有骨骼关节控制才能够达到一个控制点的位移影响所有点的位置的效果，其他方法只能控制曲线上当前点的位置和状态，如果觉得抽象，你完全可以尝试一下。 简单的回顾总结一下自己刚刚学习的一点新知识， C4D 才开始学习，还有很多东西都是未知的，学海无涯啊，在学习的海洋里畅游的时候，还是不能忘记回头看看自己曾经游过的地方遇到了些什么精彩或者惊险的玩意，不然很容易忘记接下来该怎么前行了，所谓学而不思则罔，思而不学则殆！ 最后，强烈推荐参考数字人老师的学习空间相关博客文章，下面参考资料里有链接，他的文章内容讲的非常详细到位而且也有很多应用实例讲解，详细你会仔细品读的。 参考资料：数字人的学习空间： http://digitalman.blog.163.com/C4D R17 帮助文档： http://c4d.cn/help/r17/US/html/1000.htmlXPRESSO路劲设置参数解释： U: [up one hierarchical level] U 代表向上一层，往上寻找 D: [down one hierarchical level] D 代表向下一层，往下寻找 P: [previous object on current hierarchical level] P 在当前层的前一个物体对象 N: [next object on current hierarchical level] N 是当前层的下一个物体对象 F: [first object on hierarchical level] F 是的第一个对象 L: [las object on hierarchical level] L 是最后一个对象","tags":"c4d"},{"title":"修理更换苹果AIR笔记本键盘","url":"/2017/05/29/repaire-and-replace-mac-air-keyboard/","text":"一、起因真是折腾人啊！就因为家里灰尘太多，用清洗套装把 Mac Air 笔记本稍微清洗了一下键盘，然后就出问题了…… 问题是这样的：只要我按下 Q 键就会出现 Q1 ，相当于 Q 和 1 键粘贴一起了，按 1 键也是一样的效果，同时出现 Q1 的结果，不仅 Q 键，同样从 W2/E3/R4/T5/Y6/U7/I8/O9 一直到 0 和 P 才没问题。虽然我可以打出两个字后删除一个以达到自己的目的，但是那样编写文字是不是有点太痛苦了？我就说苹果笔记本是不是有点过于脆弱啊——就像笔记本中那一位弱不禁风的金枝玉叶似的。 这个问题我在网上搜过，一般是键盘进水短路或者老化引起，外国也有朋友遇到这种情况了：Q: 1=q1, w=w2, e=e3, r=r4, etc. help! ，他的最终解决方案也是——更换笔记本。 我的苹果笔记本曾今也拆过，而且无线网卡也有点问题了，现在又不能保修，鉴于苹果笔记本那专业而又特殊的键盘结构，我要么送给专业人士修理，要么自己继续折腾。其实我拆过的笔记本不少，包括我现在手里的 DELL M3800 是我用全部件组装的，拆过联想天逸某型号、惠普 NC6400 、联想 B460 、IBM T400 、惠普 ENVY 17-3D 、惠普 ENVY17 （某型号） 、戴尔 M6700 、戴尔 7420 、神舟 P177SM 、富士通某型号、宏碁笔记本、HP MINI 210 、HP 2560P ……即使苹果的玩意都是精工细作，我还是想牛刀小试一下。我想过两个方案： 拆开后用吹风机吹干键盘尝试让它重回正轨 如上述方法不行的话就直接更换键盘吧 针对专业的 MAC 笔记本，准备好以下专业点的东西： 专用的螺丝刀就有三把 一把拔铆钉的钳子（听说可以用指甲钳） 100个左右的键盘小螺丝 新的相匹配的键盘 一些辅助小工具 二、拆解第一步拆开笔记本的后盖，然后拆下笔记本的电池和喇叭。拆主板前，要小心查看所有的排线，主板上的网卡和硬盘是可以不拆下来的，但是旁边的排线需要小心拿下。 特别注意主板右上角风扇的位置有个小螺丝，拧松取下后才能顺利把主板拿下。下图是拆掉主板和电池喇叭后。 主板和小板没必要拆开，可以不用分开，但是风扇和排线要拿下。 这里要告诫拆机的朋友们，键盘背光由背光板和背光膜组成，背光膜是粘在背光板上的，可以和背光板一起拆下，我之前就是没注意，把他们分开拆下来了，导致背光膜撕掉了几个小块，不过这并无大碍。 记住，在把背光膜周边稍微掀开后直接把背光板撕下来，因为背光板是粘在键盘上的，但是被背光膜覆盖了看不到，需要掀开周边。拆下背光板后，键盘被四周螺丝和里面大量的铆钉固定着。这是最棘手的部位。 但是也不要紧，因为键盘已经无药可救，卸掉小螺丝后，直接拔掉键盘吧，注意要慢慢拔，刚开始比较难，用点力，后面很轻松，拔掉后键盘变形很大，基本废弃。 拆解的最后就是细致活了，留下的铆钉一颗颗小心翼翼的用钳子拧下来，我在拧的过程中剪断了好几个，不过只要不是太多，还是没有大碍的，毕竟固定的螺丝孔还是有这么多的。 最后就简单了，只要把键盘放好，然后四周用原来的小螺丝固定，里面铆钉留下的孔也用小螺丝固定好，大功告成！ PS: 我之前在拆掉背光板后，用吹风机把背光板和没有拆下来的键盘都吹了一下，居然把数字键 1-9 的功能都修复了，但是 Q|W|E|R|T|Y|U|I 字母键还是老毛病，如果你的键盘能在吹风机吹干后有效的话，那就没必要拔铆钉换键盘了！ 三、说明苹果笔记本确实是精工细作，主板很小巧，和电池的固定也都非常巧妙，所以也不难拆卸，只要你准备好专用的螺丝刀就可以。但是键盘就比较麻烦了，要拔掉铆钉，还要换上螺丝，立马变得不专业了。 我的 DELL M3800 也是类似的键盘固定在 C 壳上，但是只有四周由小螺丝固定，拆解还是很方便的。 最后，大家如果也有拆苹果笔记本的话，在全部步骤弄好之后，记住先不要全部拧上所有螺丝和组件（比如我不会装上喇叭或者电池，有些排线像网卡线也不需要连接上，而且螺丝也只是先拧上几个就可以），先测试好没问题了，最后再把全部螺丝拧好那样会比较好，毕竟有时候我们忘了个别排线或者忘了哪个小部件、小螺丝没弄好，导致又要重新拆一次的麻烦事。 最后祝大家 DIY 愉快！","tags":"mac diy"},{"title":"我为何早先于你学习并应用Kotlin","url":"/2017/05/23/why-you-learn-new-skills-so-later/","text":"一、说在前面在 Google IO 大会后，Kotlin 马上成为各个群里最火热的话题！一时间， Kotlin QQ 群， Kotlin 微信群， Kotlin 公众号， Kotlin 参考文档……瞬间爆炸！是啊，谁让谷歌钦定了呢？讯息大爆炸之后是大家争先恐后抓住时间赶上潮流：了解新技术，准备学习新技术，找志同道合的同志（ ），为什么不呢？不行动就会落后，落后就要挨打，挨打打屁股。 但是，话锋一转，我想问的是，作为 Java or Android 开发技术人员的你，为什么才开始学习 Kotlin ，或者甚至夸张地才了解到 Kotlin 这个单词？其实，非科班出生的我早已经在 Kotlin 1.0 版本发布之后的不久就开始学习并使用上了，什么都比你晚，但是今天我第一次感觉自己站在了更高的位置（应该摔得更疼），或许我们应该是时候改变一下自己因循守旧的思维模式了，那么就这个话题，以下将展示仅本人个人的观点论断！注：前方非高能，高手们请再会。 二、我的做法非科班出身，也非技术大牛，无实战经验，可以说我是技术小渣渣。为啥我还能大言不惭？其实并不是说我技术功底有多厚，而是我提前了解了一些大家视而不见或者未曾了解的东西，因此显得我比你捷足先登了一步，尽管大牛们学习之后理论和实战都要比我厉害，不过谁知道以后还会不会出现程序潮流界类似改朝换代的时刻而你继续错过呢？未然。我想表达的思路从下载一个 APP 开始。 1. 首先说说我是怎么下载简书APP的在我们学习或者开发过程中遇到问题时总会进行百度或者 Google 搜索，我去年下半年开始自学编程，记得当时做一个辅助软件时，我百度找了很多相关技术文章，最先了解到的是发现一批 CSDN 上的博客，很多技术大牛做的技术分享，顺其自然地我就在手机上下载了 CSDN 这个 APP，但是这个软件有个致命 BUG ：居然不能搜索（现在新版本已经解决），另外文章排版也不是特别舒服导致阅读体验不是很好，对于我来说这就显得不是那么友好了。然后我在网页上找到了其他好几篇不错的文章，同时令人满意的是排版也非常友好，对，就是它：简书。我能估计 99.99% 的程序员都知道【简书】这个 APP ，但是对于门外汉的我来说确是酒逢知己一般，顺势在手机上下载了这个软件。在之后的日子里，利用手机通过搜索找到了不少学习材料，一直到现在我都很喜欢在简书上搜索某些方面的技术文章，当然我现在也安装了掘金 APP 和其他一些软件。 2. 我是如何了解到 Kotlin 的？为什么要说简书这个普普通通的 APP 呢？因为：搜索真的很重要！去年的我被一款叫做 Unity3D 的游戏开发软件吸引住而开始打算自学编程应用。这个软件使用的脚本是 C# ，我以前上大学的时候有点 Java 基础，初学问题不算太大。恰逢其时，我同学叫我帮忙弄个微信聊天功能辅助小软件，算桌面 GUI 程序，我当时感觉可以自己做，便拿来作为自己的练手项目，直接用 Java 就开始搞起来了。不得不说 Java 还是很难的，弄了个把月也没做出来什么，倒是学习了不少新知识，与此同时我找到了 JavaFX ，你眼里的老技术对我来说确是焕然一新啊。在不断遇到问题解决问题的过程中，一个叫 TornadoFX 的开源项目走进我的视线： Lightweight JavaFX Framework for Kotlin ，不就是用其他语言实现的 JavaFX 吗？我为啥就关注它了呢？那是因为： GitBooks ！是的，当其他的 JavaFX 参考文件都只有官方那苍白无力的文档的时候， TornadoFX 有 PDF 甚至 Mobi 、 ePub 手机版的详细阅读资料，我下载到手机里，如饥似渴地阅读起来，在感受 Kotlin 魅力的同时尝试使用着 TornadoFX 的强大！ 3. 怎样高效学习 Kotlin 呢？对于很多人来说，为了一个开源库而学习一门新的语言完全不值！刚开始我也这样认为，后面我发现新语言的新特性让我能用少量代码写出更优雅的程序，我立马下定决心学习 Kotlin ，在学习之前我还搜索了与 JVM 相关的其他语言，包括： Scala 、 Groovy 、 Clojure ，我觉得学习一门语言就应该有所比较，对它的历史也要有点认知，相比强大的 Scala ， Kotlin 的学习曲线很缓，适合新手的我！这期间，我的第一步就是下载 Kotlin 官方 PDF 文档，看完后找到了一本适合中国国情的好书：《 Programming Kotlin 》，我算是入门了。之后 TornadoFX 的文档我看了三遍，边看边用，边用边学，边学边想，最大化的理解和消化这些新知识。对了，学习一门语言，我不看视频，我觉得那是一种浪费时间的表现。 4. 为什么我起步晚但学习 Kotlin 却比有些人早？是偶然吗？我看未必。曾今我做过服装相关的行业，接触到服装行业的业内人士就知道，服装的流行元素首先是从国外流传到台湾的，然后再从台湾到香港，慢慢的，香港那边开始传播到了内陆。技术行业其实也不例外，如同服装流行元素一样，如果你想掌握先机的话，你必须先去国外了解最新的相关行业动态。怎么了解？还是搜索！而且要用英语搜索！我很喜欢用英文搜索，虽然之前也属于翻墙一员，但是能力有限不能解决 Chrome 上奇怪的 500 internal server error 而不能愉快地进行 Google 搜索，但是我用起了百度英文搜索！那句“您可以仅查看：英文结果”的话总是让我忍不住一点。同时，我在用 Google 搜索文章并阅读后总能额外了解到一些新知识，虽然是浅尝辄止，但并不影响我对新生事物的初识：我不会放过好文章中的一些专有名词以及相关技术。曾今我在 TornadoFX 的 Gitbooks 中的一段话中我就同时了解到了 ControlsFX ， JFXtras ， ReactFX ， RxJavaFX ， RxKotlin ， RxKotlinFX 这些专业技术的概念和存在： TornadoFX:It can work in conjunction with other popular JavaFX libraries such as ControlsFX and JFXtras. It works especially well with reactive frameworks such as ReactFX as well as RxJava and friends (including RxJavaFX, RxKotlin, and RxKotlinFX. 5. 我们需要勇于做一些尝试作为一位入门级“大师”，我并没有资格教大家如何学习，但是我却发现了不少人思维的局限性。我很赞同安卓大神 stormzhang 的一个理念：如果是好文章，他肯定会逐字逐句看完并理解到位，并不是收藏起来之后阅读！对于我们大部分人来说，收藏有那么点自欺欺人的意思。我们也经常看到有人说：新语言坑太多了，填都填不过来！又或者：先瞧一瞧吧，万事初生三分热，等过了再看！（而之后一直没看）还有甚者：新版本出来旧版本全挂，尝试新的就是找死！……我们会被这种理所当然的赞同思维所影响，不知不觉的顺从了“有的人”的想法和行动。其实，给自己一点时间，给自己一点勇气，认识自己，审视过去，改变自己，尝试一下，去探索新的世界，说不定就能感受到更加新鲜的空气呢？记得几个月前我尝试第一次采用英语在 StackOverFlow 上求助一问题，那是我第一次用英语公开表达，而意想不到的是被相关主题作者回复并采纳到新功能更新中，我也为自己感到惊奇，哈哈！ TornadoFX [Change Log][1.7.0] - 2017-03-04EventBus subscribe(times = n) parameter will unregister listener after it has fired n times (http://stackoverflow.com/questions/42465786/how-to-unsubscribe-events-in-tornadofx) 6. 那么是技多不压身还是贪多嚼不烂？“技术多而不深则罔，技术虽少而精则怠，技术多而深则通啊”！再说安卓界大牛 stormzhang 的一段分享主题：“为什么你觉得自己还达不到高级的标准”，他的观点很明确：你没有一个擅长的领域！是的，技多不压身，但是你就是不能跑在别人前面，问问我们自己：我擅长什么？我有什么厉害之处？我们为什么不精通某一个方向？何乐而不为啊！话又说回来，在时间资源非常紧缺的现代社会里，贪多而嚼不烂的想法自然占据了很多人的心理。我们疲于工作，忙于应酬，还有家事：房子、车子、老婆孩子……哪有时间掌握多门手艺？精通一门足矣。我也是这么认为的，但是，但是，但是，自从我在一个博客上看到一位老师既能用多种 3D 软件设计又能吉他弹奏，又看到一位魔术大师既是演员又能弹吉他还能编程后，我觉得，有时候我们更应该跳出思维的圈子，改变一下自己的思维方式。技多不深不可取，技少但精也别骄，技多且精最可贵！题目来自这篇文章： 简书 cleverfan 的文章：重新认识java（零） — 不积跬步无以至千里： http://www.jianshu.com/p/21b67448b286 三、最后是不是感觉又上了一课？哈哈，我等小菜又有何德何能啊？！话又说回来，最近一个新闻：华为 35 岁员工被辞，貌似要验证我同学在 5 年前的一个预测，他的大意是：相当一部分人在 40 岁左右会被公司辞退！！！理由很简单：公司不愿意用不断提升工资的方式来保留一位老员工而更愿意用更少的金钱加一点点培训经费雇佣一位能做同样复制工作的年轻员工！简单，暴力，而充分！ 参考资料：TornadoFX Guide: https://edvin.gitbooks.io/tornadofx-guide/content/1.%20Why%20TornadoFX.htmlKotlin Reference: http://kotlinlang.org/docs/reference/stormzhang (blog): http://stormzhang.com/","tags":"随笔 kotlin"},{"title":"分享几个实用的HEXO博客功能插件","url":"/2017/05/16/share-several-extra-functionality-of-hexo-plugins/","text":"一、前言即使是作为一名前端完全新手，也不希望自己的博客页面功能过于简单，虽然花哨的功能不需要，但是一些最基本的大众化模块还是要有吧，我的 Hexo 博客使用的主题 Phantom （下文中提到的主题文件夹也就是这个文件名，但是我会写成 ${theme_dir} ）就是属于功能模块比较简单的那种主题，借助 Hexo 强大的功能扩展能力，自己动手整合了一些有用的插件到我的博客中，主要包括：非插件化的 CSS 样式控制、文章表情符 emoji 显示、博客 RSS 订阅功能、文章图片懒加载显示、静态搜索 search 功能等！ 添加了这些功能后，感觉踏实多了， 可折腾我不少时间了，现在我把这些功能添加的过程大致的分享一下，作为自己的备忘，也希望帮助到其他有需求的前端小白们更好地使用 Hexo 博客构筑，如果是大神的话，你可以忽略了。 二、功能模块我这里主要使用也是推荐应用的功能模块主要就以下几个： Markdown 中自定义 CSS 样式 添加博客 RSS 订阅功能 文章添加 emoji 表情符 文章里图片的懒加载功能 强大的静态搜索功能插件 1. Markdown 中自定义 CSS 样式有时候写文章需要一些特殊的字体或者颜色表现样式，这其实很简单，不需要任何插件，直接在 md 文章文件中使用 HTML 加 CSS 样式就可以了，就像这样： 1234&lt;p markdown=\"1\" style=\" color: red; font-weight: bold; \"&gt;PS: （2017-05-15更新）更新的内容如下......&lt;/p&gt; PS: （2017-05-15更新）更新的内容如下…… 另外 Hexo 官方说明的方式是添加 ` 和 ` 标签块，结果和上面不使用标签块是一样的： 123456&#123;% raw %&#125;&lt;p markdown=\"1\" style=\" color: red; font-weight: bold; \"&gt;PS: （2017-05-15更新）更新的内容如下......&lt;/p&gt;&#123;% endraw %&#125; 尽情的在 style=&quot;&quot; 中添加你想要的样式吧。 2. 添加博客 RSS 订阅功能虽然这个功能有点鸡肋，但是如果你是一位优秀的博主，日志文章被大量客户访问阅读，那么你必定需要 RSS 订阅模块，为那些有需求的客户提供日志订阅的功能。我的博客 RSS 订阅就是一个 XML 文件的链接，这个 XML 文件需要由插件自动生成，这个插件是： hexo-generator-feed ，在 GitHub 上有相关应用说明：hexojs/hexo-generator-feed 。直接安装这个 Hexo 插件： 1$ cnpm install hexo-generator-feed --save 安装好之后，每次 hexo g 命令或者启动服务都会自动生成 atom.xml 文件（你也可以设置成 rss2.xml 文件，具体设置参考官网吧），然后把 RSS 订阅的地址链接到这个文件即可！ So easy! 3. 文章添加 emoji 表情符表情符这么重要的写作功能怎么能不具备呢？习惯了在微信、 QQ 上聊天的表情符号，写作也必须来几桶表情符是吧？！ 其实表情符都是一些小图片，如果直接在写文章的时候像插入图片一样插入表情符，那会比较痛苦，所以我们需要安装一个表情符简写渲染的插件： hexo-filter-github-emojis ： 1$ cnpm install hexo-filter-github-emojis --save 安装后在根目录下的配置文件 _config.yml 中进行具体配置，还可以添加自定义的表情符（我已经把网站上的部分表情符下载到本地改成自定义表情符了 ）： 123456789githubEmojis: enable: true className: github-emoji unicode: false localEmojis: your_emoji_1: src: http://your/emoji/path/img1.png your_emoji_2: src: http://your/emoji/path/img2.png 这样你在写文章的时候可以直接简单地用这种格式表达表情符： :your_emoji_1: :your_emoji_2: ，最后文章渲染显示就是类似这样的表情图片了： 具体说明可以到插件地址查看： hexo-filter-github-emojis ，内有详细使用配置说明。 4. 文章里图片的懒加载功能这是我很喜欢的一个功能，也是折腾我最久的，毕竟新手加小白 。图片的懒加载在很多地方都能看到，比如微信订阅号的文章就是采用图片懒加载的方式显示，这是一个流量为王和手机阅读的时代，大量的图片容易造成不必要的流量耗费，不过懒加载并不是减少流量使用，而是当不需要显示的时候就不要耗费多余的流量了，增加用户体验吧。 实现这个功能对我来说有点繁琐，首先需要安装渲染插件： hexo-renderer-marked-lazy ，然后还需要一个 JS 库： Echo.js ，最后需要手动写一点点 JS 代码，一步一步的来： 1$ cnpm install hexo-renderer-marked-lazy --save 上面安装插件之后，在根目录配置的文件 _config.yml 中添加以下配置： 123marked: lazyAttr: data-echo blankSrc: http://your/loading/path/blankSrc.gif 配置原理我等下说，接着需要在生成文章的页面添加相关 JS 脚本，我直接下载了 echo.js 这个脚本（连接：echo.js ），保存在博客主题下的文件夹中：${theme_dir}/source/scripts/echo.js ，接下来在主题文件夹下的模板文件 ${theme_dir}/source/after-footer.ejs 中添加应用 JS 代码，这样生成的每篇文章都会包含这个 JS 脚本： 123456789101112&lt;%- js('scripts/echo.js') %&gt;&lt;script&gt; echo.init(&#123; offset: 100, throttle: 250, unload: false, callback: function (element, op) &#123; console.log(element, 'has been', op + 'ed') &#125; &#125;); // echo.render(); is also available for non-scroll callbacks&lt;/script&gt; 学过前端的朋友应该一眼就能看清楚这是怎么实现的，他的基本原理就是利用 hexo-renderer-marked-lazy 插件把 md 文章中的图片标记： ![real image](http://url/to/real/img.jpg) 渲染成带有 data-echo 标签的 HTML ： &lt;img src=&quot;blankSrc.gif&quot; data-echo=&quot;http://url/to/real/img.jpg&quot; alt=&quot;some desc&quot;&gt; ，这样显示的不是真实的图片，而是你在配置文件中配置的 blankSrc 所指向的临时图片，最后由 echo.js 脚本替换临时图片 src 为 data-echo 表示的真实链接并加载真实的图片。 怎么样？也比较简单吧，确实折腾了我很久，需要的就 Add 上吧！ 5. 强大的静态搜索功能插件现在哪个页面没有搜索功能？内容为王的前提下，搜索功能显得尤为重要！此乃必不可少的功能，大牛、 dalao 有的组件，我们小菜也要有！ 关于 Hexo 博客搜索功能，我参考了不少文章，但是要么比价复杂，要么需要技术支持，折腾了我一天！最后在这篇文章：完美解决Hexo静态博客搜索问题中找到了引荐的静态搜索开源项目： Tipue Search ，但是这篇文章不适合我等新手，而这篇官方文章： hexo-generator-tipue-search-json 给了我足够的安装指导！ 参考了 hexo-generator-tipue-search-json 这个插件的官方说明后，我也是按部就班地尝试，但是也有稍微不一样的地方，如果你需要这个功能，按照说明不能解决的话，那就按我的做吧， 先安装插件： 1$ cnpm install hexo-generator-tipue-search-json --save 这个插件主要用来生成搜索引擎需要的 JSON 数据，会保存在搜索引擎目录 tipuesearch/tipuesearch_content.json 文件中。安装好插件后，还要下载 Tipue 搜索插件的源码：Tipue Search 点击下载 ，下载完把压缩包里的 tipuesearch 文件夹复制到你的主题目录： ${theme_dir}/source 下，然后修改主题文章模板文件 article-full.ejs 的内容（这些 ejs 文件一般都在 ${theme_dir}/layout/_partial 下，自己找一下吧），添加如下搜索功能的代码，它的作用大概是相当于收录文章转化数据的意思吧： 12345&lt;div id=\"tipue_search_content\" style=\"display: none\"&gt;&lt;/div&gt;&lt;!-- 下面的是之前有的，上面的代码是添加的 --&gt;&lt;!-- Content --&gt;&lt;%- item.content %&gt; 接着需要在有搜索功能的页面加入 JS 和 CSS 引用，在主题根部模板文件 after-footer.ejs 中添加以下引用和脚本，使 JS 发挥搜索的作用： 1234567891011121314151617181920212223242526272829&lt;link href=\"&lt;%- config.root %&gt;tipuesearch/css/tipuesearch.css\" rel=\"stylesheet\"&gt;&lt;script src=\"&lt;%- config.root %&gt;tipuesearch/tipuesearch_set.js\"&gt;&lt;/script&gt;&lt;script src=\"&lt;%- config.root %&gt;tipuesearch/tipuesearch.js\"&gt;&lt;/script&gt;&lt;!-- 这里可能有一些其他原来文件里的代码，也可以没有 --&gt;&lt;script&gt; $(document).ready(function () &#123; var searchInput = $('#tipue_search_input'); searchInput.tipuesearch(&#123; 'mode': 'json', 'minimumLength': 2, 'contentLocation': '&lt;%- config.root %&gt;tipuesearch/tipuesearch_content.json', highlightEveryTerm: true &#125;); $('#search-form').on('submit', function (e) &#123; e.preventDefault(); $('#tipue_search_content').show(); $('#content').hide(); &#125;); searchInput.keyup(function () &#123; var length = $(this).val().length; if (length &lt; 1) &#123; $('#tipue_search_content').hide(); $('#content').show(); &#125; &#125;); &#125;);&lt;/script&gt; 最后，在主题页面模板文件 article-page.ejs 中添加搜索内容显示框（ div ）的 HTML 代码： 1234567891011&lt;% if(item.addSearch) &#123; %&gt; &lt;form id=\"search-form\"&gt; &lt;div class=\"tipue_search_left\"&gt;&lt;img src=\"&lt;%- config.root %&gt;tipuesearch/search.png\" class=\"tipue_search_icon\"&gt;&lt;/div&gt; &lt;div class=\"tipue_search_right\" style=\"width:80%;\"&gt;&lt;input type=\"text\" name=\"q\" id=\"tipue_search_input\" autocomplete=\"off\" required placeholder=\"&lt;%= __('search') %&gt;\" style=\"width:80%;\" /&gt;&lt;/div&gt; &lt;/form&gt; &lt;div id=\"tipue_search_content\"&gt;&lt;/div&gt;&lt;% &#125; %&gt;&lt;!-- 下面的是之前有的，上面的代码是添加的 --&gt;&lt;!-- Content --&gt;&lt;%- item.content %&gt; 这里有必要说明一下，我这里使用了 &lt;% if(item.addSearch) { %&gt; 这样的 ejs 语法块，其实很简单你也能看的懂，我是在 md 文章的开头 Front-matter 中添加了一个 addSearch 的变量，值为 true 表示生成的这个页面是带搜索功能的页面，值没有或者为 false 表示这个页面不会添加搜索引擎和显示搜索结果，关于 Front-matter 的解释就是每篇文章的开头 --- 包含的代码部分，就像这样： 123456789---title: 分享几个实用的HEXO博客功能插件subtitle: Share several extra useful functionality of Hexo blog via plugins or codedate: 2017-05-16 13:39:19tags: [Hexo]cover_index: cover.pngcover_detail:addSearch: false--- 完成了所有配置，这时候你只需要新建一个提供搜索的页面即可，就像你创建 Tags About Category 页面一样： 1$ hexo new page search 如果你和我的一样设置，记得在 source/_post/search 文件夹下的 index.md 中的 Front-matter 添加 addSearch: true 参数。好了，就这样OK了，希望你能理解吧。 三、总结越到后面确实有点小复杂，我也是折腾了不少时间啊，主要是对于前端我几乎完全门外汉，没办法，只能自己琢磨了。不求花哨，但求够用。 最后，在这里还是需要提醒一下，如果博客配置文件 _config.yml 中指定博客地址有根目录的话，比如我的博客根目录是 root: / ，那么有很多地方需要加上 config.root 才能正确显示相关的链接（也包括资源的引用，你可以看到我的代码中不少包含了 config.root ），我设置了根目录，所以直接使用 Tipue 搜索引擎的时候搜索出来的文章显示的链接少了 /blog ，那样都是错误的地址，这时候就要手动更改一下 hexo-generator-tipue-search-json 这个插件的源码使它在生成的 JSON 数据的链接里加入 /blog ，修改按以下步骤： 找到博客根目录下 node_modules/hexo-generator-tipue-search-json/index.js 文件 打开并找到这行代码： case &#39;url&#39;: return actualPost[item] = post[&#39;path&#39;]; 修改代码添加上根目录： case &#39;url&#39;: return actualPost[item] = hexo.config.root + post[&#39;path&#39;]; 好了，希望对你有帮助。 参考资料：Hexo Tag Plugins: https://hexo.io/docs/tag-plugins.htmlTipue Search: http://www.tipue.com/search/Plugin: hexo-generator-tipue-search-json: https://www.npmjs.com/package/hexo-generator-tipue-search-jsonPlugin: hexo-filter-github-emojis: https://www.npmjs.com/package/hexo-filter-github-emojisPlugin: hexo-filter-github-emojis (Github): https://github.com/crimx/hexo-filter-github-emojisPlugin: hexo-generator-feed: https://github.com/hexojs/hexo-generator-feedPlugin: hexo-renderer-marked-lazy: https://www.npmjs.com/package/hexo-renderer-marked-lazyEcho.js: https://github.com/toddmotto/echo/","tags":"hexo"},{"title":"记一次Unity3D中WWW加载本地图片很慢的BUG","url":"/2017/05/11/bug-of-www-load-local-texture-in-unity3d/","text":"事情是这样的，昨天有朋友在群里询问一个 Unity3D 本地图片资源加载相关的问题：“切换图片的时候，要等3,4秒才能显示切换的图片”，今天上线后看到了，然后自己也做了测试，发现并没有重现这个问题，如是两个人讨论了一番。 一、问题需求大概是这样：从本地文件中加载图片到游戏中，然后显示到界面上。朋友的代码大概是这样的： 123456789101112131415161718192021void Start () &#123; string file = \"file://E:/file/path/to/image.jpg\"; StartCoroutine(LoadImage(file, imageCard));&#125;public IEnumerator LoadImage(string path, Image image)&#123; WWW www = new WWW (path); while (! www.isDone) &#123; Debug.Log (DateTime.Now); yield return www; Debug.Log (DateTime.Now); &#125; Texture2D texture = www.texture; Sprite sp = Sprite.Create (texture, new Rect (0, 0, texture.width, texture.height), new Vector2 (0.5f, 0.5f)); image.sprite = sp;&#125; 运行后的控制台打印的结果显示加载本地图片的过程中花了3秒钟时间： 12345/11/2017 9:49:43 PMUnityEngine.Debug:Log(Object)5/11/2017 9:49:46 PMUnityEngine.Debug:Log(Object) 二、解决显然上面的 3 秒钟时间是不符合逻辑的，即使是加载远程服务器的大图估计也花不了这么长的时间，因为没有做过 Unity3D 的开发，我的第一反应就是去官网找了 WWW 的相关用法： You can inspect the isDone property to see if the download has completed or yield the download object to automatically wait until it is (without blocking the rest of the game).When using file protocol on Windows and Windows Store Apps for accessing local files, you have to specify file:/// (with three slashes). 所以根据以上的建议我告诉朋友试试这两种方案： 用了 isDone 就不用 yield 了，也就是删除 while(! www.isDone) 改图片路径的字符串 file:// 成 file:/// 很显然，结果是无用功，以上只是逻辑问题，不可能会引起长达 3 秒的加载时间。接着我自己在电脑上做了测试，莫名的发现，不管怎样，我的图片加载很顺畅！这又是什么鬼？ 既然软件没问题，马上我怀疑上了硬件问题，朋友马上拿来固态硬盘一试！————结果是悲哀的，固态硬盘上花费了 4 秒钟的时间！ 只能 Google 一下了，果然有同学也遇到过这个问题：www-Class for loading local texture is very slow ，高手的解释大意是：只要设置了网络的 gateway ，但是 Unity 又没有真正的连接网络，那么这个卡 3-4 秒的问题就会出现！太神奇了啊！有木有！ 所以，最后的解决方法肯定是拔掉网络了！哈哈，不过，我朋友并不是这样解决问题的，而是：卸载 Unity3D 并砸了电脑！？，搞错了是关闭了他安装的虚拟机！因为装了虚拟机后有两个网络适配器导致！ 三、总结真是奇怪啊，不过还是学到了经验，至少了解了一下 WWW 的用法。希望这个解决方法对那些刚遇到类似问题的新手有一定的借鉴作用。 参考资料：www-Class for loading local texture is very slow: http://answers.unity3d.com/questions/623448/www-class-for-loading-local-texture-is-very-slow.html?sort=votesWWW Script Reference: https://docs.unity3d.com/ScriptReference/WWW.html","tags":"unity3d"},{"title":"【学习笔记】SWIFT中的构造函数","url":"/2017/05/05/learning-notes-of-swift-initialization/","text":"一、前言2017 年才接触苹果相关的东西，打算学习 Apple iOS 开发，无 Objective-C 基础，目前正在努力学习 SWIFT 的过程中。虽然有一点 Java 基础，不过还是被 SWIFT 这种现代语言震惊了！ SWIFT 简洁强大而又人性化，不过最近忙于照顾二崽，学习进度有点慢，也没有任何实操，总感觉很虚，暂时学习到 SWIFT 的构造函数，比起 Java 来说内容要丰富得多，做一个学习笔记，记录要点，掌握精髓，提高自己吧。 我看的是《The Swift Programming Language (Swift 3.0.1)》这本书，官方的作品，目前最新版本 3.1 ，使用 Readiator EPUB Reader 这个 Chrome 扩展应用翻阅的，蛮方便！另外，代码我用 IBM 提供的在线 Swift 代码编写运行交互网站： IBM Swift Sandbox 二、语言 SWIFT 构造函数基本要点 SWIFT 的构造函数用于结构体、枚举和类中：struct, enum, class ，作为实例的初始化，它的基本语法是 init 函数： 12345678910class MyClass &#123; var myProperty = 1 let myVariable:String init() &#123; //initialization code here...... myVariable = \"abc\" &#125;&#125;let instance = MyClass() 你可以不要定义构造函数，比如变量都已经有默认值没有必要自定义构造函数，那么我们可以使用默认构造函数： 12345678class MyClass &#123; var myProperty = 1 let myVariable = \"abc\" var myOptional:Bool? //no init() needed here......&#125;let instance = MyClass() 比较特别的默认构造函数是对于结构体来说，它有两个默认的构造函数，很人性化： 1234567struct AStruct &#123; var property = 1 var variable = true&#125;let twoByTwo = AStruct(property: 2, variable: false)let twoByTwo = AStruct() 同时对于枚举也有个含有 rawValue 参数的构造函数，仅此一个，注意：这个构造函数还是个可失败构造函数，学过 Java 的朋友都知道，构造函数可以抛出异常，在 Swift 中可以直接让实例化失败返回 nil ，那就是： Failable Initializer 可失败的构造函数： 123456enum MyEnum: Character &#123; case avar = \"V\", alet = \"L\", afunc = \"F\"&#125;let myFuncEnum = MyEnum(rawValue: \"F\")let unknownEnum = MyEnum(rawValue: \"X\") //Default Failable Initializer......print(unknownEnum == nil) //true 记住，如果我们手写了构造函数，那么就没有默认构造函数了（注意，手写了 Convenience 便利构造器不算，下文有介绍），对于类和结构体都一样，以下注释部分解除注释运行会报错： 123456789101112131415161718class MyClass &#123; var myProperty = 1 var myVariable:String? init(_ variable:String) &#123; //initialization code here...... myVariable = variable &#125;&#125;//let instance = MyClass() //compile-time error!struct AStruct &#123; var property = 1 var variable = true init()&#123; //initialization code here...... &#125;&#125;//let twoByTwo1 = AStruct(property: 2, variable: false) //compile-time error! Override 和 Required 关键字 SWIFT 中类的构造函数在子类中同样定义的话，必须需要 override 关键字： 1234567891011121314151617class ParentClass &#123; init() &#123; //initialization code here...... &#125; required init(_ param:Int) &#123; //initialization code here...... &#125;&#125;class ChildClass &#123; override init() &#123; //initialization code here...... &#125; required init(_ param:Int) &#123; //initialization code here...... &#125;&#125; 如上代码， required 修饰的构造函数在重载时不需要写 override 关键字，但是所有用 required 构造函数在子类中必须全部继承。 另外不得不说说 swift 很符合人类语言特性的超强重构功能： 123456789101112131415class MyClass &#123; var myProperty: Int init(_ digit: Int) &#123; myProperty = digit &#125; init(fromTwoDigits digits: Int) &#123; myProperty = digits / 10 &#125; init(fromThreeDigits digits: Int) &#123; myProperty = digits / 100 &#125;&#125;var instance = MyClass(5)instance = MyClass(fromTwoDigits: 25)instance = MyClass(fromThreeDigits: 265) Designated 和 Convenience 构造函数 Swift 把构造函数分为 Designated 指定构造函数和 Convenience 便利构造函数，为什么呢？看下面注释部分： 12345678910111213141516class MyClass &#123; var myProperty:Int = 1 var myVariable:String? init(property: Int) &#123; myProperty = property &#125; init(property:Int, variable:String) &#123; //self.init(property: property) //compile-time error! &#125; convenience init() &#123; self.init(property: 0) &#125; convenience init(_ variable:String) &#123; self.init() &#125;&#125; 上面代码中第一个和第二个都是普通指定构造方法，后面两个都是便利构造器，只有便利构造器才能访问指定构造器，而且便利构造器必须访问指定构造器！不管便利构造器是通过直接访问指定构造器还是通过访问其他便利构造器达到访问指定构造器的目的。另外要指出的是，可以直接定义便利构造器，你只需要访问默认的指定构造器就可以了，注意注释部分重复定义的错误提示哦： 12345678class MyClass5 &#123; var myProperty:Int = 1 var myVariable:String? convenience init(_ variable:String) &#123; self.init() &#125; //convenience init() &#123; self.init() &#125; //error: redeclaration of 'init()'&#125; 另外继承方面的重载很重要，先看下图： 简单的一个原则：要么自动继承，要么在符合“便利访问指定”的约束下重载父类指定构造器，这里代码就有点弱了，直接看官方的一个结构图很容易理解： 三、总结相比自己学过的 Java 构造还是有点复杂的，不过也还好，自己总结一下关键点，到时候自己实践的时候遇到问题随时准备查阅吧，毕竟纸上得来终觉浅,绝知此事要躬行！继续努力中~~~ 参考资料：Swift3.0初始化(Initialization): http://www.jianshu.com/p/f334f2c779c4The Swift Programming Language (Swift 3.1): https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/IBM Swift Sandbox: https://swift.sandbox.bluemix.net/ PS: （2017-05-15更新）如果类实现了某个定义了构造函数的接口（协议），那么他必须使用 required 关键字，同时符合继承的时候别忘了 override 重载符： 123456789101112131415protocol SomeProtocol &#123; init()&#125;class SomeSuperClass &#123; init() &#123; // initializer implementation goes here &#125;&#125;class SomeSubClass: SomeSuperClass, SomeProtocol &#123; // \"required\" from SomeProtocol conformance; // \"override\" from SomeSuperClass required override init() &#123; // initializer implementation goes here &#125;&#125;","tags":"swift"},{"title":"【翻译】Kotlin 1.1 新版本同样适合安卓开发者","url":"/2017/04/29/translation-of-kotlin-11-is-also-for-android-developers/","text":"一、前言本文是一篇翻译文，尽量遵照了原文的意思，加上本人英语水平有限，第一次做翻译，如有不当之处请多包涵！ 二、正文 标题：Kotlin 1.1 新版本同样适合安卓开发者2017年4月5号由 Roman Belov 发布这是一篇邀请文，由 Antonio Leiva 编写，一位安卓工程师、培训导师，也是《Kotlin for Android Developers》书的作者 Kotlin 1.1 的发布真是激动人心啊！新版本的新特性对于 Java 开发者来说非常有用，将给整个 JVM 开发界带来新的可能。 但是这些新特性，比如协程，或者类型别名（举个列子）的特性，看起来似乎和安卓开发者沾不上边。 我们仍然挣扎在低效率的、古老的 Java 6 版本中，以至于大部分开发者都忘记了还有其他平台的存在。 那么有一个很严肃的问题是： Kotlin 团队能否在带来新特性的同时保持对 Java 6 的兼容性呢？这个问题的回答是肯定的！ 所有的新特性仍然适用于 Java 6 ，同时作为扩展而适用于安卓开发者。更重要的是，今天我就要把这些都展示给您，让您知道在开发安卓程序过程中是多么的爽快。 类型别名：让你的事件监听更具可读性 当然，类型别名是有很多用处的。但是在我看来首当其冲的是在使用 lambda 表达式的时候能够让事件监听增加可读性。 如果之前你都还没有听说过类型别名的话，那我告诉你其实它的功能就是简单地重命名复杂的类型，使其更加具有可读性。 比如你有个 RecyclerViewadapter 类会接收一个事件监听。众所周知， RecyclerView 和 ListView 一样没有标准的处理单项视图点击事件的方式，所以我们必须动手自己写。 假设我们有个事件监听需要访问这个视图，我们的适配器类就像下面这样： 123class MyAdapter(val items: List&lt;Item&gt;, val listener: (View) -&gt; Unit) : RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;() &#123; ...&#125; 同时你的 ViewHolder 可能也需要接收这个监听事件，把它赋值给这个视图的点击事件监听者： 12345class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; fun bind(item: Item, listener: (View) -&gt; Unit) &#123; itemView.setOnClickListener(listener) &#125;&#125; 这种情况并不复杂，如你所见，在上下文之外，我们需要多次重复定义这个 lambda 表达式导致代码可读性降低。 但是，我们可以使用类型别名来表示一个点击事件监听者： typealias ClickListener = (View) -&gt; Unit这样我们就能在任意需要这个事件监听的地方使用它，像这样： class MyAdapter(val items: List&lt;Item&gt;, val listener: ClickListener) 或者 fun bind(item: Item, listener: ClickListener) { ... } 数据类的功能更加强大 数据类非常有用，因为它避免了大量的重复模板工作。但是他们在某些功能上的缺乏使得在有些场所并不能派上用场。 Kotlin 1.1 中引入的一个新特性就是继承性：数据类也可以继承自其他类。这就允许数据类成为封装类的一部分： 12345sealed class UiOp &#123; object Show : UiOp() object Hide : UiOp() data class Translate(val axis: Axis, val amount: Int): UiOp()&#125; 现在，封装类可以在父类之外定义了，就像这样： 1234sealed class UiOpobject Show : UiOp()object Hide : UiOp()data class Translate(val axis: Axis, val amount: Int) lambda 表达式的解构体 数据类在最初始的版本中就能够使用解构体，那是多亏了自动生成的 componentX() 方法。你可以把数据类的内容用这样的方式同时赋值给多个变量： 123data class Item(val text: String, val url: String) val (text, url) = item 但是之前，这个非常有用而强大的特性却不能在 lambda 表达式中使用。现在这种方式被改变了，你可以像这样做： 1234fun bind(item: Item) = item.let &#123; (text, url) -&gt; textView.text = text imageView.loadUrl(url)&#125; 这确实对于双元素或者字典中键值对设置非常有用，打个比方。 局部属性代理 属性代理被证明很有用，能够给类中的属性带来额外的效果。 比如，一个很有用处的例子就是懒加载代理，它能延迟赋值的执行直到这个属性第一次被使用。 懒加载对于局部变量也是很有用的，但是 Kotlin 却没有这样的特性。 现在，我们可以这样使用局部属性代理： 12345678910fun testLocalDelegation() &#123; val database by lazy &#123; createDatabase() &#125; val cache by lazy &#123; createMemoryCache() &#125; if (mustUseDatabase()) &#123; database.use &#123; ... &#125; &#125; else &#123; cache.use &#123; ... &#125; &#125;&#125; 尽管这个例子完全可以不使用懒加载来做，但是这有助于我们理解相关概念。 有一些相当耗资源的操作我们可能会执行也可能不会。通过使用懒加载，我们可以延迟资源的实例化直到我们必须使用它。 当第一次运行的时候，大括号里的代码就会被执行，同时也会缓存起来供之后使用。 再也不要管理那些 lambda 表达式中不需要使用的变量了 有一种常见的情形就是：我们在 lambda 表达式中所定义的参数到最后都不能派上用场。 这是因为在 Kotlin 1.0 版本中我们没有一种有效的方式来抛弃那些不需要使用的参数。 举个例子，在文章的前面我解释了如何使用代理更新一个 RecyclerView 的适配器，后面的代码是这样的： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; prop, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; 这个 prop 参数并没有用上，但是却必须要有它的定义。现在，你可以采用下划线来避免这种情况： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; _, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; 不过还有一种最糟糕的情况就是所有的参数你都不会使用。如果你的 lambda 表达式中有多个参数，尽管你不会使用但是你必须全部写出来。 现在，我们可以这样忽略他们： 1234var items: List&lt;Item&gt; by Delegates.observable(emptyList()) &#123; _, _, _ -&gt; notifyDataSetChanged()&#125; 这不仅使得我们减少了变量的定义，还能让代码更具有可读性。现在，你不需要去判断哪些参数用了哪些没用。这真是一清二楚！ 协程 在 Kotlin 1.1 中协程是一个令人振奋的新闻。尽管最后发布的依然是带有“实验性”的包，不过它已经功能齐全并且从今天开始你也可以开始在你的项目中使用了！ 协程能够让你像写同步代码块一样写异步代码，能够编写流畅的代码使得在某刻挂起任务的执行以等待结果的返回。 想必你有可能已经知道 Kotlin 中协程并不是一个库或者一种特殊的实现，它是一种语言特性，允许我们通过它创造实用的库。 因此，即使我们同样实现的代码看上去大同小异，但很重要的一点就是我们懂得协程归更到底是创建了子线程并在主线程中返回得到结果，这在安卓中尤为重要。 辛运的是， Kotlin 团队开发极其迅速，已经有好些库把协程的威力带到了安卓开发中。这里有几个例子： 第一个是你很可能希望看到的 Jetbrains 官方提供的库： kotlinx-coroutines-android ,这个库实现了协程在安卓中的使用。 Anko ，这个库的最新 beta 版本已经包含了协程对很多框架的支持。 同时也还有很多第三方库实现了他们自己版本的协程： AsyncAwait-Android by Niek Haarman Async / Await by Metalab 如果你仅仅只需要 Retrofit 的支持，你可以看一下这个库： kotlin-coroutines-retrofit by Andrey Mischenko 我强烈建议你们不仅要会使用他们，还要去看看他们是如何实现的。这也是开源的魅力所在！ 其他一些对于安卓开发者来说很酷的事情 在这个版本中还有很多其他的改进，但是我想重点提出几个关于针对安卓开发的功能。 第一个就是：你现在可以启用 Jack 编译器了，通过这样的设置： jackOptions { true } 。尽管谷歌已经宣布放弃 Jack 工具链，但是如果你还在 Java 8 中使用它，那么在 Android Studio 2.4 版本的的最终发布前，这会对你很有用。 另外一个，将会有一个新的潮流就是使用 @JvmOverloads 来实现自定义视图组件的构造函数，这从文字意义上来说就是可以用一句话来实现自定义视图的构造函数（不过确实是很长的一句话），通过一个构造函数和默认的参数值： 12345class CustomView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; ...&#125; 结论 Kotlin 1.1 带来的一大堆惊艳的特性毫无征兆地质问着我们：为什么还要继续使用 Java 呢？ Kotlin 带给安卓开发者的益处毋庸置疑，你完全可以从今天开始就使用 Kotlin 来开发安卓软件。 另外，如果你想学习使用 Kotlin 来开发安卓程序，那么你会对《[Kotlin for Android Developers]》(https://antonioleiva.com/kotlin-android-developers-book/)这本书感兴趣的。 这边文章发布在类目：安卓，访客文章和新闻标签下，订阅他的永久地址。原文地址：https://blog.jetbrains.com/kotlin/2017/04/kotlin-1-1-is-also-for-android-developers/ PS: 文中代码格式错乱，已更新，于 2018-10-27","tags":"kotlin 翻译"},{"title":"很有意思的一些 GIF 古典动画图片","url":"/2017/04/16/gif-images-of-historic-sharing/","text":"分享一些有意思的古典动画图片，来源于 media 网站。 原网址： Historic GIFs wot I did: https://artplusmarketing.com/historic-gifs-wot-i-did-d3e2c3afe71","tags":"photo"},{"title":"「Markdown」标记语言学习笔记","url":"/2017/04/13/markdown-for-writing-and-learn/","text":"一、前言相信在网上写文章的朋友都知道 Markdown 这门标记语言，刚接触这门语言不久就已经爱上它了，熟悉它就像拥有了一个操作简单而功能强大的有利武器！真是让人爱不释手，哈哈。 Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（ John Gruber ）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 Markdown 标记语言就是那么简单实在，很多软件或者网站都支持 Markdown 编写，平时常用的简书，还有 GitHub 上的 md 文件都是使用的 Markdown ，像 VSCode 和 IDEA 这些软件天生就支持 Markdown 的，使用起来简单方便，随手可写，相比以前写文章还要进行复杂的格式化或者源码编辑， Markdown 简直不能再轻松了！ 二、学习虽然简单，但是条条目目还是挺多的，我平时写作只需要一些最实用的就可以了。另外，可以搭配使用，记得要加空格哦！ 标题 用 # 表示标题，一个 # 表示一级标题，二个 ## 则表示二级标题， ### 表示三级标题，以此类推。 123# 这是一个一级标题## 这是一个二级标题### 这是一个三级标题 ——————这是一个一级标题——————————这是一个二级标题————————————— 这是一个三级标题 引用 引用直接用一个 &gt; 符号即可。 12&gt; 这是一段引用还可以直接换行哦！ ——————————这是一段引用——————————还可以直接换行哦！ 图片 &amp; 链接 用 表示链接，加个 ! 即 表示图片。 12[这是一个链接点我吧](http://liuqingwen.me)![这是一个图片别点我](sample-image.jpg) ——————————这是一个链接点我吧—————————— 代码 用编程软件写 Markdown 最爽的地方就是可以直接写代码，而且还有颜色标记和智能提示，让那些烦人的缩进去死吧！哈哈，简直不要太爽哦！ 123456`这是简单的代码 var x = 100`//这是一段很长的并且分行有缩进有高亮的代码，请用三个【`】表示var code = 'xyz';for(it = 0; it ++; it &lt; 10) &#123; code = code + it;&#125; ——————————这是简单的代码 var x = 100 12345//这是一段很长的并且分行有缩进有高亮的代码，请用三个【`】包括起来var code = 'xyz';for(it = 0; it ++; it &lt; 10) &#123; code = code + it;&#125; 列表 列表也很简单，有序的和无序的，注意有序的列表如果相隔有其他元素可能不会正常显示哦，就是说可能你的列表一直是 1 开头，自己尝试吧！ 1234* 无序列表1* 无序列表21. 有序列表12. 有序列表2 ——————————无序列表1 ——————————无序列表2 ——————————有序列表1 ——————————有序列表2 粗体 | 斜体 真的很 Simple 很 Young 也有点 Naive 。 12*这是斜体***这是粗体** ——————————这是斜体——————————这是粗体 其他：分隔符，表格 分隔符直接使用三个 * 表示，表格有点复杂了，不过还是好相识滴，注意 - 代表长度哦。 1234567这里有个分隔符看到了吗：***|星期一 |星期二|星期三 |星期四|星期五 |星期六 | 星期日特别长 ||:---: |:---:|:---: |:---:|:---:|:---: |:--------------------:|| 1 | 2 | 3 | 4 | 5 | 6 | 777777 || 栏目1 |栏目2 |栏目3 |栏目4 |栏目5| 栏目6 | 栏目7 || A | B |C |D |E | F | G | ——————————这里有个分隔符看到了吗： 星期一 星期二 星期三 星期四 星期五 星期六 星期日特别长 1 2 3 4 5 6 777777 栏目1 栏目2 栏目3 栏目4 栏目5 栏目6 栏目7 A B C D E F G 三、总结总之 Markdown 就是那么简单易用，学会这几个常用的暂时还是够用了，后续需要继续学习吧！当然，它实际上并不是一门编程语言，不要把它当做 Html 之类的标记语言来写哦，为文章发烧而生，它就是马克党！ Enjoy it! 哈哈！ 参考： 中文维基百科 Markdown ： https://zh.wikipedia.org/zh-hans/Markdown Hexo Tag Plugins ： https://hexo.io/docs/tag-plugins.html","tags":"随笔 web"},{"title":"「Hexo On Win10」新手搭建博客过程","url":"/2017/04/11/hexo-blog-creation-work-progress/","text":"一、前言现在博客框架真是多之又多， Wordpress ， Jekyll ， Hexo ， Octopress ，曾经我就简单尝试过 Worldpress ，过去的痛点已经忘却，开始新的历（tong）程（ku）吧！对于新手来说，直接、强大、稳健的框架最好不过，那么我推荐一套 Hexo 框架，这是一个最近很热门的博客框架，按照官方的说法是： Hexo:A fast, simple &amp; powerful blog framework 快速，简单，而且强大！对，你值得拥有。 当然，对于我这样的新手来说并不是吹牛皮那么简单，在搭建博客的过程中确实遇到了不少问题，没有任何前端经验的我一度想着放弃或者干脆放个 .txt 文本作为博客访问数据算了！还好，我做到了，于是有了这么一篇具有里程碑意义的文章，哈哈！在这里我把自己遇到的一些问题和解决方法例举出来，方便日后查阅或者能够帮助到其他新手朋友们愉快的搭建博客系统。 二、问题列表在解决问题之前，我自己主要参考了一篇来自同一个小密圈子里的朋友的文章，这篇文章可以肯定的说是业界的良心，新手的福音！ 传送门：最适合新手的 GitHub + Hexo 「大话」博客搭建教程，同时，我自己的博客系统暂时并没有发布到 GitHub 上，所以相关问题请参考这位朋友的文章或者 Google 吧！另外，一些细节问题比如安装 Nodejs ， NPM ， Git ， Hexo ，最好是参考官方网站文档一步一步进行。 NPM 不能正常使用 Git 不能正常使用 Blog 图片路径混乱 Hexo 自定义参数 三、解决方法1. NPM 不能正常使用生活在天朝就是有很多莫名其妙的问题，没解决前总是东寻西觅，看到解决方法后往往淡然处之：这就是生活吧！言归正传，在使用 Hexo 的主题过程中，有些主题需要使用 SCSS 作为 CSS 的渲染工具（具体我也不懂），那么在你的博客路径下执行 npm install --save hexo-renderer-scss 进行安装 SCSS ，然后你会得到这样的问题： 123456HTTP error 500 Domain Not FoundHint: If github.com is not accessible in your location try setting a proxy via HTTP_PROXY, e.g. export HTTP_PROXY=http://example.com:1234or configure npm proxy via npm config set proxy http://example.com:8080 解决办法：直接传送门吧：安装hexo-renderer-sass最终解决方案，dalao告诉我们直接执行以下命令： 12npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org 以后就愉快地使用 cnpm 取代 npm 吧！ 2. Git 不能正常连接 GitHub这个问题和上述 NPM 的问题是一样一样的，刚开始使用 Hexo 进行主题 Clone 的时候，发现根本不能用，只能手动下载 Zip 文件解压使用了。如果你一定要用 Git 而且又是在 Windows 上的话，你必须先安装 Bash on ubuntu on Windows ， Microsoft 微软官网有详细的安装指南： Installation Guide ，安装的前提是 Window10 的更新程序，这里有必要对类似我这种不熟悉 Linux 系统的朋友说一下， Windows 命令行 CMD 中的盘符 C: 对应 Linux 中的是 /mnt/c ，别弄错了哦，如有疑问，参考官网： Frequently Asked Questions ，嘿嘿。 安装好高大上的 Bash on ubuntu on Windows 后，还需要生成 GitHub 需要的 SSH Key 才能使用 Git ，这是为什么我们需要 Bash 的原因（ SSH Key 怎么直接在 Windows 上使用我不清楚，知道的朋友给我留言，感谢！）。不过这时候你在 Windows 上的 Git 并不能用于 Bash on ubuntu on Windows ，直接使用命令行： apt-get install git-all 获取 Git 吧！之后，关于生成 SSH Key 和上传到 GtiHub ，开头我说的那篇文章有详细说明：最适合新手的 GitHub + Hexo 「大话」博客搭建教程 ，唯一注明的一点是密钥文件在 Windows 中的位置： 1234# on Linux:C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub# on Windows:C:\\Users\\Qingwen\\AppData\\Local\\lxss\\root\\.ssh\\id_rsa.pub 3. Hexo 博客的图片路径混乱相信博客主题中关于图片路径问题肯定有很多新手朋友遇到过，写文章难免需要一些自己上传的图片，即使你用的图床，你在使用某些主题设置中还是需要设置图片路径的，比如我的主题就需要设置封面图片： cover_index: your_cover_image_path.jpg 。但是当你设置好后，你会发现根本图片不会按照你所期望那样正常显示出来，这里就需要说明一下 Hexo 中图片路径的设置了。 写文章时单独使用的图片相对路径设置 直接打开博客根目录下的配置文件： _config.yml ，设置： post_asset_folder: true 这样在每次生成写文章 hexo new &lt;post-article-title&gt; 的时候会生成和文章同名字的资源文件夹，图片存放在这个目录可以直接使用相对路径。 12345# Writing setting (_config.yml)post_asset_folder: true # default: false# Start serverhexo new &lt;your-post-article-title&gt;hexo server 任何页面引用全局图片相对路径设置 如果你的博客页面里引用了全局图片，比如每篇文章页面或者关于页面、分类页面等都显示一个默认的 Logo 或者 Cover 之类的图片，这个图片一般是在主题的配置文件 themes/&lt;your-theme&gt;/_config.yml 中设置的。一般设置成相对路径是没问题的，比如我的主题默认封面图片设置： 12# config in \"themes/&lt;my-theme&gt;/_config.yml\"default_cover_index: images/default_cover_index.gif 但是发现文章页面图片显示异常。这个时候用浏览器检查一下图片的显示地址，发现是我的图片路径不对，究其原因是我使用了服务器空间的非根目录存放博客： 12345# config in \"_config.yml\"# URL# If your site is put in a subdirectory, # set url as 'http://yoursite.com/child' and root as '/child/'root: / 所以，解决办法是手动修改主题下的相关页面的图片路径，比如我的主题目录下的文件 layout/_partial/article-index.ejs 中路径加上 config.root ： 12345&lt;% if(item.cover_index)&#123; %&gt; &lt;img src=\"&lt;%- config.root + item.path + item.cover_index %&gt;\" alt=\"\" /&gt;&lt;% &#125;else&#123; %&gt; &lt;img src=\"&lt;%- config.root + theme.default_cover_index %&gt;\" alt=\"\" /&gt;&lt;% &#125; %&gt; 由 JS 动态更改的图片路径设置 除了以上路径设置之外，还有一个可能遇到的问题是：文章中的路径被自己的 JS 库或者某个懒加载 Renderer 功能模块动态更改为配置中的图片路径，导致最后的显示异常。打个比方，在我的文章中某个图片 ![Image](path-to/real-image.jpg) 在发布文章后都会被 Renderer 改成临时显示地址 &lt;img src=&quot;temp-path-to/temp-image.jpg&quot; data=&quot;path-to/real-image.jpg&quot;&gt; ，这个临时地址就是在我的设置中设置的相对路径地址： temp_image_path: temp-path-to/temp-image.jpg ，这个时候这个临时图片就会显示异常： 1234&lt;!-- img src, the unexpected one --&gt;http://localhost:4000/2017/04/12/.../temp-path-to/temp-image.jpg&lt;!-- the expected one --&gt;http://localhost:4000/temp-path-to/temp-image.jpg 浏览器显示的是上方带有博客路径的地址，实际我需要的是统一全局地址的，这个时候怎么解决呢？其实，我也没有办法（如果你有好方案请告知，谢谢！ ），直接使用绝对地址了： 12# image path configtemp_image_path: http://localhost:4000/temp-path-to/temp-image.jpg Hexo 自定义参数关于自定义参数并不是什么问题，我建议大家在使用他人的博客主题的时候，找到博客主题的官方页面，一般主题开发者都会详细说明主题中参数的相关配置，如果需要自己定义一些参数方便页面的显示、跳转、或者其他功能，也很简单。在仔细参考了主题文件的一些代码后，配置参数可以分别写到相应的文件以及做相应的代码引用： root/_config.yml123# your custom configuration parametersyour_config_param: your_value# in .ejs file usage: config.your_config_param theme/_config.yml123# your custom configuration parametersyour_config_param: your_value# in .ejs file usage: theme.your_config_param Front-matter12345# your custom configuration parameters---your_config_param: your_value---# in .ejs file usage: item.your_config_param 很简单吧，配置对应引用： config theme item 就可以了，注意 Front-matter 是位于你的每篇博客文章的开头哦，具体参考官方文档吧。 四、总结所以就是那么复杂而又简单，最后还是那句话，建议多参考官方文档说明哦，祝你顺利搭建自己的博客，写出一篇又一篇好文章！有什么问题请给我留言，互相学习，天天向上！ 参考： 最适合新手的 GitHub + Hexo 「大话」博客搭建教程： https://smartbeng.github.io/2017/03/26/blogFinish/ 安装hexo-renderer-sass最终解决方案： https://github.com/tufu9441/maupassant-hexo/issues/225 Bash on ubuntu on Windows： (https://msdn.microsoft.com/en-us/commandline/wsl/about Hexo Docs 官方文档： https://hexo.io/docs/ Connecting to GitHub with SSH： https://help.github.com/articles/connecting-to-github-with-ssh/ Error: Permission denied (publickey)： https://help.github.com/articles/error-permission-denied-publickey/","tags":"hexo web"},{"title":"Godot游戏引擎的介绍与入门教程","url":"/introduction-of-godot-series/index.html","text":"关于 Godot 开源游戏引擎的一些介绍和简单的入门教程！ 欢迎关注我的博客： www.liuqingwen.me 所有 Godot 相关文章： Godot 入门介绍系列 所有的源码可以在我的 Github 仓库中找到： https://github.com/spkingr/Godot-Demos 另外我也会在以下专题网站发表相关的文章： 简书： https://www.jianshu.com/u/756bad579149 掘金： https://juejin.im/user/59d1d5b1f265da0656048d2b 知乎： https://zhuanlan.zhihu.com/godot INDIE NOVA （计划中）: https://indienova.com/groups/309 13. Introduction of Godot 3 part 13 - The player jump implementation and make a platform game文章链接： Godot3游戏引擎入门之十三：实现玩家的跳跃功能并完成一个平台小游戏（上） Godot3游戏引擎入门之十三：实现玩家的跳跃功能并完成一个平台小游戏（下） 本篇讲解到的知识点： 重力加速度知识和简单的跳跃实现方法 二次跳跃的实现 精确高度的跳跃实现 游戏场景结构与主要代码 三种敌人的行为和实现 其他的一些效果介绍 问题和总结 12. Introduction of Godot 3 part 12 - talk about collision and move_and_collide vs move_and_slide in KinematicBody2D文章链接：Godot3游戏引擎入门之十二：Godot碰撞理论以及KinematicBody2D的两个方法 本篇讲解到的知识点： 三种 2D 物理节点以及 Area2D 节点的回顾 碰撞层和碰撞掩码理论知识 KinematicBody2D 两个方法详述 简单的应用场景分析 11. Introduction of Godot 3 part 11 - introduce the particles system and make a shooter game文章链接： Godot3游戏引擎入门之十一：Godot中的粒子系统与射击游戏（上） Godot3游戏引擎入门之十一：Godot中的粒子系统与射击游戏（下） 本篇讲解到的知识点： Godot 中自带粒子系统的相关参数说明 游戏中应用到的其他几个有用的节点 太空射击游戏的所有场景构造及其关键点 游戏代码逻辑的核心部分解析 10. Introduction of Godot 3 part 10 - introduce some node types and make a new game文章链接： Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（上） Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（中） Godot3游戏引擎入门之十：介绍一些常用的节点并开发一个小游戏（下） 本篇讲解到的知识点： 学习了一些新的 Godot 节点，以及一些新的关键词 探讨了一些基本的游戏开发规则，包括编写代码的规范 编写实现游戏中相关逻辑代码，完成我们第一个完整的小游戏 9. Introduction of Godot 3 part 9 - add audio effects and UI elements文章链接：Godot3游戏引擎入门之九：创建UI界面并添加背景音乐 本篇讲解到的知识点： 给游戏添加 UI 控件元素，使用 CanvasLayer 节点 创建独立的游戏主界面，使用按键切换游戏场景 添加背景音乐和其他声音效果及动画、代码控制 其他小知识点：分组、代码中信号连接、字体资源等 8. Introduction of Godot 3 part 8 - add collectable elements and sub-scenes文章链接：Godot3游戏引擎入门之八：添加可收集元素和子场景 本篇讲解到的知识点： 创建子场景并实例化子场景： SubScene 连接订阅事件信号，处理信号： Signal 学习使用 Godot 3.1 动画中的方法调用特性： Call Method Track Area2D 节点简介，碰撞处理，多轨道动画设计 源码链接： https://github.com/spkingr/Godot-Demos/tree/v0.3 7. Introduction of Godot 3 part 7 - add collision and move player in map文章链接：Godot3游戏引擎入门之七：地图添加碰撞体制作封闭的游戏世界 本篇讲解到的知识点： Godot 3.1 中 Tile 瓦片的碰撞体添加和设置 Godot 中调试地图和玩家的碰撞体运行状态 几个有用的 GDScript 脚本代码技巧： export, flip_h, move_and_collide 源码链接： https://github.com/spkingr/Godot-Demos/tree/v0.2 6. Introduction of Godot 3 part 6 - make tile map in godot文章链接：Godot3游戏引擎入门之六：制作TileMap瓦片地图 本篇讲解到的知识点： 创建 TileSet 瓦片集资源 创建 TileMap 瓦片地图 介绍 Godot 3.1 中 TileMap 的一些新特性 源码链接： https://github.com/spkingr/Godot-Demos/tree/v0.1 5. Introduction of Godot 3 part 5 - base topdown movement文章链接： Godot3游戏引擎入门之五：上下左右移动动画（上） Godot3游戏引擎入门之五：上下左右移动动画（下） 本篇讲解到的知识点： 使用 AnimationPlayer 节点工具创建状态动画 使用代码控制玩家的上下左右移动功能 简单的摄像机使用和地图碰撞检测实现 通过代码实现 RigidBody2D 刚体节点的运动 4. Introduction of Godot 3 part 4 - add some cute animations文章链接： Godot3游戏引擎入门之三：移动我们的主角（上） Godot3游戏引擎入门之三：移动我们的主角（下） 本篇讲解到的知识点： 使用 AnimatedSprite 节点创建多个多图动画 使用 Sprite 节点和 GDScript 脚本代码创建背景动画 介绍了 Sprite 节点的原点设置：左上角或者居中 相关 GDScript 脚本知识：onready/$/position/animation 3. Introduction of Godot 3 part 3 - move the character with inputs文章链接：Godot3游戏引擎入门之三：移动我们的主角 本篇讲解到的知识点： 图片材质的导入模式 节点渲染顺序 最基础的 GDScript 脚本入门 使用脚本获取节点属性，侦听输入控制主角移动 2. Introduction of Godot 3 part 2 - game scene and node文章链接：Godot3游戏引擎入门之二：第一个简单的游戏场景 本篇讲解到的知识点： 几个基本的节点添加和使用 刚体碰撞体设置 静态碰撞体设置 材质背景平铺设置 可视化 Debug 功能 1. Introduction of Godot 3 part 1 - the editor文章链接：Godot3游戏引擎入门之一：熟悉编辑器界面 欢迎关注我的微信公众号：","tags":""},{"title":"50 Android Projects in 100 Days","url":"/100-days-50-android-projects/index.html","text":"Github address: https://github.com/spkingr/50-android-kotlin-projects-in-100-daysMore about me: http://liuqingwen.me I learn Android skills by self-taught, and use Kotlin in all my Android projects, I start this project for testing my skills and the improvement of my programme. The samples are all from the web site, I take it and just write by myself. Most of the projects I cannot finish it once I see the final output, so I will use Google search and StackOverFlow to find my solution, and try my best to make them done! And after all I have uploaded and updated the projects to my Github pages. If you have some questions please leave me a comment and I’ll appreciate it! To do list SurfaceView with canvas drawing HORIZONTAL VERTICAL Scroll Service with IPC Socket ContentProvider, Glide4 with Gif, Uploader, Activity as popup! Coroutines!!! Dagger, Retrofit! 39. Image Puzzle GameDate: 2018-8-10 What I learned from this demo: Make a simple image puzzle game with bitmap data operations: scale, draw, clip and so on Use the powerful BRVAH library to make a simple RecyclerView with XML layout Now remove the support library and migrate to androidX packages, so Anko layout is not supported right now PS: Restart(cold reboot) simulator to make the downloaded images appear in gallery. 12345# while build failed with this problem:# Cause: delight/rhinosandox/RhinoSandboxes# Try run the command in terminal:gradlew clean assemble -stacktrace Resource: How to Build a Jigsaw Puzzle Android Game 38. Simple Game With LibGdxDate: 2018-7-26 What I learned from this demo: Build simple game in Android with libgdx framework Manage multi scenes in the game with Stages and Camera and Sprites Use Box2D to do simple physics simulation in the game 37. Basic Unit And UI TestDate: 2018-7-25 What I learned from this demo: Basic unit test with JUnit4, and Espresso test framework in Android Use mockK to do Kotlin unit test: mock, spy, function callback captures and verify, ect Simple UI test in Android with Espresso and barista library: find view, click, recyclerview test and waiting and so on Resource: mockK 36. ServiceDate: 2018-5-17 What I learned from this demo: Create Service in Android app with IBinder, send notification background Use Guideline and Barrier in ConstraintLayout with Anko Layout Switch threads in RxAndroid, and in doOnComplete PS: To correctly use Guideline in constraint layout as the item ui in RecyclerView, I add the code bellow to make sure the layout renders expectedly: 1234567891011constraintLayout &#123; //Importance! layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT) guideline &#123; id = ID_GUIDELINE &#125;.lparams(width = matchConstraint, height = matchConstraint)&#123; orientation = ConstraintLayout.LayoutParams.VERTICAL guidePercent = 0.25f &#125; //... other code&#125; 35. Reactive Text SearchDate: 2018-5-2 What I learned from this demo: Create Observable from buttons and text changes, and merge them together Switch work threads, use doOnNext to show progress bar, and dispose them when needed Use arrays in XML resource, change the button appearance use the theme of Widget.AppCompat.Button.Colored 34. Basic Material AnimationDate: 2018-3-11 What I learned from this demo: Basic material animations for Fragment: enter/exit transition, shared element trasition Use coroutines to do time-consuming process: async, await in launch coroutines scope Build animations in ConstraintLayout use simple and powerful ConstraintSet and Transition Single activity as a container with multiple fragments Resource: Android KTX libraryKeyframe Animations with ConstraintLayout and ConstraintSetPS: While use shared element between fragments, I notice that, the 1st: add will not work but replace works, and 2nd: I set transitionName in the CardView instead of directly in the ImageView, which is the sub-view of CardView, that works! 33. ObjectBox And CoroutinesDate: 2018-3-7 What I learned from this demo: Work with ObjectBox to do the operations of databases Try to use Kotlin Coroutines to simulate some time-consuming process, it’s just a test Create the custom Application, use open source toast: Toasty, use NestedScrollView in CoordinatorLayout Resource: ObjectBox APIA test project, lost of functionalities are not accomplished yet. 32. Basic Android MVPDate: 2018-3-1 What I learned from this demo: Use the basic MVP pattern in Android project, to make code clean and testable Understand and use the abstract class and abstract methods The data binding in view, use this library: KotlinAndroidViewBindings (I just copied some code in my project.) Resource: KotlinAndroidViewBindings 31. Retrofit And RxAndroidDate: 2018-2-6 What I learned from this demo: Try with Retrofit and RxAndroid/RxJava to populate data in web service No XML layout now, try to work with pure Anko layouts, and the awesome Anko ConstraintLayout library How to change the layout in RecyclerView, and smooth scroll to the desired position Anko layout with Coordinator Layout, CardView, AppBar Layout, Toolbar and so on in design support library Pre-load or pause-load behavior in Glide image loader with RecyclerView while scrolling Resource: Anko ConstraintLayoutGlide: RecyclerView integration library 30. A Simple Custom View GroupDate: 2018-1-29 What I learned from this demo: It works like a charm!!! Five days cost to finish my little simple ViewGroup! That deserves. Got the basic idea of the processes of measure, layout, touchEvent, interceptEvent, and custom child layout parameters Use the scroller to make the movement much smooth Let the ViewGroup support click event and long click events 29. A Map DemoDate: 2018-1-23 What I learned from this demo: Show map, display marker, animate camera, search, deal with the latitude and longitude with A Map API Fullscreen control, show and hide the soft keyboard Work with the AutoCompleteTextView widget Resource: A MAP 28. Custom View The SwitchDate: 2018-1-21 What I learned from this demo: Custom view with basic workflow: measure, layout, draw and touch event handle Add custom properties or attributes in XML of view The basics of drawing api in Android with: path, paint, canvas 27. Play With Audio AssetsDate: 2018-1-11 What I learned from this demo: No XML layouts, the UI is completely replaced with Anko layout codes Work with assets in Android, and use AssetManager to do asset management Use SoundPool to play tiny wav audio files The basic knowledge of Anko layouts, pure code to make views 26. Better Practice Fragment (Part.1)Date: 2018-1-8 What I learned from this demo: Use RecylcerView list item animations with XML resource Understand the layout_behavior in CoordinatorLayout and layout_anchor property Try to use Fragment instead the Activity for better practise, it makes ViewPager very esay to build Work with the alert dilog with custom view The refactor is not so easy for me, a lot of functionalities is not finished, and I will try to get that done later. 25. Image UploaderDate: 2017-12-29 What I learned from this demo: Work with OKHttp to post data: upload files, get and send cookies, retrive the result Use XML Shape to create nice controls such as buttons Crop image and get the bitmap data through FileProvider in API greater than 24 Use view animations, Gson to analysis json string, indeterminateProgressDialog and alert in anko Realy thanks to the guy in Weixin group: @���е���ؤ���� for solving my code problem, while reuse the animation XML will cause wried things! 24. Photo WallDate: 2017-12-26 What I learned from this demo: Get images throught network, decode stream and display Use LruCache to cache the bitmap data for quick loading and recylcling data usage The same Activity is setted as both the Detail activity and Add New activity Load data from database in the asynchronized way If too much photos loaded, will the app get the changce to crash for OOM? I should try to figure it out! 23. Parcelable Data ObjectsDate: 2017-12-23 What I learned from this demo: Use Parcelable objects for data passing between activities Try Android unit test with: Instrumented Test and Unit Test Data class used both as Parcelable data object and Room database entity Solve two problems through StackOverFlow.com: Gradle error, failed to create directory and Empty test suite A lot of functionalities are not implemeted yet in this app, and I will finish that in my next days, hold on please! :) 22. Simple View PagerDate: 2017-12-16 What I learned from this demo: Work with ViewPager and TabLayout together to display walk through pages Use FragmentStatePagerAdapter as the ViewPager adapter and, the fragments Finish the activity so that make sure it is removed from the stack Resource: ViewPager Tutorial: Getting Started in Kotlin 21. The Floating WindowDate: 2017-12-16 What I learned from this demo: No layout XML files, but replace with the anko layout library to create views Use WindowManager to display floating views on the window Deal with the back button pressed to hide the activity, prevent from finishing the app After 2 months at last! Still 2 problems or questions:1. If back pressed and app is killed, then the android.view.WindowLeaked exception throws, how to solve?2. In the emulator, if the drag and drop event happens outside, then the position of the window will be some wried. 20. Simple Search Web ViewDate: 2017-10-18 What I learned from this demo: Work with WebView, set the client as WebViewClient and WebChromeClient Use the ToolBar instead of ActionBar, try SearchView in the tool bar Save and retrieve list items (StringSet) in shared preferences Add or remove item in RecyclerView, handle long click events on list item Deal with the WebView in NestedScrollView through the library: NestedScrollWebView in Github Resource: NestedScrollWebView 19. Downloader With NotificationsDate: 2017-10-14 What I learned from this demo: Use the basic notifications in Android The asynchronized task with doAsync and uiThread in Kotlin Basic file and stream operations in Android 18. Basic File OperationDate: 2017-10-4 What I learned from this demo: Use SharedPreferences to store and retrieve simple data Basic file operations on Android system, with openFileInput and openFileOutput Set data in the activity result and return 17. Simple Broadcast ReceiverDate: 2017-09-27 What I learned from this demo: Use one of the most four important components in Android: Broadcast Receiver Extension functions in Kotlin with AppCompatActivity Try the open-source library: EventBus to post and handle events, and also the CircleImageView Reduce the redundant of layout by using &lt;inlucde&gt; tags I am still not very clear with Android BroadcastReceiver, I found that it sometimes(especially for the single app development) can be replaced with EventBus through publish/subscribe pattern, is that right? 16. Self AdaptionDate: 2017-09-12 What I learned from this demo: Use the Fragments in the Activities Specify different layouts for different size or screen orientation (layout-land and layout-large) Use the empty view element as spacer or divider (be careful of the tag, it is View not view!) Dynamically set the visibility of view Till now I have no idea of using the savedInstanceState variable to make the data consistent while rotate the screen orientation, I should try it out later. 15. Database with RoomDate: 2017-09-04 What I learned from this demo: Use the Room Persistence Library for the basic database operations: INSERT/DELETE/UPDATE/QUERY Work with data class in Kotlin and the let lamda, and the annotations Convert date types to string types, and vice versa by using SimpleDateFormat or DateFormat.getDateInstance() Use adb shell and sqlite3 command to query the data in emulator local system files: 1234567891011$ adb quit# for more than one device found here$ adb devices$ adb -s &lt;emulator name&gt; shell$ cd data/data/me.liuqingwen.android.projectdatabaseroom/databases$ sqlite3$ .open &lt;dbname.db&gt;$ .tables$ SELECT * FROM &lt;table name&gt; 14. Activity AnimationsDate: 2017-09-01 What I learned from this demo: Transitions between activities use overridePendingTransition Work with animation xml resource file, the difference of “50%” and “50%p” (relative to parent view) Override onBackPressed method to finish the activity 13. Simple Activity with IntentDate: 2017-08-31 What I learned from this demo: Dealing with the custom item click handler of RecyclerView Start an intent to show another Activity by startActivityForResult Get the result from another activity through method of onActivityResult 12. Simple Animations with Custom ViewDate: 2017-08-30 What I learned from this demo: Custom view with custom attributes (declared in the xml value file) Use onMeasure to set the correct size of view Use onDraw to display the paint on the canvas Work with the basic object animator and animator-set The importance of lazy properties in Kotlin, think about the code: 12345678910111213141516//the [sunColor] initialized here will be changed later in the constructor through xml user attributes.private var sunColor = Color.RED/*//the paint directly initialized will not be the expected one, as the [sunColor] will change later for xml attributes!private val paint = Paint(Paint.ANTI_ALIAS_FLAG).apply &#123; this.color = this@SunView.sunColor this.isAntiAlias = true&#125;*///by using the lazy properties, the paint will be all right with the [sunColor] property!private val paint by lazy &#123; Paint(Paint.ANTI_ALIAS_FLAG).apply &#123; this.color = this@SunView.sunColor this.isAntiAlias = true &#125;&#125; 11. Simple Scalable ImageViewDate: 2017-08-28 What I learned from this demo: Multiple constructors from base class inheritance in Kotlin The basic knowledge of custom view: onLayout (left, right, top, bottom)/setFrame/onTouchEvent (Here I should always return true for receiving other touch events) Multi-touch handle on views: use event.actionMasked instead of event.action This is a bad-experienced project(view), I think I have to improve that in the next days while learning. 11. Simple ASynchronized WorksDate: 2017-08-17 What I learned from this demo: Try to figure out the differences of usage between Handler and AsyncTask in Android Download file from server via OkHttp and read bytes from InputStream RandomAccessFile for writing file content from specified positions Till now I can’t figure out a solution to pause/resume the downloading tasks, and I will try it later. 10. Swipe Refresh RecylcerViewDate: 2017-08-16 What I learned from this demo: Work with SwipeRefreshLayout and RecyclerView Basic AlertDialog and Snackbar usage Custom header and footer item in RecyclerView (It looks a little weird!) 9. Simple Video PlayerDate: 2017-08-14 What I learned from this demo: The first time explore the MediaPlayer with SurfaceView Got idea of LayoutParams and its simple properties (ConstraintLayout.LayoutParams) 8. Basic Material DesignDate: 2017-08-12 What I learned from this demo: Basic material design elements: DrawerLayout, NavigationView, CoordinatorLayout, AppBarLayout with Toolbar and FloatingActionButton Try to use the open source Android libraries of RxAndroid, OkHttp, Gson and Glide, ect. DrawerLayout must work with a child with layout_gravity property specified. Gson tokens with types: object : TypeToken&lt;List&lt;Turns&gt;&gt;() {}.type is the right way. Resource: RxAndroid, OkHttp, Gson, Glide 7. Recycle Image LoaderDate: 2017-08-11 What I learned from this demo: CardView is very cute, isn’t is? (I hate the gap between image nad text!) Load json data through HttpURLConnection and display view with ViewStub Use doAsync{} and uiThread{} to do asynchronized task in Kotlin Read InputStream in Kotlin and convert string data to JSONObject 6. Basic RecycleViewDate: 2017-08-09 What I learned from this demo: The very basics of RecycleView RecycleView with custom ViewHolder and Adapter, and layout managers Using lazy delegates , and Pair&lt;out A, out B&gt; in Kotlin In fact it shows the unexpected results, but I will give more effort to the RecycleView app next time. 5. Pick ImageDate: 2017-08-08 What I learned from this demo: Start a intent and get the result from that Work with local images and camera basics Display bitmap data on an ImageView 4. My LocationDate: 2017-08-06 What I learned from this demo: Work with LocationManager, get GPS providers and locations Got to know how to request specified Permissions at RunTime Use HttpUrlConnection to fetch data with url and read the input streams The LAMDA of thread and runOnUiThread My network is not stable, and I really do a lot of hard-code, I think I can fix that later. 3. Tip CalculatorDate: 2017-08-05 What I learned from this demo: Work with EditText and SeekBar The editor of keyboard event handler with EditText Strings to formatted floats and strings remove specified prefix in kotlin And what I cannot resolve is the focus changes of EditText and auto-hided of keyboard, I hope I can work it later. 2. Tap or Hold CounterDate: 2017-08-04 What I learned from this demo: Delegates of property in Kotlin Basic usage of Timer and TimerTask Button long click and touch event listener AnkoLogger for test (I have deleted the test code, but the activity has implemented the interface) 1. Tap CounteDate: 2017-08-03 What I learned from this demo: Menu resource file creation and option menus add to title bar Use anko library to reach UI elements easily in layout Button click handler with lambda in kotlin Change the button and text view appearance in editor Basic usage of Git commands and Github repository with AS 3.0 Resource: anko 资源：抓住iOS的未来 - 30天学习编写30个Swift小程序： http://www.jianshu.com/p/c6ae28964ad5100 Days of Swift ： http://samvlu.com/index.html【Android UI设计与开发】8.顶部标题栏（一）ActionBar 奥义·详解： http://www.cnblogs.com/yc-755909659/p/4290784.htmlAS 中 Git 与 GitHub 的使用入门： http://www.jianshu.com/p/f85eb3e9caec","tags":""},{"title":"Tags & Search","url":"/tags/index.html","text":"Android C4D DIY Godot Gradle Hexo Java Kotlin Mac Photo Python Swift Unity3D Web 书籍 翻译 随笔","tags":""},{"title":"About Me","url":"/about/index.html","text":"感谢光临我的博客！ 一、关于我Godot 积极布道者！ 厚积薄发，坚持将收获最大的回报！ 我认为，学习方式的效果：读书+练习 &gt; 仅读书 &gt; 视频教程。 二、本博客v1.32, 2019-01数学公式功能添加，添加的页面 js 文件而非 Markdown Render 添加 MathJax 数学公式支持 调整二三级标题大小及字间距样式 v1.31, 2018-12微小的调整 文章底部添加【上一篇】【下一篇】链接 更新 About 页面 v1.30, 2018-12一些适配，一些调整，一些 BUG FIX 修改替换原来默认的 Logo 添加导航栏，添加导航栏手机页面适配 更改底部社交网络图标和地址 开始大量使用 Font Awesome 字体 v1.22, 2018-11整理页面，解决加载速度慢的问题 删除老的依赖链接，改为新的，提升载入速度 修复包含大图的文章在手机上显示异常的问题 v1.21, 2018-10添加日历功能 添加日历云功能 添加不蒜子计数 使用 python 脚本提取 HTML 文件更新全部文章 v1.20, 2018-08更换电脑，更新插件 v1.10, 2017-05添加一些功能 添加 RSS 订阅功能 添加 Emoji 表情符 文章图片懒加载功能 静态搜索功能 v1.0第一次发布， 2017-04 三、其他 欢迎关注我的博客： www.liuqingwen.me 我的 Github 仓库： https://github.com/spkingr Godot 入门系列： http://liuqingwen.me/introduction-of-godot-series/ PS: 更新中......","tags":""}]}